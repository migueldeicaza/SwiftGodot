// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A stream peer that handles GZIP and deflate compression/decompression.
/// 
/// This class allows to compress or decompress data using GZIP/deflate in a streaming fashion. This is particularly useful when compressing or decompressing files that have to be sent through the network without needing to allocate them all in memory.
/// 
/// After starting the stream via ``startCompression(useDeflate:bufferSize:)`` (or ``startDecompression(useDeflate:bufferSize:)``), calling ``StreamPeer/putPartialData(_:)`` on this stream will compress (or decompress) the data, writing it to the internal buffer. Calling ``StreamPeer/getAvailableBytes()`` will return the pending bytes in the internal buffer, and ``StreamPeer/getPartialData(bytes:)`` will retrieve the compressed (or decompressed) bytes from it. When the stream is over, you must call ``finish()`` to ensure the internal buffer is properly flushed (make sure to call ``StreamPeer/getAvailableBytes()`` on last time to check if more data needs to be read after that).
/// 
open class StreamPeerGZIP: StreamPeer {
    override open class var godotClassName: StringName { "StreamPeerGZIP" }
    /* Methods */
    fileprivate static var method_start_compression: GDExtensionMethodBindPtr = {
        let methodName = StringName("start_compression")
        return withUnsafePointer(to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 781582770)!
            }
            
        }
        
    }()
    
    /// Start the stream in compression mode with the given `bufferSize`, if `useDeflate` is `true` uses deflate instead of GZIP.
    public final func startCompression(useDeflate: Bool = false, bufferSize: Int32 = 65535) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: useDeflate) { pArg0 in
            withUnsafePointer(to: bufferSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(StreamPeerGZIP.method_start_compression, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_start_decompression: GDExtensionMethodBindPtr = {
        let methodName = StringName("start_decompression")
        return withUnsafePointer(to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 781582770)!
            }
            
        }
        
    }()
    
    /// Start the stream in decompression mode with the given `bufferSize`, if `useDeflate` is `true` uses deflate instead of GZIP.
    public final func startDecompression(useDeflate: Bool = false, bufferSize: Int32 = 65535) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: useDeflate) { pArg0 in
            withUnsafePointer(to: bufferSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(StreamPeerGZIP.method_start_decompression, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_finish: GDExtensionMethodBindPtr = {
        let methodName = StringName("finish")
        return withUnsafePointer(to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Finalizes the stream, compressing or decompressing any buffered chunk left.
    public final func finish() -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(StreamPeerGZIP.method_finish, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears this stream, resetting the internal state.
    public final func clear() {
        gi.object_method_bind_ptrcall(StreamPeerGZIP.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
}

