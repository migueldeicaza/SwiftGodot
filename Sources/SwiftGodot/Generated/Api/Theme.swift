// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A resource used for styling/skinning ``Control``s and ``Window``s.
/// 
/// A resource used for styling/skinning ``Control`` and ``Window`` nodes. While individual controls can be styled using their local theme overrides (see ``Control/addThemeColorOverride(name:color:)``), theme resources allow you to store and apply the same settings across all controls sharing the same type (e.g. style all ``Button``s the same). One theme resource can be used for the entire project, but you can also set a separate theme resource to a branch of control nodes. A theme resource assigned to a control applies to the control itself, as well as all of its direct and indirect children (as long as a chain of controls is uninterrupted).
/// 
/// Use ``ProjectSettings/gui/theme/custom`` to set up a project-scope theme that will be available to every control in your project.
/// 
/// Use ``Control/theme`` of any control node to set up a theme that will be available to that control and all of its direct and indirect children.
/// 
open class Theme: Resource {
    override open class var godotClassName: StringName { "Theme" }
    public enum DataType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Theme's ``Color`` item type.
        case color = 0 // DATA_TYPE_COLOR
        /// Theme's constant item type.
        case constant = 1 // DATA_TYPE_CONSTANT
        /// Theme's ``Font`` item type.
        case font = 2 // DATA_TYPE_FONT
        /// Theme's font size item type.
        case fontSize = 3 // DATA_TYPE_FONT_SIZE
        /// Theme's icon ``Texture2D`` item type.
        case icon = 4 // DATA_TYPE_ICON
        /// Theme's ``StyleBox`` item type.
        case stylebox = 5 // DATA_TYPE_STYLEBOX
        /// Maximum value for the DataType enum.
        case max = 6 // DATA_TYPE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .color: return ".color"
                case .constant: return ".constant"
                case .font: return ".font"
                case .fontSize: return ".fontSize"
                case .icon: return ".icon"
                case .stylebox: return ".stylebox"
                case .max: return ".max"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The default base scale factor of this theme resource. Used by some controls to scale their visual properties based on the global scale factor. If this value is set to `0.0`, the global scale factor is used (see ``ThemeDB/fallbackBaseScale``).
    /// 
    /// Use ``hasDefaultBaseScale()`` to check if this value is valid.
    /// 
    final public var defaultBaseScale: Double {
        get {
            return get_default_base_scale ()
        }
        
        set {
            set_default_base_scale (newValue)
        }
        
    }
    
    /// The default font of this theme resource. Used as the default value when trying to fetch a font resource that doesn't exist in this theme or is in invalid state. If the default font is also missing or invalid, the engine fallback value is used (see ``ThemeDB/fallbackFont``).
    /// 
    /// Use ``hasDefaultFont()`` to check if this value is valid.
    /// 
    final public var defaultFont: Font? {
        get {
            return get_default_font ()
        }
        
        set {
            set_default_font (newValue)
        }
        
    }
    
    /// The default font size of this theme resource. Used as the default value when trying to fetch a font size value that doesn't exist in this theme or is in invalid state. If the default font size is also missing or invalid, the engine fallback value is used (see ``ThemeDB/fallbackFontSize``).
    /// 
    /// Values below `0` are invalid and can be used to unset the property. Use ``hasDefaultFontSize()`` to check if this value is valid.
    /// 
    final public var defaultFontSize: Int32 {
        get {
            return get_default_font_size ()
        }
        
        set {
            set_default_font_size (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_icon")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2188371082)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the icon property defined by `name` and `themeType`. Use ``clearIcon(name:themeType:)`` to remove the property.
    public final func setIcon(name: StringName, themeType: StringName, texture: Texture2D?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: texture?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_icon")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 934555193)!
            }
            
        }
        
    }()
    
    /// Returns the icon property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the engine fallback icon value if the property doesn't exist (see ``ThemeDB/fallbackIcon``). Use ``hasIcon(name:themeType:)`` to check for existence.
    /// 
    public final func getIcon(name: StringName, themeType: StringName) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_icon")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the icon property defined by `name` and `themeType` exists.
    /// 
    /// Returns `false` if it doesn't exist. Use ``setIcon(name:themeType:texture:)`` to define it.
    /// 
    public final func hasIcon(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_icon")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the icon property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasIcon(name:themeType:)`` to check for existence, and ``clearIcon(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameIcon(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_icon")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the icon property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasIcon(name:themeType:)`` to check for existence.
    /// 
    public final func clearIcon(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_icon_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_icon_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for icon properties defined with `themeType`. Use ``getIconTypeList()`` to get a list of possible theme type names.
    public final func getIconList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_icon_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_icon_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_icon_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for icon properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getIconTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_icon_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_stylebox")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2075907568)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the ``StyleBox`` property defined by `name` and `themeType`. Use ``clearStylebox(name:themeType:)`` to remove the property.
    public final func setStylebox(name: StringName, themeType: StringName, texture: StyleBox?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: texture?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_stylebox")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3405608165)!
            }
            
        }
        
    }()
    
    /// Returns the ``StyleBox`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the engine fallback stylebox value if the property doesn't exist (see ``ThemeDB/fallbackStylebox``). Use ``hasStylebox(name:themeType:)`` to check for existence.
    /// 
    public final func getStylebox(name: StringName, themeType: StringName) -> StyleBox? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_stylebox")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``StyleBox`` property defined by `name` and `themeType` exists.
    /// 
    /// Returns `false` if it doesn't exist. Use ``setStylebox(name:themeType:texture:)`` to define it.
    /// 
    public final func hasStylebox(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_stylebox")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the ``StyleBox`` property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasStylebox(name:themeType:)`` to check for existence, and ``clearStylebox(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameStylebox(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_stylebox")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the ``StyleBox`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasStylebox(name:themeType:)`` to check for existence.
    /// 
    public final func clearStylebox(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_stylebox_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_stylebox_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for ``StyleBox`` properties defined with `themeType`. Use ``getStyleboxTypeList()`` to get a list of possible theme type names.
    public final func getStyleboxList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_stylebox_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_stylebox_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_stylebox_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for ``StyleBox`` properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getStyleboxTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_stylebox_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 177292320)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the ``Font`` property defined by `name` and `themeType`. Use ``clearFont(name:themeType:)`` to remove the property.
    public final func setFont(name: StringName, themeType: StringName, font: Font?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: font?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3445063586)!
            }
            
        }
        
    }()
    
    /// Returns the ``Font`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the default theme font if the property doesn't exist and the default theme font is set up (see ``defaultFont``). Use ``hasFont(name:themeType:)`` to check for existence of the property and ``hasDefaultFont()`` to check for existence of the default theme font.
    /// 
    /// Returns the engine fallback font value, if neither exist (see ``ThemeDB/fallbackFont``).
    /// 
    public final func getFont(name: StringName, themeType: StringName) -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``Font`` property defined by `name` and `themeType` exists, or if the default theme font is set up (see ``hasDefaultFont()``).
    /// 
    /// Returns `false` if neither exist. Use ``setFont(name:themeType:font:)`` to define the property.
    /// 
    public final func hasFont(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the ``Font`` property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasFont(name:themeType:)`` to check for existence, and ``clearFont(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameFont(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the ``Font`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasFont(name:themeType:)`` to check for existence.
    /// 
    public final func clearFont(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_font_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for ``Font`` properties defined with `themeType`. Use ``getFontTypeList()`` to get a list of possible theme type names.
    public final func getFontList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_font_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_font_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for ``Font`` properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getFontTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_font_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 281601298)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the font size property defined by `name` and `themeType`. Use ``clearFontSize(name:themeType:)`` to remove the property.
    public final func setFontSize(name: StringName, themeType: StringName, fontSize: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: fontSize) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2419549490)!
            }
            
        }
        
    }()
    
    /// Returns the font size property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the default theme font size if the property doesn't exist and the default theme font size is set up (see ``defaultFontSize``). Use ``hasFontSize(name:themeType:)`` to check for existence of the property and ``hasDefaultFontSize()`` to check for existence of the default theme font.
    /// 
    /// Returns the engine fallback font size value, if neither exist (see ``ThemeDB/fallbackFontSize``).
    /// 
    public final func getFontSize(name: StringName, themeType: StringName) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the font size property defined by `name` and `themeType` exists, or if the default theme font size is set up (see ``hasDefaultFontSize()``).
    /// 
    /// Returns `false` if neither exist. Use ``setFontSize(name:themeType:fontSize:)`` to define the property.
    /// 
    public final func hasFontSize(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the font size property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasFontSize(name:themeType:)`` to check for existence, and ``clearFontSize(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameFontSize(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the font size property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasFontSize(name:themeType:)`` to check for existence.
    /// 
    public final func clearFontSize(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_font_size_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font_size_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for font size properties defined with `themeType`. Use ``getFontSizeTypeList()`` to get a list of possible theme type names.
    public final func getFontSizeList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_font_size_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_font_size_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_font_size_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for font size properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getFontSizeTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_font_size_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_color")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4111215154)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the ``Color`` property defined by `name` and `themeType`. Use ``clearColor(name:themeType:)`` to remove the property.
    public final func setColor(name: StringName, themeType: StringName, color: Color) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: color) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_color")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2015923404)!
            }
            
        }
        
    }()
    
    /// Returns the ``Color`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the default color value if the property doesn't exist. Use ``hasColor(name:themeType:)`` to check for existence.
    /// 
    public final func getColor(name: StringName, themeType: StringName) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_color")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``Color`` property defined by `name` and `themeType` exists.
    /// 
    /// Returns `false` if it doesn't exist. Use ``setColor(name:themeType:color:)`` to define it.
    /// 
    public final func hasColor(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_color")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the ``Color`` property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasColor(name:themeType:)`` to check for existence, and ``clearColor(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameColor(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_color")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the ``Color`` property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasColor(name:themeType:)`` to check for existence.
    /// 
    public final func clearColor(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_color_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_color_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for ``Color`` properties defined with `themeType`. Use ``getColorTypeList()`` to get a list of possible theme type names.
    public final func getColorList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_color_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_color_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_color_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for ``Color`` properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getColorTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_color_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_constant")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 281601298)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the constant property defined by `name` and `themeType`. Use ``clearConstant(name:themeType:)`` to remove the property.
    public final func setConstant(name: StringName, themeType: StringName, constant: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: constant) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_set_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_constant")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2419549490)!
            }
            
        }
        
    }()
    
    /// Returns the constant property defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns `0` if the property doesn't exist. Use ``hasConstant(name:themeType:)`` to check for existence.
    /// 
    public final func getConstant(name: StringName, themeType: StringName) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_constant")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the constant property defined by `name` and `themeType` exists.
    /// 
    /// Returns `false` if it doesn't exist. Use ``setConstant(name:themeType:constant:)`` to define it.
    /// 
    public final func hasConstant(name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_has_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_constant")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642128662)!
            }
            
        }
        
    }()
    
    /// Renames the constant property defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasConstant(name:themeType:)`` to check for existence, and ``clearConstant(name:themeType:)`` to remove the existing property.
    /// 
    public final func renameConstant(oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: oldName.content) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_rename_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_constant")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Removes the constant property defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasConstant(name:themeType:)`` to check for existence.
    /// 
    public final func clearConstant(name: StringName, themeType: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_clear_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_constant_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_constant_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for constant properties defined with `themeType`. Use ``getConstantTypeList()`` to get a list of possible theme type names.
    public final func getConstantList(themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let themeType = GString(themeType)
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_constant_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_constant_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_constant_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for constant properties. Use ``getTypeList()`` to get a list of all unique theme types.
    public final func getConstantTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_constant_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_base_scale")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_base_scale(_ baseScale: Double) {
        withUnsafePointer(to: baseScale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_set_default_base_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_base_scale")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_base_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Theme.method_get_default_base_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_default_base_scale")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if ``defaultBaseScale`` has a valid value.
    /// 
    /// Returns `false` if it doesn't. The value must be greater than `0.0` to be considered valid.
    /// 
    public final func hasDefaultBaseScale() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Theme.method_has_default_base_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1262170328)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_font(_ font: Font?) {
        withUnsafePointer(to: font?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_set_default_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3229501585)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_font() -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Theme.method_get_default_font, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_default_font")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if ``defaultFont`` has a valid value.
    /// 
    /// Returns `false` if it doesn't.
    /// 
    public final func hasDefaultFont() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Theme.method_has_default_font, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_font_size(_ fontSize: Int32) {
        withUnsafePointer(to: fontSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_set_default_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_font_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Theme.method_get_default_font_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_default_font_size")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if ``defaultFontSize`` has a valid value.
    /// 
    /// Returns `false` if it doesn't. The value must be greater than `0` to be considered valid.
    /// 
    public final func hasDefaultFontSize() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Theme.method_has_default_font_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_theme_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_theme_item")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2492983623)!
            }
            
        }
        
    }()
    
    /// Creates or changes the value of the theme property of `dataType` defined by `name` and `themeType`. Use ``clearThemeItem(dataType:name:themeType:)`` to remove the property.
    /// 
    /// Fails if the `value` type is not accepted by `dataType`.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func setThemeItem(dataType: Theme.DataType, name: StringName, themeType: StringName, value: Variant?) {
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: value.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Theme.method_set_theme_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_item")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2191024021)!
            }
            
        }
        
    }()
    
    /// Returns the theme property of `dataType` defined by `name` and `themeType`, if it exists.
    /// 
    /// Returns the engine fallback value if the property doesn't exist (see ``ThemeDB``). Use ``hasThemeItem(dataType:name:themeType:)`` to check for existence.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func getThemeItem(dataType: Theme.DataType, name: StringName, themeType: StringName) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_get_theme_item, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_has_theme_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_item")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1739311056)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the theme property of `dataType` defined by `name` and `themeType` exists.
    /// 
    /// Returns `false` if it doesn't exist. Use ``setThemeItem(dataType:name:themeType:value:)`` to define it.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func hasThemeItem(dataType: Theme.DataType, name: StringName, themeType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_has_theme_item, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rename_theme_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("rename_theme_item")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3900867553)!
            }
            
        }
        
    }()
    
    /// Renames the theme property of `dataType` defined by `oldName` and `themeType` to `name`, if it exists.
    /// 
    /// Fails if it doesn't exist, or if a similar property with the new name already exists. Use ``hasThemeItem(dataType:name:themeType:)`` to check for existence, and ``clearThemeItem(dataType:name:themeType:)`` to remove the existing property.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func renameThemeItem(dataType: Theme.DataType, oldName: StringName, name: StringName, themeType: StringName) {
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: oldName.content) { pArg1 in
                withUnsafePointer(to: name.content) { pArg2 in
                    withUnsafePointer(to: themeType.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Theme.method_rename_theme_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_theme_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_theme_item")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2965505587)!
            }
            
        }
        
    }()
    
    /// Removes the theme property of `dataType` defined by `name` and `themeType`, if it exists.
    /// 
    /// Fails if it doesn't exist. Use ``hasThemeItem(dataType:name:themeType:)`` to check for existence.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func clearThemeItem(dataType: Theme.DataType, name: StringName, themeType: StringName) {
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: themeType.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Theme.method_clear_theme_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_item_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_item_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3726716710)!
            }
            
        }
        
    }()
    
    /// Returns a list of names for properties of `dataType` defined with `themeType`. Use ``getThemeItemTypeList(dataType:)`` to get a list of possible theme type names.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func getThemeItemList(dataType: Theme.DataType, themeType: String) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            let themeType = GString(themeType)
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_get_theme_item_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_item_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_item_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1316004935)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names for `dataType` properties. Use ``getTypeList()`` to get a list of all unique theme types.
    /// 
    /// > Note: This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
    /// 
    public final func getThemeItemTypeList(dataType: Theme.DataType) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        withUnsafePointer(to: dataType.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_theme_item_type_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_type_variation")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Marks `themeType` as a variation of `baseType`.
    /// 
    /// This adds `themeType` as a suggested option for ``Control/themeTypeVariation`` on a ``Control`` that is of the `baseType` class.
    /// 
    /// Variations can also be nested, i.e. `baseType` can be another variation. If a chain of variations ends with a `baseType` matching the class of the ``Control``, the whole chain is going to be suggested as options.
    /// 
    /// > Note: Suggestions only show up if this theme resource is set as the project default theme. See ``ProjectSettings/gui/theme/custom``.
    /// 
    public final func setTypeVariation(themeType: StringName, baseType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: baseType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_set_type_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_type_variation")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `themeType` is marked as a variation of `baseType`.
    public final func isTypeVariation(themeType: StringName, baseType: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: baseType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Theme.method_is_type_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clear_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_type_variation")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Unmarks `themeType` as being a variation of another theme type. See ``setTypeVariation(themeType:baseType:)``.
    public final func clearTypeVariation(themeType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_clear_type_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_type_variation_base: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_type_variation_base")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965194235)!
            }
            
        }
        
    }()
    
    /// Returns the name of the base theme type if `themeType` is a valid variation type. Returns an empty string otherwise.
    public final func getTypeVariationBase(themeType: StringName) -> StringName {
        let _result: StringName = StringName ()
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_type_variation_base, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_type_variation_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_type_variation_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1761182771)!
            }
            
        }
        
    }()
    
    /// Returns a list of all type variations for the given `baseType`.
    public final func getTypeVariationList(baseType: StringName) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        withUnsafePointer(to: baseType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_get_type_variation_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_type")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Adds an empty theme type for every valid data type.
    /// 
    /// > Note: Empty types are not saved with the theme. This method only exists to perform in-memory changes to the resource. Use available `set_*` methods to add theme items.
    /// 
    public final func addType(themeType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_add_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_type")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes the theme type, gracefully discarding defined theme items. If the type is a variation, this information is also erased. If the type is a base for type variations, those variations lose their base.
    public final func removeType(themeType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_remove_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_type_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_type_list")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of all unique theme type names. Use the appropriate `get_*_type_list` method to get a list of unique theme types for a single data type.
    public final func getTypeList() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(Theme.method_get_type_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_merge_with: GDExtensionMethodBindPtr = {
        let methodName = StringName("merge_with")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2326690814)!
            }
            
        }
        
    }()
    
    /// Adds missing and overrides existing definitions with values from the `other` theme resource.
    /// 
    /// > Note: This modifies the current theme. If you want to merge two themes together without modifying either one, create a new empty theme and merge the other two into it one after another.
    /// 
    public final func mergeWith(other: Theme?) {
        withUnsafePointer(to: other?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Theme.method_merge_with, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &Theme.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all the theme properties defined on the theme resource.
    public final func clear() {
        gi.object_method_bind_ptrcall(Theme.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
}

