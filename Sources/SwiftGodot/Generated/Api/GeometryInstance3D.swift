// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base node for geometry-based visual instances.
/// 
/// Base node for geometry-based visual instances. Shares some common functionality like visibility and custom materials.
open class GeometryInstance3D: VisualInstance3D {
    override open class var godotClassName: StringName { "GeometryInstance3D" }
    public enum ShadowCastingSetting: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Will not cast any shadows. Use this to improve performance for small geometry that is unlikely to cast noticeable shadows (such as debris).
        case off = 0 // SHADOW_CASTING_SETTING_OFF
        /// Will cast shadows from all visible faces in the GeometryInstance3D.
        /// 
        /// Will take culling into account, so faces not being rendered will not be taken into account when shadow casting.
        /// 
        case on = 1 // SHADOW_CASTING_SETTING_ON
        /// Will cast shadows from all visible faces in the GeometryInstance3D.
        /// 
        /// Will not take culling into account, so all faces will be taken into account when shadow casting.
        /// 
        case doubleSided = 2 // SHADOW_CASTING_SETTING_DOUBLE_SIDED
        /// Will only show the shadows casted from this object.
        /// 
        /// In other words, the actual mesh will not be visible, only the shadows casted from the mesh will be.
        /// 
        case shadowsOnly = 3 // SHADOW_CASTING_SETTING_SHADOWS_ONLY
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .off: return ".off"
                case .on: return ".on"
                case .doubleSided: return ".doubleSided"
                case .shadowsOnly: return ".shadowsOnly"
            }
            
        }
        
    }
    
    public enum GIMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Disabled global illumination mode. Use for dynamic objects that do not contribute to global illumination (such as characters). When using ``VoxelGI`` and SDFGI, the geometry will _receive_ indirect lighting and reflections but the geometry will not be considered in GI baking.
        case disabled = 0 // GI_MODE_DISABLED
        /// Baked global illumination mode. Use for static objects that contribute to global illumination (such as level geometry). This GI mode is effective when using ``VoxelGI``, SDFGI and ``LightmapGI``.
        case `static` = 1 // GI_MODE_STATIC
        /// Dynamic global illumination mode. Use for dynamic objects that contribute to global illumination. This GI mode is only effective when using ``VoxelGI``, but it has a higher performance impact than ``GIMode/`static```. When using other GI methods, this will act the same as ``GIMode/disabled``. When using ``LightmapGI``, the object will receive indirect lighting using lightmap probes instead of using the baked lightmap texture.
        case dynamic = 2 // GI_MODE_DYNAMIC
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .`static`: return ".`static`"
                case .dynamic: return ".dynamic"
            }
            
        }
        
    }
    
    public enum LightmapScale: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The standard texel density for lightmapping with ``LightmapGI``.
        case lightmapScale1x = 0 // LIGHTMAP_SCALE_1X
        /// Multiplies texel density by 2× for lightmapping with ``LightmapGI``. To ensure consistency in texel density, use this when scaling a mesh by a factor between 1.5 and 3.0.
        case lightmapScale2x = 1 // LIGHTMAP_SCALE_2X
        /// Multiplies texel density by 4× for lightmapping with ``LightmapGI``. To ensure consistency in texel density, use this when scaling a mesh by a factor between 3.0 and 6.0.
        case lightmapScale4x = 2 // LIGHTMAP_SCALE_4X
        /// Multiplies texel density by 8× for lightmapping with ``LightmapGI``. To ensure consistency in texel density, use this when scaling a mesh by a factor greater than 6.0.
        case lightmapScale8x = 3 // LIGHTMAP_SCALE_8X
        /// Represents the size of the ``GeometryInstance3D/LightmapScale`` enum.
        case max = 4 // LIGHTMAP_SCALE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .lightmapScale1x: return ".lightmapScale1x"
                case .lightmapScale2x: return ".lightmapScale2x"
                case .lightmapScale4x: return ".lightmapScale4x"
                case .lightmapScale8x: return ".lightmapScale8x"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum VisibilityRangeFadeMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Will not fade itself nor its visibility dependencies, hysteresis will be used instead. This is the fastest approach to manual LOD, but it can result in noticeable LOD transitions depending on how the LOD meshes are authored. See ``visibilityRangeBegin`` and ``Node3D/visibilityParent`` for more information.
        case disabled = 0 // VISIBILITY_RANGE_FADE_DISABLED
        /// Will fade-out itself when reaching the limits of its own visibility range. This is slower than ``VisibilityRangeFadeMode/disabled``, but it can provide smoother transitions. The fading range is determined by ``visibilityRangeBeginMargin`` and ``visibilityRangeEndMargin``.
        /// 
        /// > Note: Only supported when using the Forward+ rendering method. When using the Mobile or Compatibility rendering method, this mode acts like ``VisibilityRangeFadeMode/disabled`` but with hysteresis disabled.
        /// 
        case `self` = 1 // VISIBILITY_RANGE_FADE_SELF
        /// Will fade-in its visibility dependencies (see ``Node3D/visibilityParent``) when reaching the limits of its own visibility range. This is slower than ``VisibilityRangeFadeMode/disabled``, but it can provide smoother transitions. The fading range is determined by ``visibilityRangeBeginMargin`` and ``visibilityRangeEndMargin``.
        /// 
        /// > Note: Only supported when using the Forward+ rendering method. When using the Mobile or Compatibility rendering method, this mode acts like ``VisibilityRangeFadeMode/disabled`` but with hysteresis disabled.
        /// 
        case dependencies = 2 // VISIBILITY_RANGE_FADE_DEPENDENCIES
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .`self`: return ".`self`"
                case .dependencies: return ".dependencies"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The material override for the whole geometry.
    /// 
    /// If a material is assigned to this property, it will be used instead of any material set in any material slot of the mesh.
    /// 
    final public var materialOverride: Material? {
        get {
            return get_material_override ()
        }
        
        set {
            set_material_override (newValue)
        }
        
    }
    
    /// The material overlay for the whole geometry.
    /// 
    /// If a material is assigned to this property, it will be rendered on top of any other active material for all the surfaces.
    /// 
    final public var materialOverlay: Material? {
        get {
            return get_material_overlay ()
        }
        
        set {
            set_material_overlay (newValue)
        }
        
    }
    
    /// The transparency applied to the whole geometry (as a multiplier of the materials' existing transparency). `0.0` is fully opaque, while `1.0` is fully transparent. Values greater than `0.0` (exclusive) will force the geometry's materials to go through the transparent pipeline, which is slower to render and can exhibit rendering issues due to incorrect transparency sorting. However, unlike using a transparent material, setting ``transparency`` to a value greater than `0.0` (exclusive) will _not_ disable shadow rendering.
    /// 
    /// In spatial shaders, `1.0 - transparency` is set as the default value of the `ALPHA` built-in.
    /// 
    /// > Note: ``transparency`` is clamped between `0.0` and `1.0`, so this property cannot be used to make transparent materials more opaque than they originally are.
    /// 
    /// > Note: Only supported when using the Forward+ rendering method. When using the Mobile or Compatibility rendering method, ``transparency`` is ignored and is considered as always being `0.0`.
    /// 
    final public var transparency: Double {
        get {
            return get_transparency ()
        }
        
        set {
            set_transparency (newValue)
        }
        
    }
    
    /// The selected shadow casting flag. See ``GeometryInstance3D/ShadowCastingSetting`` for possible values.
    final public var castShadow: GeometryInstance3D.ShadowCastingSetting {
        get {
            return get_cast_shadows_setting ()
        }
        
        set {
            set_cast_shadows_setting (newValue)
        }
        
    }
    
    /// The extra distance added to the GeometryInstance3D's bounding box (``AABB``) to increase its cull box.
    final public var extraCullMargin: Double {
        get {
            return get_extra_cull_margin ()
        }
        
        set {
            set_extra_cull_margin (newValue)
        }
        
    }
    
    /// Overrides the bounding box of this node with a custom one. This can be used to avoid the expensive ``AABB`` recalculation that happens when a skeleton is used with a ``MeshInstance3D`` or to have precise control over the ``MeshInstance3D``'s bounding box. To use the default AABB, set value to an ``AABB`` with all fields set to `0.0`. To avoid frustum culling, set ``customAabb`` to a very large AABB that covers your entire game world such as `AABB(-10000, -10000, -10000, 20000, 20000, 20000)`. To disable all forms of culling (including occlusion culling), call ``RenderingServer/instanceSetIgnoreCulling(instance:enabled:)`` on the ``GeometryInstance3D``'s ``RID``.
    final public var customAabb: AABB {
        get {
            return get_custom_aabb ()
        }
        
        set {
            set_custom_aabb (newValue)
        }
        
    }
    
    /// Changes how quickly the mesh transitions to a lower level of detail. A value of 0 will force the mesh to its lowest level of detail, a value of 1 will use the default settings, and larger values will keep the mesh in a higher level of detail at farther distances.
    /// 
    /// Useful for testing level of detail transitions in the editor.
    /// 
    final public var lodBias: Double {
        get {
            return get_lod_bias ()
        }
        
        set {
            set_lod_bias (newValue)
        }
        
    }
    
    /// If `true`, disables occlusion culling for this instance. Useful for gizmos that must be rendered even when occlusion culling is in use.
    /// 
    /// > Note: ``ignoreOcclusionCulling`` does not affect frustum culling (which is what happens when an object is not visible given the camera's angle). To avoid frustum culling, set ``customAabb`` to a very large AABB that covers your entire game world such as `AABB(-10000, -10000, -10000, 20000, 20000, 20000)`.
    /// 
    final public var ignoreOcclusionCulling: Bool {
        get {
            return is_ignoring_occlusion_culling ()
        }
        
        set {
            set_ignore_occlusion_culling (newValue)
        }
        
    }
    
    /// The global illumination mode to use for the whole geometry. To avoid inconsistent results, use a mode that matches the purpose of the mesh during gameplay (static/dynamic).
    /// 
    /// > Note: Lights' bake mode will also affect the global illumination rendering. See ``Light3D/lightBakeMode``.
    /// 
    final public var giMode: GeometryInstance3D.GIMode {
        get {
            return get_gi_mode ()
        }
        
        set {
            set_gi_mode (newValue)
        }
        
    }
    
    /// The texel density to use for lightmapping in ``LightmapGI``. Greater scale values provide higher resolution in the lightmap, which can result in sharper shadows for lights that have both direct and indirect light baked. However, greater scale values will also increase the space taken by the mesh in the lightmap texture, which increases the memory, storage, and bake time requirements. When using a single mesh at different scales, consider adjusting this value to keep the lightmap texel density consistent across meshes.
    final public var giLightmapScale: GeometryInstance3D.LightmapScale {
        get {
            return get_lightmap_scale ()
        }
        
        set {
            set_lightmap_scale (newValue)
        }
        
    }
    
    /// Starting distance from which the GeometryInstance3D will be visible, taking ``visibilityRangeBeginMargin`` into account as well. The default value of 0 is used to disable the range check.
    final public var visibilityRangeBegin: Double {
        get {
            return get_visibility_range_begin ()
        }
        
        set {
            set_visibility_range_begin (newValue)
        }
        
    }
    
    /// Margin for the ``visibilityRangeBegin`` threshold. The GeometryInstance3D will only change its visibility state when it goes over or under the ``visibilityRangeBegin`` threshold by this amount.
    /// 
    /// If ``visibilityRangeFadeMode`` is ``VisibilityRangeFadeMode/disabled``, this acts as a hysteresis distance. If ``visibilityRangeFadeMode`` is ``VisibilityRangeFadeMode/`self``` or ``VisibilityRangeFadeMode/dependencies``, this acts as a fade transition distance and must be set to a value greater than `0.0` for the effect to be noticeable.
    /// 
    final public var visibilityRangeBeginMargin: Double {
        get {
            return get_visibility_range_begin_margin ()
        }
        
        set {
            set_visibility_range_begin_margin (newValue)
        }
        
    }
    
    /// Distance from which the GeometryInstance3D will be hidden, taking ``visibilityRangeEndMargin`` into account as well. The default value of 0 is used to disable the range check.
    final public var visibilityRangeEnd: Double {
        get {
            return get_visibility_range_end ()
        }
        
        set {
            set_visibility_range_end (newValue)
        }
        
    }
    
    /// Margin for the ``visibilityRangeEnd`` threshold. The GeometryInstance3D will only change its visibility state when it goes over or under the ``visibilityRangeEnd`` threshold by this amount.
    /// 
    /// If ``visibilityRangeFadeMode`` is ``VisibilityRangeFadeMode/disabled``, this acts as a hysteresis distance. If ``visibilityRangeFadeMode`` is ``VisibilityRangeFadeMode/`self``` or ``VisibilityRangeFadeMode/dependencies``, this acts as a fade transition distance and must be set to a value greater than `0.0` for the effect to be noticeable.
    /// 
    final public var visibilityRangeEndMargin: Double {
        get {
            return get_visibility_range_end_margin ()
        }
        
        set {
            set_visibility_range_end_margin (newValue)
        }
        
    }
    
    /// Controls which instances will be faded when approaching the limits of the visibility range. See ``GeometryInstance3D/VisibilityRangeFadeMode`` for possible values.
    final public var visibilityRangeFadeMode: GeometryInstance3D.VisibilityRangeFadeMode {
        get {
            return get_visibility_range_fade_mode ()
        }
        
        set {
            set_visibility_range_fade_mode (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_material_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_material_override")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2757459619)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_material_override(_ material: Material?) {
        withUnsafePointer(to: material?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_material_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_material_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_material_override")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 5934680)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_material_override() -> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_material_override, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_material_overlay: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_material_overlay")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2757459619)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_material_overlay(_ material: Material?) {
        withUnsafePointer(to: material?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_material_overlay, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_material_overlay: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_material_overlay")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 5934680)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_material_overlay() -> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_material_overlay, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_cast_shadows_setting: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cast_shadows_setting")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 856677339)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_cast_shadows_setting(_ shadowCastingSetting: GeometryInstance3D.ShadowCastingSetting) {
        withUnsafePointer(to: shadowCastingSetting.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_cast_shadows_setting, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_cast_shadows_setting: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cast_shadows_setting")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3383019359)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_cast_shadows_setting() -> GeometryInstance3D.ShadowCastingSetting {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_cast_shadows_setting, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GeometryInstance3D.ShadowCastingSetting (rawValue: _result)!
    }
    
    fileprivate static var method_set_lod_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_lod_bias")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_lod_bias(_ bias: Double) {
        withUnsafePointer(to: bias) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_lod_bias, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_lod_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_lod_bias")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_lod_bias() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_lod_bias, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_transparency: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_transparency")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transparency(_ transparency: Double) {
        withUnsafePointer(to: transparency) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_transparency, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_transparency: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transparency")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_transparency() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_transparency, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_range_end_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visibility_range_end_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_range_end_margin(_ distance: Double) {
        withUnsafePointer(to: distance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_visibility_range_end_margin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visibility_range_end_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visibility_range_end_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_range_end_margin() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_visibility_range_end_margin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_range_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visibility_range_end")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_range_end(_ distance: Double) {
        withUnsafePointer(to: distance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_visibility_range_end, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visibility_range_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visibility_range_end")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_range_end() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_visibility_range_end, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_range_begin_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visibility_range_begin_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_range_begin_margin(_ distance: Double) {
        withUnsafePointer(to: distance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_visibility_range_begin_margin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visibility_range_begin_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visibility_range_begin_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_range_begin_margin() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_visibility_range_begin_margin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_range_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visibility_range_begin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_range_begin(_ distance: Double) {
        withUnsafePointer(to: distance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_visibility_range_begin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visibility_range_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visibility_range_begin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_range_begin() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_visibility_range_begin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_range_fade_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visibility_range_fade_mode")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1440117808)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_range_fade_mode(_ mode: GeometryInstance3D.VisibilityRangeFadeMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_visibility_range_fade_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visibility_range_fade_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visibility_range_fade_mode")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2067221882)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_range_fade_mode() -> GeometryInstance3D.VisibilityRangeFadeMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_visibility_range_fade_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GeometryInstance3D.VisibilityRangeFadeMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_instance_shader_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_instance_shader_parameter")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Set the value of a shader uniform for this instance only (<a href="https://docs.godotengine.org/en//tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms">per-instance uniform</a>). See also ``ShaderMaterial/setShaderParameter(param:value:)`` to assign a uniform on all instances using the same ``ShaderMaterial``.
    /// 
    /// > Note: For a shader uniform to be assignable on a per-instance basis, it _must_ be defined with `instance uniform ...` rather than `uniform ...` in the shader code.
    /// 
    /// > Note: `name` is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
    /// 
    /// > Note: Per-instance shader uniforms are currently only available in 3D, so there is no 2D equivalent of this method.
    /// 
    public final func setInstanceShaderParameter(name: StringName, value: Variant?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: value.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_instance_shader_parameter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_instance_shader_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_instance_shader_parameter")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2760726917)!
            }
            
        }
        
    }()
    
    /// Get the value of a shader parameter as set on this instance.
    public final func getInstanceShaderParameter(name: StringName) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_instance_shader_parameter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_set_extra_cull_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_extra_cull_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_extra_cull_margin(_ margin: Double) {
        withUnsafePointer(to: margin) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_extra_cull_margin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_extra_cull_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_extra_cull_margin")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_extra_cull_margin() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_extra_cull_margin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_lightmap_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_lightmap_scale")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2462696582)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_lightmap_scale(_ scale: GeometryInstance3D.LightmapScale) {
        withUnsafePointer(to: scale.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_lightmap_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_lightmap_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_lightmap_scale")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 798767852)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_lightmap_scale() -> GeometryInstance3D.LightmapScale {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_lightmap_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GeometryInstance3D.LightmapScale (rawValue: _result)!
    }
    
    fileprivate static var method_set_gi_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_gi_mode")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2548557163)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_gi_mode(_ mode: GeometryInstance3D.GIMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_gi_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_gi_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_gi_mode")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2188566509)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_gi_mode() -> GeometryInstance3D.GIMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_gi_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GeometryInstance3D.GIMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_ignore_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_ignore_occlusion_culling")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_ignore_occlusion_culling(_ ignoreCulling: Bool) {
        withUnsafePointer(to: ignoreCulling) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_ignore_occlusion_culling, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_ignoring_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_ignoring_occlusion_culling")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_ignoring_occlusion_culling() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_is_ignoring_occlusion_culling, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_custom_aabb")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 259215842)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_custom_aabb(_ aabb: AABB) {
        withUnsafePointer(to: aabb) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GeometryInstance3D.method_set_custom_aabb, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_custom_aabb")
        return withUnsafePointer(to: &GeometryInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1068685055)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_custom_aabb() -> AABB {
        var _result: AABB = AABB ()
        gi.object_method_bind_ptrcall(GeometryInstance3D.method_get_custom_aabb, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

