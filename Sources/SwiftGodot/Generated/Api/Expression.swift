// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A class that stores an expression you can execute.
/// 
/// An expression can be made of any arithmetic operation, built-in math function call, method call of a passed instance, or built-in type construction call.
/// 
/// An example expression text using the built-in math functions could be `sqrt(pow(3, 2) + pow(4, 2))`.
/// 
/// In the following example we use a ``LineEdit`` node to write our expression and show the result.
/// 
open class Expression: RefCounted {
    override open class var godotClassName: StringName { "Expression" }
    /* Methods */
    fileprivate static var method_parse: GDExtensionMethodBindPtr = {
        let methodName = StringName("parse")
        return withUnsafePointer(to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3069722906)!
            }
            
        }
        
    }()
    
    /// Parses the expression and returns an ``GodotError`` code.
    /// 
    /// You can optionally specify names of variables that may appear in the expression with `inputNames`, so that you can bind them when it gets executed.
    /// 
    public final func parse(expression: String, inputNames: PackedStringArray = PackedStringArray()) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let expression = GString(expression)
        withUnsafePointer(to: expression.content) { pArg0 in
            withUnsafePointer(to: inputNames.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Expression.method_parse, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_execute: GDExtensionMethodBindPtr = {
        let methodName = StringName("execute")
        return withUnsafePointer(to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3712471238)!
            }
            
        }
        
    }()
    
    /// Executes the expression that was previously parsed by ``parse(expression:inputNames:)`` and returns the result. Before you use the returned object, you should check if the method failed by calling ``hasExecuteFailed()``.
    /// 
    /// If you defined input variables in ``parse(expression:inputNames:)``, you can specify their values in the inputs array, in the same order.
    /// 
    public final func execute(inputs: GArray = GArray (), baseInstance: Object? = nil, showError: Bool = true, constCallsOnly: Bool = false) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: inputs.content) { pArg0 in
            withUnsafePointer(to: baseInstance?.handle) { pArg1 in
                withUnsafePointer(to: showError) { pArg2 in
                    withUnsafePointer(to: constCallsOnly) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Expression.method_execute, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_has_execute_failed: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_execute_failed")
        return withUnsafePointer(to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if ``execute(inputs:baseInstance:showError:constCallsOnly:)`` has failed.
    public final func hasExecuteFailed() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Expression.method_has_execute_failed, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_error_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_error_text")
        return withUnsafePointer(to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the error text if ``parse(expression:inputNames:)`` or ``execute(inputs:baseInstance:showError:constCallsOnly:)`` has failed.
    public final func getErrorText() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Expression.method_get_error_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
}

