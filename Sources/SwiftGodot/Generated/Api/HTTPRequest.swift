// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A node with the ability to send HTTP(S) requests.
/// 
/// A node with the ability to send HTTP requests. Uses ``HTTPClient`` internally.
/// 
/// Can be used to make HTTP requests, i.e. download or upload files or web content via HTTP.
/// 
/// > Warning: See the notes and warnings on ``HTTPClient`` for limitations, especially regarding TLS security.
/// 
/// > Note: When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
/// 
/// **Example of contacting a REST API and printing one of its returned fields:**
/// 
/// **Example of loading and displaying an image using HTTPRequest:**
/// 
/// **Gzipped response bodies**: HTTPRequest will automatically handle decompression of response bodies. A `Accept-Encoding` header will be automatically added to each of your requests, unless one is already specified. Any response with a `Content-Encoding: gzip` header will automatically be decompressed and delivered to you as uncompressed bytes.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``requestCompleted``
open class HTTPRequest: Node {
    override open class var godotClassName: StringName { "HTTPRequest" }
    public enum Result: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Request successful.
        case success = 0 // RESULT_SUCCESS
        /// 
        case chunkedBodySizeMismatch = 1 // RESULT_CHUNKED_BODY_SIZE_MISMATCH
        /// Request failed while connecting.
        case cantConnect = 2 // RESULT_CANT_CONNECT
        /// Request failed while resolving.
        case cantResolve = 3 // RESULT_CANT_RESOLVE
        /// Request failed due to connection (read/write) error.
        case connectionError = 4 // RESULT_CONNECTION_ERROR
        /// Request failed on TLS handshake.
        case tlsHandshakeError = 5 // RESULT_TLS_HANDSHAKE_ERROR
        /// Request does not have a response (yet).
        case noResponse = 6 // RESULT_NO_RESPONSE
        /// Request exceeded its maximum size limit, see ``bodySizeLimit``.
        case bodySizeLimitExceeded = 7 // RESULT_BODY_SIZE_LIMIT_EXCEEDED
        /// 
        case bodyDecompressFailed = 8 // RESULT_BODY_DECOMPRESS_FAILED
        /// Request failed (currently unused).
        case requestFailed = 9 // RESULT_REQUEST_FAILED
        /// HTTPRequest couldn't open the download file.
        case downloadFileCantOpen = 10 // RESULT_DOWNLOAD_FILE_CANT_OPEN
        /// HTTPRequest couldn't write to the download file.
        case downloadFileWriteError = 11 // RESULT_DOWNLOAD_FILE_WRITE_ERROR
        /// Request reached its maximum redirect limit, see ``maxRedirects``.
        case redirectLimitReached = 12 // RESULT_REDIRECT_LIMIT_REACHED
        /// Request failed due to a timeout. If you expect requests to take a long time, try increasing the value of ``timeout`` or setting it to `0.0` to remove the timeout completely.
        case timeout = 13 // RESULT_TIMEOUT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .success: return ".success"
                case .chunkedBodySizeMismatch: return ".chunkedBodySizeMismatch"
                case .cantConnect: return ".cantConnect"
                case .cantResolve: return ".cantResolve"
                case .connectionError: return ".connectionError"
                case .tlsHandshakeError: return ".tlsHandshakeError"
                case .noResponse: return ".noResponse"
                case .bodySizeLimitExceeded: return ".bodySizeLimitExceeded"
                case .bodyDecompressFailed: return ".bodyDecompressFailed"
                case .requestFailed: return ".requestFailed"
                case .downloadFileCantOpen: return ".downloadFileCantOpen"
                case .downloadFileWriteError: return ".downloadFileWriteError"
                case .redirectLimitReached: return ".redirectLimitReached"
                case .timeout: return ".timeout"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The file to download into. Will output any received file into it.
    final public var downloadFile: String {
        get {
            return get_download_file ()
        }
        
        set {
            set_download_file (newValue)
        }
        
    }
    
    /// The size of the buffer used and maximum bytes to read per iteration. See ``HTTPClient/readChunkSize``.
    /// 
    /// Set this to a lower value (e.g. 4096 for 4 KiB) when downloading small files to decrease memory usage at the cost of download speeds.
    /// 
    final public var downloadChunkSize: Int32 {
        get {
            return get_download_chunk_size ()
        }
        
        set {
            set_download_chunk_size (newValue)
        }
        
    }
    
    /// If `true`, multithreading is used to improve performance.
    final public var useThreads: Bool {
        get {
            return is_using_threads ()
        }
        
        set {
            set_use_threads (newValue)
        }
        
    }
    
    /// If `true`, this header will be added to each request: `Accept-Encoding: gzip, deflate` telling servers that it's okay to compress response bodies.
    /// 
    /// Any Response body declaring a `Content-Encoding` of either `gzip` or `deflate` will then be automatically decompressed, and the uncompressed bytes will be delivered via [signal request_completed].
    /// 
    /// If the user has specified their own `Accept-Encoding` header, then no header will be added regardless of ``acceptGzip``.
    /// 
    /// If `false` no header will be added, and no decompression will be performed on response bodies. The raw bytes of the response body will be returned via [signal request_completed].
    /// 
    final public var acceptGzip: Bool {
        get {
            return is_accepting_gzip ()
        }
        
        set {
            set_accept_gzip (newValue)
        }
        
    }
    
    /// Maximum allowed size for response bodies. If the response body is compressed, this will be used as the maximum allowed size for the decompressed body.
    final public var bodySizeLimit: Int32 {
        get {
            return get_body_size_limit ()
        }
        
        set {
            set_body_size_limit (newValue)
        }
        
    }
    
    /// Maximum number of allowed redirects.
    final public var maxRedirects: Int32 {
        get {
            return get_max_redirects ()
        }
        
        set {
            set_max_redirects (newValue)
        }
        
    }
    
    /// The duration to wait in seconds before a request times out. If ``timeout`` is set to `0.0` then the request will never time out. For simple requests, such as communication with a REST API, it is recommended that ``timeout`` is set to a value suitable for the server response time (e.g. between `1.0` and `10.0`). This will help prevent unwanted timeouts caused by variation in server response times while still allowing the application to detect when a request has timed out. For larger requests such as file downloads it is suggested the ``timeout`` be set to `0.0`, disabling the timeout functionality. This will help to prevent large transfers from failing due to exceeding the timeout value.
    final public var timeout: Double {
        get {
            return get_timeout ()
        }
        
        set {
            set_timeout (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_request: GDExtensionMethodBindPtr = {
        let methodName = StringName("request")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3215244323)!
            }
            
        }
        
    }()
    
    /// Creates request on the underlying ``HTTPClient``. If there is no configuration errors, it tries to connect using ``HTTPClient/connectToHost(_:port:tlsOptions:)`` and passes parameters onto ``HTTPClient/request(method:url:headers:body:)``.
    /// 
    /// Returns ``GodotError/ok`` if request is successfully created. (Does not imply that the server has responded), ``GodotError/errUnconfigured`` if not in the tree, ``GodotError/errBusy`` if still processing previous request, ``GodotError/errInvalidParameter`` if given string is not a valid URL format, or ``GodotError/errCantConnect`` if not using thread and the ``HTTPClient`` cannot connect to host.
    /// 
    /// > Note: When `method` is ``HTTPClient/Method/get``, the payload sent via `requestData` might be ignored by the server or even cause the server to reject the request (check <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">RFC 7231 section 4.3.1</a> for more details). As a workaround, you can send data as a query string in the URL (see ``GString/uriEncode()`` for an example).
    /// 
    /// > Note: It's recommended to use transport encryption (TLS) and to avoid sending sensitive information (such as login credentials) in HTTP GET URL parameters. Consider using HTTP POST requests or HTTP headers for such information instead.
    /// 
    public final func request(url: String, customHeaders: PackedStringArray = PackedStringArray(), method: HTTPClient.Method = .get, requestData: String = "") -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let url = GString(url)
        withUnsafePointer(to: url.content) { pArg0 in
            withUnsafePointer(to: customHeaders.content) { pArg1 in
                withUnsafePointer(to: method.rawValue) { pArg2 in
                    let requestData = GString(requestData)
                    withUnsafePointer(to: requestData.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(HTTPRequest.method_request, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_request_raw: GDExtensionMethodBindPtr = {
        let methodName = StringName("request_raw")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2714829993)!
            }
            
        }
        
    }()
    
    /// Creates request on the underlying ``HTTPClient`` using a raw array of bytes for the request body. If there is no configuration errors, it tries to connect using ``HTTPClient/connectToHost(_:port:tlsOptions:)`` and passes parameters onto ``HTTPClient/request(method:url:headers:body:)``.
    /// 
    /// Returns ``GodotError/ok`` if request is successfully created. (Does not imply that the server has responded), ``GodotError/errUnconfigured`` if not in the tree, ``GodotError/errBusy`` if still processing previous request, ``GodotError/errInvalidParameter`` if given string is not a valid URL format, or ``GodotError/errCantConnect`` if not using thread and the ``HTTPClient`` cannot connect to host.
    /// 
    public final func requestRaw(url: String, customHeaders: PackedStringArray = PackedStringArray(), method: HTTPClient.Method = .get, requestDataRaw: PackedByteArray = PackedByteArray()) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let url = GString(url)
        withUnsafePointer(to: url.content) { pArg0 in
            withUnsafePointer(to: customHeaders.content) { pArg1 in
                withUnsafePointer(to: method.rawValue) { pArg2 in
                    withUnsafePointer(to: requestDataRaw.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(HTTPRequest.method_request_raw, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_cancel_request: GDExtensionMethodBindPtr = {
        let methodName = StringName("cancel_request")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Cancels the current request.
    public final func cancelRequest() {
        gi.object_method_bind_ptrcall(HTTPRequest.method_cancel_request, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_tls_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tls_options")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2210231844)!
            }
            
        }
        
    }()
    
    /// Sets the ``TLSOptions`` to be used when connecting to an HTTPS server. See ``TLSOptions/client(trustedChain:commonNameOverride:)``.
    public final func setTlsOptions(clientOptions: TLSOptions?) {
        withUnsafePointer(to: clientOptions?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_tls_options, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_http_client_status: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_http_client_status")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1426656811)!
            }
            
        }
        
    }()
    
    /// Returns the current status of the underlying ``HTTPClient``. See ``HTTPClient.Status``.
    public final func getHttpClientStatus() -> HTTPClient.Status {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_http_client_status, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return HTTPClient.Status (rawValue: _result)!
    }
    
    fileprivate static var method_set_use_threads: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_threads")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_threads(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_use_threads, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_threads: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_threads")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_threads() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(HTTPRequest.method_is_using_threads, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_accept_gzip: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_accept_gzip")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_accept_gzip(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_accept_gzip, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_accepting_gzip: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_accepting_gzip")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_accepting_gzip() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(HTTPRequest.method_is_accepting_gzip, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_body_size_limit: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_body_size_limit")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_body_size_limit(_ bytes: Int32) {
        withUnsafePointer(to: bytes) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_body_size_limit, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_body_size_limit: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_body_size_limit")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_body_size_limit() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_body_size_limit, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_redirects: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_max_redirects")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_redirects(_ amount: Int32) {
        withUnsafePointer(to: amount) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_max_redirects, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_max_redirects: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_max_redirects")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_redirects() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_max_redirects, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_download_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_download_file")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_download_file(_ path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_download_file, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_download_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_download_file")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_download_file() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_download_file, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_downloaded_bytes: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_downloaded_bytes")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of bytes this HTTPRequest downloaded.
    public final func getDownloadedBytes() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_downloaded_bytes, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_body_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_body_size")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the response body length.
    /// 
    /// > Note: Some Web servers may not send a body length. In this case, the value returned will be `-1`. If using chunked transfer encoding, the body length will also be `-1`.
    /// 
    public final func getBodySize() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_body_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_timeout: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_timeout")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_timeout(_ timeout: Double) {
        withUnsafePointer(to: timeout) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_timeout, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_timeout: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_timeout")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 191475506)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_timeout() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_timeout, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_download_chunk_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_download_chunk_size")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_download_chunk_size(_ chunkSize: Int32) {
        withUnsafePointer(to: chunkSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(HTTPRequest.method_set_download_chunk_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_download_chunk_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_download_chunk_size")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_download_chunk_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(HTTPRequest.method_get_download_chunk_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_http_proxy: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_http_proxy")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2956805083)!
            }
            
        }
        
    }()
    
    /// Sets the proxy server for HTTP requests.
    /// 
    /// The proxy server is unset if `host` is empty or `port` is -1.
    /// 
    public final func setHttpProxy(host: String, port: Int32) {
        let host = GString(host)
        withUnsafePointer(to: host.content) { pArg0 in
            withUnsafePointer(to: port) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(HTTPRequest.method_set_http_proxy, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_https_proxy: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_https_proxy")
        return withUnsafePointer(to: &HTTPRequest.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2956805083)!
            }
            
        }
        
    }()
    
    /// Sets the proxy server for HTTPS requests.
    /// 
    /// The proxy server is unset if `host` is empty or `port` is -1.
    /// 
    public final func setHttpsProxy(host: String, port: Int32) {
        let host = GString(host)
        withUnsafePointer(to: host.content) { pArg0 in
            withUnsafePointer(to: port) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(HTTPRequest.method_set_https_proxy, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ result: Int64, _ responseCode: Int64, _ headers: PackedStringArray, _ body: PackedByteArray) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                let arg_2 = PackedStringArray (args [2]!)!
                let arg_3 = PackedByteArray (args [3]!)!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a request is completed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.requestCompleted.connect { result, responseCode, headers, body in
    ///    print ("caught signal")
    /// }
    /// ```
    public var requestCompleted: Signal1 { Signal1 (target: self, signalName: "request_completed") }
    
}

