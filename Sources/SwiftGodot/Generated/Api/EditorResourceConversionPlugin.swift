// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Plugin for adding custom converters from one resource format to another in the editor resource picker context menu; for example, converting a ``StandardMaterial3D`` to a ``ShaderMaterial``.
/// 
/// ``EditorResourceConversionPlugin`` is invoked when the context menu is brought up for a resource in the editor inspector. Relevant conversion plugins will appear as menu options to convert the given resource to a target type.
/// 
/// Below shows an example of a basic plugin that will convert an ``ImageTexture`` to a ``PortableCompressedTexture2D``.
/// 
/// To use an ``EditorResourceConversionPlugin``, register it using the ``EditorPlugin/addResourceConversionPlugin(_:)`` method first.
/// 
open class EditorResourceConversionPlugin: RefCounted {
    override open class var godotClassName: StringName { "EditorResourceConversionPlugin" }
    /* Methods */
    /// Returns the class name of the target type of ``Resource`` that this plugin converts source resources to.
    @_documentation(visibility: public)
    open func _convertsTo() -> String {
        return String ()
    }
    
    /// Called to determine whether a particular ``Resource`` can be converted to the target resource type by this plugin.
    @_documentation(visibility: public)
    open func _handles(resource: Resource?) -> Bool {
        return false
    }
    
    /// Takes an input ``Resource`` and converts it to the type given in ``_convertsTo()``. The returned ``Resource`` is the result of the conversion, and the input ``Resource`` remains unchanged.
    @_documentation(visibility: public)
    open func _convert(resource: Resource?) -> Resource? {
        return Resource ()
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_convert":
                return _EditorResourceConversionPlugin_proxy_convert
            case "_converts_to":
                return _EditorResourceConversionPlugin_proxy_converts_to
            case "_handles":
                return _EditorResourceConversionPlugin_proxy_handles
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _EditorResourceConversionPlugin_proxy_convert (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorResourceConversionPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._convert (resource: lookupLiveObject (handleAddress: resolved_0) as? Resource ?? Resource (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Resource
}

func _EditorResourceConversionPlugin_proxy_converts_to (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorResourceConversionPlugin>.fromOpaque(instance).takeUnretainedValue()
    let ret = GString (swiftObject._convertsTo ())
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorResourceConversionPlugin_proxy_handles (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorResourceConversionPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._handles (resource: lookupLiveObject (handleAddress: resolved_0) as? Resource ?? Resource (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

