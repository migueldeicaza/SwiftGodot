// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class used for extending the ``MultiplayerAPI``.
/// 
/// This class can be used to augment or replace the default ``MultiplayerAPI`` implementation via script or extensions.
/// 
/// The following example augment the default implementation (``SceneMultiplayer``) by logging every RPC being made, and every object being configured for replication.
/// 
/// Then in your main scene or in an autoload call ``SceneTree/setMultiplayer(_:rootPath:)`` to start using your custom ``MultiplayerAPI``:
/// 
/// Native extensions can alternatively use the ``MultiplayerAPI/setDefaultInterface(interfaceName:)`` method during initialization to configure themselves as the default implementation.
/// 
open class MultiplayerAPIExtension: MultiplayerAPI {
    override open class var godotClassName: StringName { "MultiplayerAPIExtension" }
    /* Methods */
    /// Callback for ``MultiplayerAPI/poll()``.
    @_documentation(visibility: public)
    open func _poll() -> GodotError {
        return .ok
    }
    
    /// Called when the ``MultiplayerAPI/multiplayerPeer`` is set.
    @_documentation(visibility: public)
    open func _setMultiplayerPeer(_ multiplayerPeer: MultiplayerPeer?) {
    }
    
    /// Called when the ``MultiplayerAPI/multiplayerPeer`` is retrieved.
    @_documentation(visibility: public)
    open func _getMultiplayerPeer() -> MultiplayerPeer? {
        return MultiplayerPeer ()
    }
    
    /// Callback for ``MultiplayerAPI/getUniqueId()``.
    @_documentation(visibility: public)
    open func _getUniqueId() -> Int32 {
        return 0
    }
    
    /// Callback for ``MultiplayerAPI/getPeers()``.
    @_documentation(visibility: public)
    open func _getPeerIds() -> PackedInt32Array {
        return PackedInt32Array ()
    }
    
    /// Callback for ``MultiplayerAPI/rpc(peer:object:method:arguments:)``.
    @_documentation(visibility: public)
    open func _rpc(peer: Int32, object: Object?, method: StringName, args: GArray) -> GodotError {
        return .ok
    }
    
    /// Callback for ``MultiplayerAPI/getRemoteSenderId()``.
    @_documentation(visibility: public)
    open func _getRemoteSenderId() -> Int32 {
        return 0
    }
    
    /// Callback for ``MultiplayerAPI/objectConfigurationAdd(object:configuration:)``.
    @_documentation(visibility: public)
    open func _objectConfigurationAdd(object: Object?, configuration: Variant?) -> GodotError {
        return .ok
    }
    
    /// Callback for ``MultiplayerAPI/objectConfigurationRemove(object:configuration:)``.
    @_documentation(visibility: public)
    open func _objectConfigurationRemove(object: Object?, configuration: Variant?) -> GodotError {
        return .ok
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_multiplayer_peer":
                return _MultiplayerAPIExtension_proxy_get_multiplayer_peer
            case "_get_peer_ids":
                return _MultiplayerAPIExtension_proxy_get_peer_ids
            case "_get_remote_sender_id":
                return _MultiplayerAPIExtension_proxy_get_remote_sender_id
            case "_get_unique_id":
                return _MultiplayerAPIExtension_proxy_get_unique_id
            case "_object_configuration_add":
                return _MultiplayerAPIExtension_proxy_object_configuration_add
            case "_object_configuration_remove":
                return _MultiplayerAPIExtension_proxy_object_configuration_remove
            case "_poll":
                return _MultiplayerAPIExtension_proxy_poll
            case "_rpc":
                return _MultiplayerAPIExtension_proxy_rpc
            case "_set_multiplayer_peer":
                return _MultiplayerAPIExtension_proxy_set_multiplayer_peer
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _MultiplayerAPIExtension_proxy_get_multiplayer_peer (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getMultiplayerPeer ()
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // MultiplayerPeer
}

func _MultiplayerAPIExtension_proxy_get_peer_ids (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getPeerIds ()
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedInt32Array
    ret.content = PackedInt32Array.zero
}

func _MultiplayerAPIExtension_proxy_get_remote_sender_id (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getRemoteSenderId ()
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_get_unique_id (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getUniqueId ()
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_object_configuration_add (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._objectConfigurationAdd (object: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), configuration: args [1]!.assumingMemoryBound (to: Variant.self).pointee)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_object_configuration_remove (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._objectConfigurationRemove (object: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), configuration: args [1]!.assumingMemoryBound (to: Variant.self).pointee)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_poll (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._poll ()
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_rpc (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._rpc (peer: args [0]!.assumingMemoryBound (to: Int32.self).pointee, object: lookupLiveObject (handleAddress: resolved_1) as? Object ?? Object (nativeHandle: resolved_1), method: StringName (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), args: GArray (content: args [3]!.assumingMemoryBound (to: Int64.self).pointee))
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _MultiplayerAPIExtension_proxy_set_multiplayer_peer (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<MultiplayerAPIExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._setMultiplayerPeer (lookupLiveObject (handleAddress: resolved_0) as? MultiplayerPeer ?? MultiplayerPeer (nativeHandle: resolved_0))
}

