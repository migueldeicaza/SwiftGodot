// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control used to show a set of internal ``TreeItem``s in a hierarchical structure.
/// 
/// A control used to show a set of internal ``TreeItem``s in a hierarchical structure. The tree items can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like ``LineEdit``s, buttons and popups. It can be useful for structured displays and interactions.
/// 
/// Trees are built via code, using ``TreeItem`` objects to create the structure. They have a single root, but multiple roots can be simulated with ``hideRoot``:
/// 
/// To iterate over all the ``TreeItem`` objects in a ``Tree`` object, use ``TreeItem/getNext()`` and ``TreeItem/getFirstChild()`` after getting the root through ``getRoot()``. You can use ``Object/free()`` on a ``TreeItem`` to remove it from the ``Tree``.
/// 
/// **Incremental search:** Like ``ItemList`` and ``PopupMenu``, ``Tree`` supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing ``ProjectSettings/gui/timers/incrementalSearchMaxIntervalMsec``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``itemSelected``
/// - ``cellSelected``
/// - ``multiSelected``
/// - ``itemMouseSelected``
/// - ``emptyClicked``
/// - ``itemEdited``
/// - ``customItemClicked``
/// - ``itemIconDoubleClicked``
/// - ``itemCollapsed``
/// - ``checkPropagatedToItem``
/// - ``buttonClicked``
/// - ``customPopupEdited``
/// - ``itemActivated``
/// - ``columnTitleClicked``
/// - ``nothingSelected``
open class Tree: Control {
    override open class var godotClassName: StringName { "Tree" }
    public enum SelectMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Allows selection of a single cell at a time. From the perspective of items, only a single item is allowed to be selected. And there is only one column selected in the selected item.
        /// 
        /// The focus cursor is always hidden in this mode, but it is positioned at the current selection, making the currently selected item the currently focused item.
        /// 
        case single = 0 // SELECT_SINGLE
        /// Allows selection of a single row at a time. From the perspective of items, only a single items is allowed to be selected. And all the columns are selected in the selected item.
        /// 
        /// The focus cursor is always hidden in this mode, but it is positioned at the first column of the current selection, making the currently selected item the currently focused item.
        /// 
        case row = 1 // SELECT_ROW
        /// Allows selection of multiple cells at the same time. From the perspective of items, multiple items are allowed to be selected. And there can be multiple columns selected in each selected item.
        /// 
        /// The focus cursor is visible in this mode, the item or column under the cursor is not necessarily selected.
        /// 
        case multi = 2 // SELECT_MULTI
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .single: return ".single"
                case .row: return ".row"
                case .multi: return ".multi"
            }
            
        }
        
    }
    
    public enum DropModeFlags: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Disables all drop sections, but still allows to detect the "on item" drop section by ``getDropSectionAtPosition(_:)``.
        /// 
        /// > Note: This is the default flag, it has no effect when combined with other flags.
        /// 
        case disabled = 0 // DROP_MODE_DISABLED
        /// Enables the "on item" drop section. This drop section covers the entire item.
        /// 
        /// When combined with ``DropModeFlags/inbetween``, this drop section halves the height and stays centered vertically.
        /// 
        case onItem = 1 // DROP_MODE_ON_ITEM
        /// Enables "above item" and "below item" drop sections. The "above item" drop section covers the top half of the item, and the "below item" drop section covers the bottom half.
        /// 
        /// When combined with ``DropModeFlags/onItem``, these drop sections halves the height and stays on top / bottom accordingly.
        /// 
        case inbetween = 2 // DROP_MODE_INBETWEEN
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .onItem: return ".onItem"
                case .inbetween: return ".inbetween"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The number of columns.
    final public var columns: Int32 {
        get {
            return get_columns ()
        }
        
        set {
            set_columns (newValue)
        }
        
    }
    
    /// If `true`, column titles are visible.
    final public var columnTitlesVisible: Bool {
        get {
            return are_column_titles_visible ()
        }
        
        set {
            set_column_titles_visible (newValue)
        }
        
    }
    
    /// If `true`, the currently selected cell may be selected again.
    final public var allowReselect: Bool {
        get {
            return get_allow_reselect ()
        }
        
        set {
            set_allow_reselect (newValue)
        }
        
    }
    
    /// If `true`, a right mouse button click can select items.
    final public var allowRmbSelect: Bool {
        get {
            return get_allow_rmb_select ()
        }
        
        set {
            set_allow_rmb_select (newValue)
        }
        
    }
    
    /// If `true`, allows navigating the ``Tree`` with letter keys through incremental search.
    final public var allowSearch: Bool {
        get {
            return get_allow_search ()
        }
        
        set {
            set_allow_search (newValue)
        }
        
    }
    
    /// If `true`, the folding arrow is hidden.
    final public var hideFolding: Bool {
        get {
            return is_folding_hidden ()
        }
        
        set {
            set_hide_folding (newValue)
        }
        
    }
    
    /// If `true`, recursive folding is enabled for this ``Tree``. Holding down [kbd]Shift[/kbd] while clicking the fold arrow or using `ui_right`/`ui_left` shortcuts collapses or uncollapses the ``TreeItem`` and all its descendants.
    final public var enableRecursiveFolding: Bool {
        get {
            return is_recursive_folding_enabled ()
        }
        
        set {
            set_enable_recursive_folding (newValue)
        }
        
    }
    
    /// If `true`, the tree's root is hidden.
    final public var hideRoot: Bool {
        get {
            return is_root_hidden ()
        }
        
        set {
            set_hide_root (newValue)
        }
        
    }
    
    /// The drop mode as an OR combination of flags. See ``Tree/DropModeFlags`` constants. Once dropping is done, reverts to ``DropModeFlags/disabled``. Setting this during ``Control/_canDropData(atPosition:data:)`` is recommended.
    /// 
    /// This controls the drop sections, i.e. the decision and drawing of possible drop locations based on the mouse position.
    /// 
    final public var dropModeFlags: Int32 {
        get {
            return get_drop_mode_flags ()
        }
        
        set {
            set_drop_mode_flags (newValue)
        }
        
    }
    
    /// Allows single or multiple selection. See the ``Tree/SelectMode`` constants.
    final public var selectMode: Tree.SelectMode {
        get {
            return get_select_mode ()
        }
        
        set {
            set_select_mode (newValue)
        }
        
    }
    
    /// If `true`, enables horizontal scrolling.
    final public var scrollHorizontalEnabled: Bool {
        get {
            return is_h_scroll_enabled ()
        }
        
        set {
            set_h_scroll_enabled (newValue)
        }
        
    }
    
    /// If `true`, enables vertical scrolling.
    final public var scrollVerticalEnabled: Bool {
        get {
            return is_v_scroll_enabled ()
        }
        
        set {
            set_v_scroll_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the tree. This removes all items.
    public final func clear() {
        gi.object_method_bind_ptrcall(Tree.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_create_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_item")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 528467046)!
            }
            
        }
        
    }()
    
    /// Creates an item in the tree and adds it as a child of `parent`, which can be either a valid ``TreeItem`` or `null`.
    /// 
    /// If `parent` is `null`, the root item will be the parent, or the new item will be the root itself if the tree is empty.
    /// 
    /// The new item will be the `index`-th child of parent, or it will be the last child if there are not enough siblings.
    /// 
    public final func createItem(parent: TreeItem? = nil, index: Int32 = -1) -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: parent?.handle) { pArg0 in
            withUnsafePointer(to: index) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_create_item, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_root: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_root")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the tree's root item, or `null` if the tree is empty.
    public final func getRoot() -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Tree.method_get_root, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_column_custom_minimum_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_custom_minimum_width")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Overrides the calculated minimum width of a column. It can be set to `0` to restore the default behavior. Columns that have the "Expand" flag will use their "min_width" in a similar fashion to ``Control/sizeFlagsStretchRatio``.
    public final func setColumnCustomMinimumWidth(column: Int32, minWidth: Int32) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: minWidth) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_custom_minimum_width, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_column_expand: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_expand")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `true`, the column will have the "Expand" flag of ``Control``. Columns that have the "Expand" flag will use their expand ratio in a similar fashion to ``Control/sizeFlagsStretchRatio`` (see ``setColumnExpandRatio(column:ratio:)``).
    public final func setColumnExpand(column: Int32, expand: Bool) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: expand) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_expand, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_column_expand_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_expand_ratio")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the relative expand ratio for a column. See ``setColumnExpand(column:expand:)``.
    public final func setColumnExpandRatio(column: Int32, ratio: Int32) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: ratio) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_expand_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_column_clip_content: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_clip_content")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Allows to enable clipping for column's content, making the content size ignored.
    public final func setColumnClipContent(column: Int32, enable: Bool) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_clip_content, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_column_expanding: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_column_expanding")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the column has enabled expanding (see ``setColumnExpand(column:expand:)``).
    public final func isColumnExpanding(column: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_is_column_expanding, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_column_clipping_content: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_column_clipping_content")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the column has enabled clipping (see ``setColumnClipContent(column:enable:)``).
    public final func isColumnClippingContent(column: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_is_column_clipping_content, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_column_expand_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_expand_ratio")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the expand ratio assigned to the column.
    public final func getColumnExpandRatio(column: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_expand_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_column_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_width")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the column's width in pixels.
    public final func getColumnWidth(column: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_width, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_hide_root: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hide_root")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_root(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_hide_root, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_root_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_root_hidden")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_root_hidden() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_is_root_hidden, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_next_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_next_selected")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 873446299)!
            }
            
        }
        
    }()
    
    /// Returns the next selected ``TreeItem`` after the given one, or `null` if the end is reached.
    /// 
    /// If `from` is `null`, this returns the first selected item.
    /// 
    public final func getNextSelected(from: TreeItem?) -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: from?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_next_selected, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selected")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the currently focused item, or `null` if no item is focused.
    /// 
    /// In ``SelectMode/row`` and ``SelectMode/single`` modes, the focused item is same as the selected item. In ``SelectMode/multi`` mode, the focused item is the item under the focus cursor, not necessarily selected.
    /// 
    /// To get the currently selected item(s), use ``getNextSelected(from:)``.
    /// 
    public final func getSelected() -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Tree.method_get_selected, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_selected")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2662547442)!
            }
            
        }
        
    }()
    
    /// Selects the specified ``TreeItem`` and column.
    public final func setSelected(item: TreeItem?, column: Int32) {
        withUnsafePointer(to: item?.handle) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_selected, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_selected_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selected_column")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the currently focused column, or -1 if no column is focused.
    /// 
    /// In ``SelectMode/single`` mode, the focused column is the selected column. In ``SelectMode/row`` mode, the focused column is always 0 if any item is selected. In ``SelectMode/multi`` mode, the focused column is the column under the focus cursor, and there are not necessarily any column selected.
    /// 
    /// To tell whether a column of an item is selected, use ``TreeItem/isSelected(column:)``.
    /// 
    public final func getSelectedColumn() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tree.method_get_selected_column, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_pressed_button: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pressed_button")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last pressed button's index.
    public final func getPressedButton() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tree.method_get_pressed_button, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_select_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_select_mode")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3223887270)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_select_mode(_ mode: Tree.SelectMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_select_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_select_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_select_mode")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 100748571)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_select_mode() -> Tree.SelectMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Tree.method_get_select_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Tree.SelectMode (rawValue: _result)!
    }
    
    fileprivate static var method_deselect_all: GDExtensionMethodBindPtr = {
        let methodName = StringName("deselect_all")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Deselects all tree items (rows and columns). In ``SelectMode/multi`` mode also removes selection cursor.
    public final func deselectAll() {
        gi.object_method_bind_ptrcall(Tree.method_deselect_all, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_columns")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_columns(_ amount: Int32) {
        withUnsafePointer(to: amount) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_columns, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_columns")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_columns() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tree.method_get_columns, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_edited: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_edited")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the currently edited item. Can be used with [signal item_edited] to get the item that was modified.
    /// 
    public final func getEdited() -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Tree.method_get_edited, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_edited_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_edited_column")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the column for the currently edited item.
    public final func getEditedColumn() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tree.method_get_edited_column, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_edit_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName("edit_selected")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2595650253)!
            }
            
        }
        
    }()
    
    /// Edits the selected tree item as if it was clicked.
    /// 
    /// Either the item must be set editable with ``TreeItem/setEditable(column:enabled:)`` or `forceEdit` must be `true`.
    /// 
    /// Returns `true` if the item could be edited. Fails if no item is selected.
    /// 
    public final func editSelected(forceEdit: Bool = false) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: forceEdit) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_edit_selected, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_custom_popup_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_custom_popup_rect")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the rectangle for custom popups. Helper to create custom cell controls that display a popup. See ``TreeItem/setCellMode(column:mode:)``.
    public final func getCustomPopupRect() -> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall(Tree.method_get_custom_popup_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_item_area_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_area_rect")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 47968679)!
            }
            
        }
        
    }()
    
    /// Returns the rectangle area for the specified ``TreeItem``. If `column` is specified, only get the position and size of that column, otherwise get the rectangle containing all columns. If a button index is specified, the rectangle of that button will be returned.
    public final func getItemAreaRect(item: TreeItem?, column: Int32 = -1, buttonIndex: Int32 = -1) -> Rect2 {
        var _result: Rect2 = Rect2 ()
        withUnsafePointer(to: item?.handle) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: buttonIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Tree.method_get_item_area_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_at_position")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4193340126)!
            }
            
        }
        
    }()
    
    /// Returns the tree item at the specified position (relative to the tree origin position).
    public final func getItemAtPosition(_ position: Vector2) -> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_item_at_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_column_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_at_position")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the column index at `position`, or -1 if no item is there.
    public final func getColumnAtPosition(_ position: Vector2) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_at_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_drop_section_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_drop_section_at_position")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the drop section at `position`, or -100 if no item is there.
    /// 
    /// Values -1, 0, or 1 will be returned for the "above item", "on item", and "below item" drop sections, respectively. See ``Tree/DropModeFlags`` for a description of each drop section.
    /// 
    /// To get the item which the returned drop section is relative to, use ``getItemAtPosition(_:)``.
    /// 
    public final func getDropSectionAtPosition(_ position: Vector2) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_drop_section_at_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_button_id_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_button_id_at_position")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the button ID at `position`, or -1 if no button is there.
    public final func getButtonIdAtPosition(_ position: Vector2) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_button_id_at_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_ensure_cursor_is_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("ensure_cursor_is_visible")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Makes the currently focused cell visible.
    /// 
    /// This will scroll the tree if necessary. In ``SelectMode/row`` mode, this will not do horizontal scrolling, as all the cells in the selected row is focused logically.
    /// 
    /// > Note: Despite the name of this method, the focus cursor itself is only visible in ``SelectMode/multi`` mode.
    /// 
    public final func ensureCursorIsVisible() {
        gi.object_method_bind_ptrcall(Tree.method_ensure_cursor_is_visible, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_column_titles_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_titles_visible")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_column_titles_visible(_ visible: Bool) {
        withUnsafePointer(to: visible) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_column_titles_visible, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_are_column_titles_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("are_column_titles_visible")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_column_titles_visible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_are_column_titles_visible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_column_title: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_title")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the title of a column.
    public final func setColumnTitle(column: Int32, title: String) {
        withUnsafePointer(to: column) { pArg0 in
            let title = GString(title)
            withUnsafePointer(to: title.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_title, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_column_title: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_title")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the column's title.
    public final func getColumnTitle(column: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_title, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_column_title_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_title_alignment")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3276431499)!
            }
            
        }
        
    }()
    
    /// Sets the column title alignment. Note that ``@GlobalScope.HORIZONTAL_ALIGNMENT_FILL`` is not supported for column titles.
    public final func setColumnTitleAlignment(column: Int32, titleAlignment: HorizontalAlignment) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: titleAlignment.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_title_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_column_title_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_title_alignment")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4171562184)!
            }
            
        }
        
    }()
    
    /// Returns the column title alignment.
    public final func getColumnTitleAlignment(column: Int32) -> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_title_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return HorizontalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_set_column_title_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_title_direction")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1707680378)!
            }
            
        }
        
    }()
    
    /// Sets column title base writing direction.
    public final func setColumnTitleDirection(column: Int32, direction: Control.TextDirection) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: direction.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_title_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_column_title_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_title_direction")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4235602388)!
            }
            
        }
        
    }()
    
    /// Returns column title base writing direction.
    public final func getColumnTitleDirection(column: Int32) -> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_title_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_column_title_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_column_title_language")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets language code of column title used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    public final func setColumnTitleLanguage(column: Int32, language: String) {
        withUnsafePointer(to: column) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_set_column_title_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_column_title_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_column_title_language")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns column title language code.
    public final func getColumnTitleLanguage(column: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_get_column_title_language, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scroll")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the current scrolling position.
    public final func getScroll() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Tree.method_get_scroll, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_scroll_to_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("scroll_to_item")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1314737213)!
            }
            
        }
        
    }()
    
    /// Causes the ``Tree`` to jump to the specified ``TreeItem``.
    public final func scrollToItem(_ item: TreeItem?, centerOnItem: Bool = false) {
        withUnsafePointer(to: item?.handle) { pArg0 in
            withUnsafePointer(to: centerOnItem) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Tree.method_scroll_to_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_h_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_h_scroll_enabled")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_h_scroll_enabled(_ hScroll: Bool) {
        withUnsafePointer(to: hScroll) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_h_scroll_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_h_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_h_scroll_enabled")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_h_scroll_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_is_h_scroll_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_v_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_v_scroll_enabled")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_scroll_enabled(_ hScroll: Bool) {
        withUnsafePointer(to: hScroll) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_v_scroll_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_v_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_v_scroll_enabled")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_v_scroll_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_is_v_scroll_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_folding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hide_folding")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_folding(_ hide: Bool) {
        withUnsafePointer(to: hide) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_hide_folding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_folding_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_folding_hidden")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_folding_hidden() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_is_folding_hidden, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_enable_recursive_folding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_enable_recursive_folding")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_enable_recursive_folding(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_enable_recursive_folding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_recursive_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_recursive_folding_enabled")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_recursive_folding_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_is_recursive_folding_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drop_mode_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_drop_mode_flags")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drop_mode_flags(_ flags: Int32) {
        withUnsafePointer(to: flags) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_drop_mode_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_drop_mode_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_drop_mode_flags")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_drop_mode_flags() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tree.method_get_drop_mode_flags, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_rmb_select: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_allow_rmb_select")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_rmb_select(_ allow: Bool) {
        withUnsafePointer(to: allow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_allow_rmb_select, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_allow_rmb_select: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_allow_rmb_select")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_rmb_select() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_get_allow_rmb_select, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_allow_reselect")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_reselect(_ allow: Bool) {
        withUnsafePointer(to: allow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_allow_reselect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_allow_reselect")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_reselect() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_get_allow_reselect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_allow_search")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_search(_ allow: Bool) {
        withUnsafePointer(to: allow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tree.method_set_allow_search, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_allow_search")
        return withUnsafePointer(to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_search() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tree.method_get_allow_search, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Emitted when an item is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemSelected: SimpleSignal { SimpleSignal (target: self, signalName: "item_selected") }
    
    /// Emitted when a cell is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.cellSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var cellSelected: SimpleSignal { SimpleSignal (target: self, signalName: "cell_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64, _ selected: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1]!)!
                let arg_2 = Bool (args [2]!)!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted instead of [signal item_selected] if ``selectMode`` is set to ``SelectMode/multi``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.multiSelected.connect { item, column, selected in
    ///    print ("caught signal")
    /// }
    /// ```
    public var multiSelected: Signal1 { Signal1 (target: self, signalName: "multi_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ mousePosition: Vector2, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item is selected with a mouse button.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemMouseSelected.connect { mousePosition, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemMouseSelected: Signal2 { Signal2 (target: self, signalName: "item_mouse_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ clickPosition: Vector2, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a mouse button is clicked in the empty space of the tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.emptyClicked.connect { clickPosition, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var emptyClicked: Signal3 { Signal3 (target: self, signalName: "empty_clicked") }
    
    /// Emitted when an item is edited.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemEdited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemEdited: SimpleSignal { SimpleSignal (target: self, signalName: "item_edited") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item with ``TreeItem/TreeCellMode/custom`` is clicked with a mouse button.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.customItemClicked.connect { mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var customItemClicked: Signal4 { Signal4 (target: self, signalName: "custom_item_clicked") }
    
    /// Emitted when an item's icon is double-clicked. For a signal that emits when any part of the item is double-clicked, see [signal item_activated].
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemIconDoubleClicked.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemIconDoubleClicked: SimpleSignal { SimpleSignal (target: self, signalName: "item_icon_double_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item is collapsed by a click on the folding arrow.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemCollapsed.connect { item in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemCollapsed: Signal5 { Signal5 (target: self, signalName: "item_collapsed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when ``TreeItem/propagateCheck(column:emitSignal:)`` is called. Connect to this signal to process the items that are affected when ``TreeItem/propagateCheck(column:emitSignal:)`` is invoked. The order that the items affected will be processed is as follows: the item that invoked the method, children of that item, and finally parents of that item.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.checkPropagatedToItem.connect { item, column in
    ///    print ("caught signal")
    /// }
    /// ```
    public var checkPropagatedToItem: Signal6 { Signal6 (target: self, signalName: "check_propagated_to_item") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64, _ id: Int64, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1]!)!
                let arg_2 = Int64 (args [2]!)!
                let arg_3 = Int64 (args [3]!)!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a button on the tree was pressed (see ``TreeItem/addButton(column:button:id:disabled:tooltipText:)``).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.buttonClicked.connect { item, column, id, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var buttonClicked: Signal7 { Signal7 (target: self, signalName: "button_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ arrowClicked: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Bool (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a cell with the ``TreeItem/TreeCellMode/custom`` is clicked to be edited.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.customPopupEdited.connect { arrowClicked in
    ///    print ("caught signal")
    /// }
    /// ```
    public var customPopupEdited: Signal8 { Signal8 (target: self, signalName: "custom_popup_edited") }
    
    /// Emitted when an item is double-clicked, or selected with a `ui_accept` input event (e.g. using [kbd]Enter[/kbd] or [kbd]Space[/kbd] on the keyboard).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemActivated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemActivated: SimpleSignal { SimpleSignal (target: self, signalName: "item_activated") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal9/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal9/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal9/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal9 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal9 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ column: Int64, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a column's title is clicked with either ``MouseButton/left`` or ``MouseButton/right``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.columnTitleClicked.connect { column, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var columnTitleClicked: Signal9 { Signal9 (target: self, signalName: "column_title_clicked") }
    
    /// Emitted when a left mouse button click does not select any item.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nothingSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var nothingSelected: SimpleSignal { SimpleSignal (target: self, signalName: "nothing_selected") }
    
}

