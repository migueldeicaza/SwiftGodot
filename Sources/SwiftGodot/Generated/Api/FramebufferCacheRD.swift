// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Framebuffer cache manager for Rendering Device based renderers.
/// 
/// Framebuffer cache manager for Rendering Device based renderers. Provides a way to create a framebuffer and reuse it in subsequent calls for as long as the used textures exists. Framebuffers will automatically be cleaned up when dependent objects are freed.
open class FramebufferCacheRD: Object {
    override open class var godotClassName: StringName { "FramebufferCacheRD" }
    /* Methods */
    fileprivate static var method_get_cache_multipass: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cache_multipass")
        return withUnsafePointer(to: &FramebufferCacheRD.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3437881813)!
            }
            
        }
        
    }()
    
    /// Creates, or obtains a cached, framebuffer. `textures` lists textures accessed. `passes` defines the subpasses and texture allocation, if left empty a single pass is created and textures are allocated depending on their usage flags. `views` defines the number of views used when rendering.
    public static func getCacheMultipass(textures: VariantCollection<RID>, passes: ObjectCollection<RDFramebufferPass>, views: UInt32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: textures.array.content) { pArg0 in
            withUnsafePointer(to: passes.array.content) { pArg1 in
                withUnsafePointer(to: views) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_get_cache_multipass, nil, pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

