// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Lightweight object used for general-purpose animation via script, using ``Tweener``s.
/// 
/// Tweens are mostly useful for animations requiring a numerical property to be interpolated over a range of values. The name _tween_ comes from _in-betweening_, an animation technique where you specify _keyframes_ and the computer interpolates the frames that appear between them. Animating something with a ``Tween`` is called tweening.
/// 
/// ``Tween`` is more suited than ``AnimationPlayer`` for animations where you don't know the final values in advance. For example, interpolating a dynamically-chosen camera zoom value is best done with a ``Tween``; it would be difficult to do the same thing with an ``AnimationPlayer`` node. Tweens are also more light-weight than ``AnimationPlayer``, so they are very much suited for simple animations or general tasks that don't require visual tweaking provided by the editor. They can be used in a "fire-and-forget" manner for some logic that normally would be done by code. You can e.g. make something shoot periodically by using a looped ``CallbackTweener`` with a delay.
/// 
/// A ``Tween`` can be created by using either ``SceneTree/createTween()`` or ``Node/createTween()``. ``Tween``s created manually (i.e. by using `Tween.new()`) are invalid and can't be used for tweening values.
/// 
/// A tween animation is created by adding ``Tweener``s to the ``Tween`` object, using ``tweenProperty(object:property:finalVal:duration:)``, ``tweenInterval(time:)``, ``tweenCallback(_:)`` or ``tweenMethod(_:from:to:duration:)``:
/// 
/// This sequence will make the `$Sprite` node turn red, then shrink, before finally calling ``Node/queueFree()`` to free the sprite. ``Tweener``s are executed one after another by default. This behavior can be changed using ``parallel()`` and ``setParallel(_:)``.
/// 
/// When a ``Tweener`` is created with one of the `tween_*` methods, a chained method call can be used to tweak the properties of this ``Tweener``. For example, if you want to set a different transition type in the above example, you can use ``setTrans(_:)``:
/// 
/// Most of the ``Tween`` methods can be chained this way too. In the following example the ``Tween`` is bound to the running script's node and a default transition is set for its ``Tweener``s:
/// 
/// Another interesting use for ``Tween``s is animating arbitrary sets of objects:
/// 
/// In the example above, all children of a node are moved one after another to position (0, 0).
/// 
/// You should avoid using more than one ``Tween`` per object's property. If two or more tweens animate one property at the same time, the last one created will take priority and assign the final value. If you want to interrupt and restart an animation, consider assigning the ``Tween`` to a variable:
/// 
/// Some ``Tweener``s use transitions and eases. The first accepts a ``Tween/TransitionType`` constant, and refers to the way the timing of the animation is handled (see <a href="https://easings.net/">easings.net</a> for some examples). The second accepts an ``Tween/EaseType`` constant, and controls where the `trans_type` is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different ``Tween/TransitionType`` constants with ``EaseType/inOut``, and use the one that looks best.
/// 
/// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/tween_cheatsheet.webp">Tween easing and transition types cheatsheet</a>
/// 
/// > Note: Tweens are not designed to be re-used and trying to do so results in an undefined behavior. Create a new Tween for each animation and every time you replay an animation from start. Keep in mind that Tweens start immediately, so only create a Tween when you want to start animating.
/// 
/// > Note: The tween is processed after all of the nodes in the current frame, i.e. node's ``Node/_process(delta:)`` method would be called before the tween (or ``Node/_physicsProcess(delta:)`` depending on the value passed to ``setProcessMode(_:)``).
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``stepFinished``
/// - ``loopFinished``
/// - ``finished``
open class Tween: RefCounted {
    override open class var godotClassName: StringName { "Tween" }
    public enum TweenProcessMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The ``Tween`` updates after each physics frame (see ``Node/_physicsProcess(delta:)``).
        case physics = 0 // TWEEN_PROCESS_PHYSICS
        /// The ``Tween`` updates after each process frame (see ``Node/_process(delta:)``).
        case idle = 1 // TWEEN_PROCESS_IDLE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .physics: return ".physics"
                case .idle: return ".idle"
            }
            
        }
        
    }
    
    public enum TweenPauseMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// If the ``Tween`` has a bound node, it will process when that node can process (see ``Node/processMode``). Otherwise it's the same as ``TweenPauseMode/stop``.
        case bound = 0 // TWEEN_PAUSE_BOUND
        /// If ``SceneTree`` is paused, the ``Tween`` will also pause.
        case stop = 1 // TWEEN_PAUSE_STOP
        /// The ``Tween`` will process regardless of whether ``SceneTree`` is paused.
        case process = 2 // TWEEN_PAUSE_PROCESS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .bound: return ".bound"
                case .stop: return ".stop"
                case .process: return ".process"
            }
            
        }
        
    }
    
    public enum TransitionType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The animation is interpolated linearly.
        case linear = 0 // TRANS_LINEAR
        /// The animation is interpolated using a sine function.
        case sine = 1 // TRANS_SINE
        /// The animation is interpolated with a quintic (to the power of 5) function.
        case quint = 2 // TRANS_QUINT
        /// The animation is interpolated with a quartic (to the power of 4) function.
        case quart = 3 // TRANS_QUART
        /// The animation is interpolated with a quadratic (to the power of 2) function.
        case quad = 4 // TRANS_QUAD
        /// The animation is interpolated with an exponential (to the power of x) function.
        case expo = 5 // TRANS_EXPO
        /// The animation is interpolated with elasticity, wiggling around the edges.
        case elastic = 6 // TRANS_ELASTIC
        /// The animation is interpolated with a cubic (to the power of 3) function.
        case cubic = 7 // TRANS_CUBIC
        /// The animation is interpolated with a function using square roots.
        case circ = 8 // TRANS_CIRC
        /// The animation is interpolated by bouncing at the end.
        case bounce = 9 // TRANS_BOUNCE
        /// The animation is interpolated backing out at ends.
        case back = 10 // TRANS_BACK
        /// The animation is interpolated like a spring towards the end.
        case spring = 11 // TRANS_SPRING
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .linear: return ".linear"
                case .sine: return ".sine"
                case .quint: return ".quint"
                case .quart: return ".quart"
                case .quad: return ".quad"
                case .expo: return ".expo"
                case .elastic: return ".elastic"
                case .cubic: return ".cubic"
                case .circ: return ".circ"
                case .bounce: return ".bounce"
                case .back: return ".back"
                case .spring: return ".spring"
            }
            
        }
        
    }
    
    public enum EaseType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The interpolation starts slowly and speeds up towards the end.
        case `in` = 0 // EASE_IN
        /// The interpolation starts quickly and slows down towards the end.
        case out = 1 // EASE_OUT
        /// A combination of ``EaseType/`in``` and ``EaseType/out``. The interpolation is slowest at both ends.
        case inOut = 2 // EASE_IN_OUT
        /// A combination of ``EaseType/`in``` and ``EaseType/out``. The interpolation is fastest at both ends.
        case outIn = 3 // EASE_OUT_IN
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`in`: return ".`in`"
                case .out: return ".out"
                case .inOut: return ".inOut"
                case .outIn: return ".outIn"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_tween_property: GDExtensionMethodBindPtr = {
        let methodName = StringName("tween_property")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4049770449)!
            }
            
        }
        
    }()
    
    /// Creates and appends a ``PropertyTweener``. This method tweens a `property` of an `object` between an initial value and `finalVal` in a span of time equal to `duration`, in seconds. The initial value by default is the property's value at the time the tweening of the ``PropertyTweener`` starts.
    /// 
    /// **Example:**
    /// 
    /// will move the sprite to position (100, 200) and then to (200, 300). If you use ``PropertyTweener/from(value:)`` or ``PropertyTweener/fromCurrent()``, the starting position will be overwritten by the given value instead. See other methods in ``PropertyTweener`` to see how the tweening can be tweaked further.
    /// 
    /// > Note: You can find the correct property name by hovering over the property in the Inspector. You can also provide the components of a property directly by using `"property:component"` (eg. `position:x`), where it would only apply to that particular component.
    /// 
    /// **Example:** Moving an object twice from the same position, with different transition types:
    /// 
    public final func tweenProperty(object: Object?, property: NodePath, finalVal: Variant?, duration: Double) -> PropertyTweener? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: finalVal.content) { pArg2 in
                    withUnsafePointer(to: duration) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Tween.method_tween_property, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_tween_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName("tween_interval")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 413360199)!
            }
            
        }
        
    }()
    
    /// Creates and appends an ``IntervalTweener``. This method can be used to create delays in the tween animation, as an alternative to using the delay in other ``Tweener``s, or when there's no animation (in which case the ``Tween`` acts as a timer). `time` is the length of the interval, in seconds.
    /// 
    /// **Example:** Creating an interval in code execution:
    /// 
    /// **Example:** Creating an object that moves back and forth and jumps every few seconds:
    /// 
    public final func tweenInterval(time: Double) -> IntervalTweener? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: time) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_tween_interval, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_tween_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("tween_callback")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1540176488)!
            }
            
        }
        
    }()
    
    /// Creates and appends a ``CallbackTweener``. This method can be used to call an arbitrary method in any object. Use ``Callable/bind()`` to bind additional arguments for the call.
    /// 
    /// **Example:** Object that keeps shooting every 1 second:
    /// 
    /// **Example:** Turning a sprite red and then blue, with 2 second delay:
    /// 
    public final func tweenCallback(_ callback: Callable) -> CallbackTweener? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: callback.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_tween_callback, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_tween_method: GDExtensionMethodBindPtr = {
        let methodName = StringName("tween_method")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2337877153)!
            }
            
        }
        
    }()
    
    /// Creates and appends a ``MethodTweener``. This method is similar to a combination of ``tweenCallback(_:)`` and ``tweenProperty(object:property:finalVal:duration:)``. It calls a method over time with a tweened value provided as an argument. The value is tweened between `from` and `to` over the time specified by `duration`, in seconds. Use ``Callable/bind()`` to bind additional arguments for the call. You can use ``MethodTweener/setEase(_:)`` and ``MethodTweener/setTrans(_:)`` to tweak the easing and transition of the value or ``MethodTweener/setDelay(_:)`` to delay the tweening.
    /// 
    /// **Example:** Making a 3D object look from one point to another point:
    /// 
    /// **Example:** Setting the text of a ``Label``, using an intermediate method and after a delay:
    /// 
    public final func tweenMethod(_ method: Callable, from: Variant?, to: Variant?, duration: Double) -> MethodTweener? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: method.content) { pArg0 in
            withUnsafePointer(to: from.content) { pArg1 in
                withUnsafePointer(to: to.content) { pArg2 in
                    withUnsafePointer(to: duration) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Tween.method_tween_method, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_custom_step: GDExtensionMethodBindPtr = {
        let methodName = StringName("custom_step")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 330693286)!
            }
            
        }
        
    }()
    
    /// Processes the ``Tween`` by the given `delta` value, in seconds. This is mostly useful for manual control when the ``Tween`` is paused. It can also be used to end the ``Tween`` animation immediately, by setting `delta` longer than the whole duration of the ``Tween`` animation.
    /// 
    /// Returns `true` if the ``Tween`` still has ``Tweener``s that haven't finished.
    /// 
    public final func customStep(delta: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: delta) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_custom_step, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName("stop")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the tweening and resets the ``Tween`` to its initial state. This will not remove any appended ``Tweener``s.
    /// 
    /// > Note: If a Tween is stopped and not bound to any node, it will exist indefinitely until manually started or invalidated. If you lose a reference to such Tween, you can retrieve it using ``SceneTree/getProcessedTweens()``.
    /// 
    public final func stop() {
        gi.object_method_bind_ptrcall(Tween.method_stop, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName("pause")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Pauses the tweening. The animation can be resumed by using ``play()``.
    /// 
    /// > Note: If a Tween is paused and not bound to any node, it will exist indefinitely until manually started or invalidated. If you lose a reference to such Tween, you can retrieve it using ``SceneTree/getProcessedTweens()``.
    /// 
    public final func pause() {
        gi.object_method_bind_ptrcall(Tween.method_pause, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_play: GDExtensionMethodBindPtr = {
        let methodName = StringName("play")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Resumes a paused or stopped ``Tween``.
    public final func play() {
        gi.object_method_bind_ptrcall(Tween.method_play, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_kill: GDExtensionMethodBindPtr = {
        let methodName = StringName("kill")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Aborts all tweening operations and invalidates the ``Tween``.
    public final func kill() {
        gi.object_method_bind_ptrcall(Tween.method_kill, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_total_elapsed_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_total_elapsed_time")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the total time in seconds the ``Tween`` has been animating (i.e. the time since it started, not counting pauses etc.). The time is affected by ``setSpeedScale(speed:)``, and ``stop()`` will reset it to `0`.
    /// 
    /// > Note: As it results from accumulating frame deltas, the time returned after the ``Tween`` has finished animating will be slightly greater than the actual ``Tween`` duration.
    /// 
    public final func getTotalElapsedTime() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Tween.method_get_total_elapsed_time, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_running: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_running")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns whether the ``Tween`` is currently running, i.e. it wasn't paused and it's not finished.
    public final func isRunning() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tween.method_is_running, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_valid")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns whether the ``Tween`` is valid. A valid ``Tween`` is a ``Tween`` contained by the scene tree (i.e. the array from ``SceneTree/getProcessedTweens()`` will contain this ``Tween``). A ``Tween`` might become invalid when it has finished tweening, is killed, or when created with `Tween.new()`. Invalid ``Tween``s can't have ``Tweener``s appended.
    public final func isValid() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Tween.method_is_valid, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_bind_node: GDExtensionMethodBindPtr = {
        let methodName = StringName("bind_node")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2946786331)!
            }
            
        }
        
    }()
    
    /// Binds this ``Tween`` with the given `node`. ``Tween``s are processed directly by the ``SceneTree``, so they run independently of the animated nodes. When you bind a ``Node`` with the ``Tween``, the ``Tween`` will halt the animation when the object is not inside tree and the ``Tween`` will be automatically killed when the bound object is freed. Also ``TweenPauseMode/bound`` will make the pausing behavior dependent on the bound node.
    /// 
    /// For a shorter way to create and bind a ``Tween``, you can use ``Node/createTween()``.
    /// 
    public final func bindNode(_ node: Node?) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: node?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_bind_node, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_process_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_process_mode")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 855258840)!
            }
            
        }
        
    }()
    
    /// Determines whether the ``Tween`` should run after process frames (see ``Node/_process(delta:)``) or physics frames (see ``Node/_physicsProcess(delta:)``).
    /// 
    /// Default value is ``TweenProcessMode/idle``.
    /// 
    public final func setProcessMode(_ mode: Tween.TweenProcessMode) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_process_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_pause_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pause_mode")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3363368837)!
            }
            
        }
        
    }()
    
    /// Determines the behavior of the ``Tween`` when the ``SceneTree`` is paused. Check ``Tween/TweenPauseMode`` for options.
    /// 
    /// Default value is ``TweenPauseMode/bound``.
    /// 
    public final func setPauseMode(_ mode: Tween.TweenPauseMode) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_pause_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_parallel: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_parallel")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1942052223)!
            }
            
        }
        
    }()
    
    /// If `parallel` is `true`, the ``Tweener``s appended after this method will by default run simultaneously, as opposed to sequentially.
    /// 
    /// > Note: Just like with ``parallel()``, the tweener added right before this method will also be part of the parallel step.
    /// 
    public final func setParallel(_ parallel: Bool = true) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: parallel) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_parallel, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_loops: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_loops")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2670836414)!
            }
            
        }
        
    }()
    
    /// Sets the number of times the tweening sequence will be repeated, i.e. `set_loops(2)` will run the animation twice.
    /// 
    /// Calling this method without arguments will make the ``Tween`` run infinitely, until either it is killed with ``kill()``, the ``Tween``'s bound node is freed, or all the animated objects have been freed (which makes further animation impossible).
    /// 
    /// > Warning: Make sure to always add some duration/delay when using infinite loops. To prevent the game freezing, 0-duration looped animations (e.g. a single ``CallbackTweener`` with no delay) are stopped after a small number of loops, which may produce unexpected results. If a ``Tween``'s lifetime depends on some node, always use ``bindNode(_:)``.
    /// 
    public final func setLoops(_ loops: Int32 = 0) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: loops) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_loops, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_loops_left: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_loops_left")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of remaining loops for this ``Tween`` (see ``setLoops(_:)``). A return value of `-1` indicates an infinitely looping ``Tween``, and a return value of `0` indicates that the ``Tween`` has already finished.
    public final func getLoopsLeft() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Tween.method_get_loops_left, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_speed_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_speed_scale")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3961971106)!
            }
            
        }
        
    }()
    
    /// Scales the speed of tweening. This affects all ``Tweener``s and their delays.
    public final func setSpeedScale(speed: Double) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: speed) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_speed_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_trans: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_trans")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3965963875)!
            }
            
        }
        
    }()
    
    /// Sets the default transition type for ``PropertyTweener``s and ``MethodTweener``s animated by this ``Tween``.
    /// 
    /// If not specified, the default value is ``TransitionType/linear``.
    /// 
    public final func setTrans(_ trans: Tween.TransitionType) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: trans.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_trans, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_ease: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_ease")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1208117252)!
            }
            
        }
        
    }()
    
    /// Sets the default ease type for ``PropertyTweener``s and ``MethodTweener``s animated by this ``Tween``.
    /// 
    /// If not specified, the default value is ``EaseType/inOut``.
    /// 
    public final func setEase(_ ease: Tween.EaseType) -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: ease.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Tween.method_set_ease, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_parallel: GDExtensionMethodBindPtr = {
        let methodName = StringName("parallel")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3426978995)!
            }
            
        }
        
    }()
    
    /// Makes the next ``Tweener`` run parallelly to the previous one.
    /// 
    /// **Example:**
    /// 
    /// All ``Tweener``s in the example will run at the same time.
    /// 
    /// You can make the ``Tween`` parallel by default by using ``setParallel(_:)``.
    /// 
    public final func parallel() -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Tween.method_parallel, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_chain: GDExtensionMethodBindPtr = {
        let methodName = StringName("chain")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3426978995)!
            }
            
        }
        
    }()
    
    /// Used to chain two ``Tweener``s after ``setParallel(_:)`` is called with `true`.
    /// 
    public final func chain() -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Tween.method_chain, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_interpolate_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("interpolate_value")
        return withUnsafePointer(to: &Tween.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3452526450)!
            }
            
        }
        
    }()
    
    /// This method can be used for manual interpolation of a value, when you don't want ``Tween`` to do animating for you. It's similar to ``@GlobalScope.lerp``, but with support for custom transition and easing.
    /// 
    /// `initialValue` is the starting value of the interpolation.
    /// 
    /// `deltaValue` is the change of the value in the interpolation, i.e. it's equal to `final_value - initial_value`.
    /// 
    /// `elapsedTime` is the time in seconds that passed after the interpolation started and it's used to control the position of the interpolation. E.g. when it's equal to half of the `duration`, the interpolated value will be halfway between initial and final values. This value can also be greater than `duration` or lower than 0, which will extrapolate the value.
    /// 
    /// `duration` is the total time of the interpolation.
    /// 
    /// > Note: If `duration` is equal to `0`, the method will always return the final value, regardless of `elapsedTime` provided.
    /// 
    public static func interpolateValue(initialValue: Variant?, deltaValue: Variant?, elapsedTime: Double, duration: Double, transType: Tween.TransitionType, easeType: Tween.EaseType) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: initialValue.content) { pArg0 in
            withUnsafePointer(to: deltaValue.content) { pArg1 in
                withUnsafePointer(to: elapsedTime) { pArg2 in
                    withUnsafePointer(to: duration) { pArg3 in
                        withUnsafePointer(to: transType.rawValue) { pArg4 in
                            withUnsafePointer(to: easeType.rawValue) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(method_interpolate_value, nil, pArgs, &_result)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ idx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when one step of the ``Tween`` is complete, providing the step index. One step is either a single ``Tweener`` or a group of ``Tweener``s running in parallel.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.stepFinished.connect { idx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var stepFinished: Signal1 { Signal1 (target: self, signalName: "step_finished") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ loopCount: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a full loop is complete (see ``setLoops(_:)``), providing the loop index. This signal is not emitted after the final loop, use [signal finished] instead for this case.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.loopFinished.connect { loopCount in
    ///    print ("caught signal")
    /// }
    /// ```
    public var loopFinished: Signal2 { Signal2 (target: self, signalName: "loop_finished") }
    
    /// Emitted when the ``Tween`` has finished all tweening. Never emitted when the ``Tween`` is set to infinite looping (see ``setLoops(_:)``).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.finished.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var finished: SimpleSignal { SimpleSignal (target: self, signalName: "finished") }
    
}

