// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Provides occlusion culling for 3D nodes, which improves performance in closed areas.
/// 
/// Occlusion culling can improve rendering performance in closed/semi-open areas by hiding geometry that is occluded by other objects.
/// 
/// The occlusion culling system is mostly static. ``OccluderInstance3D``s can be moved or hidden at run-time, but doing so will trigger a background recomputation that can take several frames. It is recommended to only move ``OccluderInstance3D``s sporadically (e.g. for procedural generation purposes), rather than doing so every frame.
/// 
/// The occlusion culling system works by rendering the occluders on the CPU in parallel using <a href="https://www.embree.org/">Embree</a>, drawing the result to a low-resolution buffer then using this to cull 3D nodes individually. In the 3D editor, you can preview the occlusion culling buffer by choosing **Perspective > Debug Advanced... > Occlusion Culling Buffer** in the top-left corner of the 3D viewport. The occlusion culling buffer quality can be adjusted in the Project Settings.
/// 
/// **Baking:** Select an ``OccluderInstance3D`` node, then use the **Bake Occluders** button at the top of the 3D editor. Only opaque materials will be taken into account; transparent materials (alpha-blended or alpha-tested) will be ignored by the occluder generation.
/// 
/// > Note: Occlusion culling is only effective if ``ProjectSettings/rendering/occlusionCulling/useOcclusionCulling`` is `true`. Enabling occlusion culling has a cost on the CPU. Only enable occlusion culling if you actually plan to use it. Large open scenes with few or no objects blocking the view will generally not benefit much from occlusion culling. Large open scenes generally benefit more from mesh LOD and visibility ranges (``GeometryInstance3D/visibilityRangeBegin`` and ``GeometryInstance3D/visibilityRangeEnd``) compared to occlusion culling.
/// 
/// > Note: Due to memory constraints, occlusion culling is not supported by default in Web export templates. It can be enabled by compiling custom Web export templates with `module_raycast_enabled=yes`.
/// 
open class OccluderInstance3D: VisualInstance3D {
    override open class var godotClassName: StringName { "OccluderInstance3D" }
    
    /* Properties */
    
    /// The occluder resource for this ``OccluderInstance3D``. You can generate an occluder resource by selecting an ``OccluderInstance3D`` node then using the **Bake Occluders** button at the top of the editor.
    /// 
    /// You can also draw your own 2D occluder polygon by adding a new ``PolygonOccluder3D`` resource to the ``occluder`` property in the Inspector.
    /// 
    /// Alternatively, you can select a primitive occluder to use: ``QuadOccluder3D``, ``BoxOccluder3D`` or ``SphereOccluder3D``.
    /// 
    final public var occluder: Occluder3D? {
        get {
            return get_occluder ()
        }
        
        set {
            set_occluder (newValue)
        }
        
    }
    
    /// The visual layers to account for when baking for occluders. Only ``MeshInstance3D``s whose ``VisualInstance3D/layers`` match with this ``bakeMask`` will be included in the generated occluder mesh. By default, all objects with _opaque_ materials are taken into account for the occluder baking.
    /// 
    /// To improve performance and avoid artifacts, it is recommended to exclude dynamic objects, small objects and fixtures from the baking process by moving them to a separate visual layer and excluding this layer in ``bakeMask``.
    /// 
    final public var bakeMask: UInt32 {
        get {
            return get_bake_mask ()
        }
        
        set {
            set_bake_mask (newValue)
        }
        
    }
    
    /// The simplification distance to use for simplifying the generated occluder polygon (in 3D units). Higher values result in a less detailed occluder mesh, which improves performance but reduces culling accuracy.
    /// 
    /// The occluder geometry is rendered on the CPU, so it is important to keep its geometry as simple as possible. Since the buffer is rendered at a low resolution, less detailed occluder meshes generally still work well. The default value is fairly aggressive, so you may have to decrease it if you run into false negatives (objects being occluded even though they are visible by the camera). A value of `0.01` will act conservatively, and will keep geometry _perceptually_ unaffected in the occlusion culling buffer. Depending on the scene, a value of `0.01` may still simplify the mesh noticeably compared to disabling simplification entirely.
    /// 
    /// Setting this to `0.0` disables simplification entirely, but vertices in the exact same position will still be merged. The mesh will also be re-indexed to reduce both the number of vertices and indices.
    /// 
    /// > Note: This uses the <a href="https://meshoptimizer.org/">meshoptimizer</a> library under the hood, similar to LOD generation.
    /// 
    final public var bakeSimplificationDistance: Double {
        get {
            return get_bake_simplification_distance ()
        }
        
        set {
            set_bake_simplification_distance (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_bake_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bake_mask")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bake_mask(_ mask: UInt32) {
        withUnsafePointer(to: mask) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OccluderInstance3D.method_set_bake_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bake_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_mask")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bake_mask() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(OccluderInstance3D.method_get_bake_mask, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_bake_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bake_mask_value")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``bakeMask``, given a `layerNumber` between 1 and 32.
    public final func setBakeMaskValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OccluderInstance3D.method_set_bake_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bake_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_mask_value")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``bakeMask`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getBakeMaskValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OccluderInstance3D.method_get_bake_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bake_simplification_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bake_simplification_distance")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bake_simplification_distance(_ simplificationDistance: Double) {
        withUnsafePointer(to: simplificationDistance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OccluderInstance3D.method_set_bake_simplification_distance, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bake_simplification_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_simplification_distance")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bake_simplification_distance() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(OccluderInstance3D.method_get_bake_simplification_distance, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_occluder: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_occluder")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1664878165)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_occluder(_ occluder: Occluder3D?) {
        withUnsafePointer(to: occluder?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OccluderInstance3D.method_set_occluder, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_occluder: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_occluder")
        return withUnsafePointer(to: &OccluderInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1696836198)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_occluder() -> Occluder3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(OccluderInstance3D.method_get_occluder, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
}

