// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Plugin for adding custom parsers to extract strings that are to be translated from custom files (.csv, .json etc.).
/// 
/// ``EditorTranslationParserPlugin`` is invoked when a file is being parsed to extract strings that require translation. To define the parsing and string extraction logic, override the ``_parseFile(path:msgids:msgidsContextPlural:)`` method in script.
/// 
/// Add the extracted strings to argument `msgids` or `msgids_context_plural` if context or plural is used.
/// 
/// When adding to `msgids_context_plural`, you must add the data using the format `["A", "B", "C"]`, where `A` represents the extracted string, `B` represents the context, and `C` represents the plural version of the extracted string. If you want to add only context but not plural, put `""` for the plural slot. The idea is the same if you only want to add plural but not context. See the code below for concrete examples.
/// 
/// The extracted strings will be written into a POT file selected by user under "POT Generation" in "Localization" tab in "Project Settings" menu.
/// 
/// Below shows an example of a custom parser that extracts strings from a CSV file to write into a POT.
/// 
/// To add a translatable string associated with context or plural, add it to `msgids_context_plural`:
/// 
/// > Note: If you override parsing logic for standard script types (GDScript, C#, etc.), it would be better to load the `path` argument using ``ResourceLoader/load(path:typeHint:cacheMode:)``. This is because built-in scripts are loaded as ``Resource`` type, not ``FileAccess`` type.
/// 
/// For example:
/// 
/// To use ``EditorTranslationParserPlugin``, register it using the ``EditorPlugin/addTranslationParserPlugin(parser:)`` method first.
/// 
open class EditorTranslationParserPlugin: RefCounted {
    override open class var godotClassName: StringName { "EditorTranslationParserPlugin" }
    /* Methods */
    /// Override this method to define a custom parsing logic to extract the translatable strings.
    @_documentation(visibility: public)
    open func _parseFile(path: String, msgids: VariantCollection<String>, msgidsContextPlural: VariantCollection<GArray>) {
    }
    
    /// Gets the list of file extensions to associate with this parser, e.g. `["csv"]`.
    @_documentation(visibility: public)
    open func _getRecognizedExtensions() -> PackedStringArray {
        return PackedStringArray ()
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_recognized_extensions":
                return _EditorTranslationParserPlugin_proxy_get_recognized_extensions
            case "_parse_file":
                return _EditorTranslationParserPlugin_proxy_parse_file
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _EditorTranslationParserPlugin_proxy_get_recognized_extensions (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorTranslationParserPlugin>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getRecognizedExtensions ()
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _EditorTranslationParserPlugin_proxy_parse_file (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorTranslationParserPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._parseFile (path: GString.stringFromGStringPtr (ptr: args [0]!) ?? "", msgids: args [1]!.assumingMemoryBound (to: VariantCollection<String>.self).pointee, msgidsContextPlural: args [2]!.assumingMemoryBound (to: VariantCollection<GArray>.self).pointee)
}

