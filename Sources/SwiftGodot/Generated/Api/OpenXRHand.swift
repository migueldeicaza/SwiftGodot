// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node supporting hand and finger tracking in OpenXR.
/// 
/// This node enables OpenXR's hand tracking functionality. The node should be a child node of an ``XROrigin3D`` node, tracking will update its position to the player's tracked hand Palm joint location (the center of the middle finger's metacarpal bone). This node also updates the skeleton of a properly skinned hand or avatar model.
/// 
/// If the skeleton is a hand (one of the hand bones is the root node of the skeleton), then the skeleton will be placed relative to the hand palm location and the hand mesh and skeleton should be children of the OpenXRHand node.
/// 
/// If the hand bones are part of a full skeleton, then the root of the hand will keep its location with the assumption that IK is used to position the hand and arm.
/// 
/// By default the skeleton hand bones are repositioned to match the size of the tracked hand. To preserve the modeled bone sizes change ``boneUpdate`` to apply rotation only.
/// 
open class OpenXRHand: Node3D {
    override open class var godotClassName: StringName { "OpenXRHand" }
    public enum Hands: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Tracking the player's left hand.
        case left = 0 // HAND_LEFT
        /// Tracking the player's right hand.
        case right = 1 // HAND_RIGHT
        /// Maximum supported hands.
        case max = 2 // HAND_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .left: return ".left"
                case .right: return ".right"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum MotionRange: Int64, CaseIterable, CustomDebugStringConvertible {
        /// When player grips, hand skeleton will form a full fist.
        case unobstructed = 0 // MOTION_RANGE_UNOBSTRUCTED
        /// When player grips, hand skeleton conforms to the controller the player is holding.
        case conformToController = 1 // MOTION_RANGE_CONFORM_TO_CONTROLLER
        /// Maximum supported motion ranges.
        case max = 2 // MOTION_RANGE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .unobstructed: return ".unobstructed"
                case .conformToController: return ".conformToController"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum SkeletonRig: Int64, CaseIterable, CustomDebugStringConvertible {
        /// An OpenXR compliant skeleton.
        case openxr = 0 // SKELETON_RIG_OPENXR
        /// A ``SkeletonProfileHumanoid`` compliant skeleton.
        case humanoid = 1 // SKELETON_RIG_HUMANOID
        /// Maximum supported hands.
        case max = 2 // SKELETON_RIG_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .openxr: return ".openxr"
                case .humanoid: return ".humanoid"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum BoneUpdate: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The skeletons bones are fully updated (both position and rotation) to match the tracked bones.
        case full = 0 // BONE_UPDATE_FULL
        /// The skeletons bones are only rotated to align with the tracked bones, preserving bone length.
        case rotationOnly = 1 // BONE_UPDATE_ROTATION_ONLY
        /// Maximum supported bone update mode.
        case max = 2 // BONE_UPDATE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .full: return ".full"
                case .rotationOnly: return ".rotationOnly"
                case .max: return ".max"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// Specifies whether this node tracks the left or right hand of the player.
    final public var hand: OpenXRHand.Hands {
        get {
            return get_hand ()
        }
        
        set {
            set_hand (newValue)
        }
        
    }
    
    /// Set the motion range (if supported) limiting the hand motion.
    final public var motionRange: OpenXRHand.MotionRange {
        get {
            return get_motion_range ()
        }
        
        set {
            set_motion_range (newValue)
        }
        
    }
    
    /// Set a ``Skeleton3D`` node for which the pose positions will be updated.
    final public var handSkeleton: NodePath {
        get {
            return get_hand_skeleton ()
        }
        
        set {
            set_hand_skeleton (newValue)
        }
        
    }
    
    /// Set the type of skeleton rig the ``handSkeleton`` is compliant with.
    final public var skeletonRig: OpenXRHand.SkeletonRig {
        get {
            return get_skeleton_rig ()
        }
        
        set {
            set_skeleton_rig (newValue)
        }
        
    }
    
    /// Specify the type of updates to perform on the bone.
    final public var boneUpdate: OpenXRHand.BoneUpdate {
        get {
            return get_bone_update ()
        }
        
        set {
            set_bone_update (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hand")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1849328560)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hand(_ hand: OpenXRHand.Hands) {
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRHand.method_set_hand, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2850644561)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_hand() -> OpenXRHand.Hands {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(OpenXRHand.method_get_hand, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return OpenXRHand.Hands (rawValue: _result)!
    }
    
    fileprivate static var method_set_hand_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hand_skeleton")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hand_skeleton(_ handSkeleton: NodePath) {
        withUnsafePointer(to: handSkeleton.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRHand.method_set_hand_skeleton, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_hand_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_skeleton")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_hand_skeleton() -> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall(OpenXRHand.method_get_hand_skeleton, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_motion_range")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3326516003)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_motion_range(_ motionRange: OpenXRHand.MotionRange) {
        withUnsafePointer(to: motionRange.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRHand.method_set_motion_range, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_motion_range")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2191822314)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_motion_range() -> OpenXRHand.MotionRange {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(OpenXRHand.method_get_motion_range, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return OpenXRHand.MotionRange (rawValue: _result)!
    }
    
    fileprivate static var method_set_skeleton_rig: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_skeleton_rig")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1528072213)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_skeleton_rig(_ skeletonRig: OpenXRHand.SkeletonRig) {
        withUnsafePointer(to: skeletonRig.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRHand.method_set_skeleton_rig, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_skeleton_rig: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_skeleton_rig")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 968409338)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_skeleton_rig() -> OpenXRHand.SkeletonRig {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(OpenXRHand.method_get_skeleton_rig, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return OpenXRHand.SkeletonRig (rawValue: _result)!
    }
    
    fileprivate static var method_set_bone_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_update")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3144625444)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bone_update(_ boneUpdate: OpenXRHand.BoneUpdate) {
        withUnsafePointer(to: boneUpdate.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRHand.method_set_bone_update, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_update")
        return withUnsafePointer(to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1310695248)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bone_update() -> OpenXRHand.BoneUpdate {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(OpenXRHand.method_get_bone_update, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return OpenXRHand.BoneUpdate (rawValue: _result)!
    }
    
}

