// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node for 3D tile-based maps.
/// 
/// GridMap lets you place meshes on a grid interactively. It works both from the editor and from scripts, which can help you create in-game level editors.
/// 
/// GridMaps use a ``MeshLibrary`` which contains a list of tiles. Each tile is a mesh with materials plus optional collision and navigation shapes.
/// 
/// A GridMap contains a collection of cells. Each grid cell refers to a tile in the ``MeshLibrary``. All cells in the map have the same dimensions.
/// 
/// Internally, a GridMap is split into a sparse collection of octants for efficient rendering and physics processing. Every octant has the same dimensions and can contain several cells.
/// 
/// > Note: GridMap doesn't extend ``VisualInstance3D`` and therefore can't be hidden or cull masked based on ``VisualInstance3D/layers``. If you make a light not affect the first layer, the whole GridMap won't be lit by the light in question.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``cellSizeChanged``
/// - ``changed``
open class GridMap: Node3D {
    override open class var godotClassName: StringName { "GridMap" }
    /* Constants */
    /// Invalid cell item that can be used in ``setCellItem(position:item:orientation:)`` to clear cells (or represent an empty cell in ``getCellItem(position:)``).
    public static let invalidCellItem = -1
    
    /* Properties */
    
    /// The assigned ``MeshLibrary``.
    final public var meshLibrary: MeshLibrary? {
        get {
            return get_mesh_library ()
        }
        
        set {
            set_mesh_library (newValue)
        }
        
    }
    
    /// Overrides the default friction and bounce physics properties for the whole ``GridMap``.
    final public var physicsMaterial: PhysicsMaterial? {
        get {
            return get_physics_material ()
        }
        
        set {
            set_physics_material (newValue)
        }
        
    }
    
    /// The dimensions of the grid's cells.
    /// 
    /// This does not affect the size of the meshes. See ``cellScale``.
    /// 
    final public var cellSize: Vector3 {
        get {
            return get_cell_size ()
        }
        
        set {
            set_cell_size (newValue)
        }
        
    }
    
    /// The size of each octant measured in number of cells. This applies to all three axis.
    final public var cellOctantSize: Int32 {
        get {
            return get_octant_size ()
        }
        
        set {
            set_octant_size (newValue)
        }
        
    }
    
    /// If `true`, grid items are centered on the X axis.
    final public var cellCenterX: Bool {
        get {
            return get_center_x ()
        }
        
        set {
            set_center_x (newValue)
        }
        
    }
    
    /// If `true`, grid items are centered on the Y axis.
    final public var cellCenterY: Bool {
        get {
            return get_center_y ()
        }
        
        set {
            set_center_y (newValue)
        }
        
    }
    
    /// If `true`, grid items are centered on the Z axis.
    final public var cellCenterZ: Bool {
        get {
            return get_center_z ()
        }
        
        set {
            set_center_z (newValue)
        }
        
    }
    
    /// The scale of the cell items.
    /// 
    /// This does not affect the size of the grid cells themselves, only the items in them. This can be used to make cell items overlap their neighbors.
    /// 
    final public var cellScale: Double {
        get {
            return get_cell_scale ()
        }
        
        set {
            set_cell_scale (newValue)
        }
        
    }
    
    /// The physics layers this GridMap is in.
    /// 
    /// GridMaps act as static bodies, meaning they aren't affected by gravity or other forces. They only affect other physics bodies that collide with them.
    /// 
    final public var collisionLayer: UInt32 {
        get {
            return get_collision_layer ()
        }
        
        set {
            set_collision_layer (newValue)
        }
        
    }
    
    /// The physics layers this GridMap detects collisions in. See <a href="https://docs.godotengine.org/en//tutorials/physics/physics_introduction.html#collision-layers-and-masks">Collision layers and masks</a> in the documentation for more information.
    final public var collisionMask: UInt32 {
        get {
            return get_collision_mask ()
        }
        
        set {
            set_collision_mask (newValue)
        }
        
    }
    
    /// The priority used to solve colliding when occurring penetration. The higher the priority is, the lower the penetration into the object will be. This can for example be used to prevent the player from breaking through the boundaries of a level.
    final public var collisionPriority: Double {
        get {
            return get_collision_priority ()
        }
        
        set {
            set_collision_priority (newValue)
        }
        
    }
    
    /// If `true`, this GridMap creates a navigation region for each cell that uses a ``meshLibrary`` item with a navigation mesh. The created navigation region will use the navigation layers bitmask assigned to the ``MeshLibrary``'s item.
    final public var bakeNavigation: Bool {
        get {
            return is_baking_navigation ()
        }
        
        set {
            set_bake_navigation (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_layer(_ layer: UInt32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_collision_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_layer() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(GridMap.method_get_collision_layer, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_mask(_ mask: UInt32) {
        withUnsafePointer(to: mask) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_collision_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_mask() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(GridMap.method_get_collision_mask, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask_value")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionMask``, given a `layerNumber` between 1 and 32.
    public final func setCollisionMaskValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GridMap.method_set_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask_value")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionMask`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionMaskValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer_value")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionLayer``, given a `layerNumber` between 1 and 32.
    public final func setCollisionLayerValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GridMap.method_set_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer_value")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionLayer`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionLayerValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_priority")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_priority(_ priority: Double) {
        withUnsafePointer(to: priority) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_collision_priority, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_priority")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_priority() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GridMap.method_get_collision_priority, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_material: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_physics_material")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1784508650)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_material(_ material: PhysicsMaterial?) {
        withUnsafePointer(to: material?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_physics_material, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_physics_material: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_physics_material")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2521850424)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_material() -> PhysicsMaterial? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(GridMap.method_get_physics_material, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_bake_navigation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bake_navigation")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bake_navigation(_ bakeNavigation: Bool) {
        withUnsafePointer(to: bakeNavigation) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_bake_navigation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_baking_navigation: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_baking_navigation")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_baking_navigation() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GridMap.method_is_baking_navigation, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_map")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Sets the ``RID`` of the navigation map this GridMap node should use for its cell baked navigation meshes.
    public final func setNavigationMap(_ navigationMap: RID) {
        withUnsafePointer(to: navigationMap.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_navigation_map")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of the navigation map this GridMap node uses for its cell baked navigation meshes.
    /// 
    /// This function returns always the map set on the GridMap node and not the map on the NavigationServer. If the map is changed directly with the NavigationServer API the GridMap node will not be aware of the map change.
    /// 
    public final func getNavigationMap() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(GridMap.method_get_navigation_map, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_mesh_library: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_mesh_library")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1488083439)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mesh_library(_ meshLibrary: MeshLibrary?) {
        withUnsafePointer(to: meshLibrary?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_mesh_library, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mesh_library: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mesh_library")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3350993772)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mesh_library() -> MeshLibrary? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(GridMap.method_get_mesh_library, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_cell_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_size")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3460891852)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_cell_size(_ size: Vector3) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_cell_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_cell_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_size")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3360562783)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_cell_size() -> Vector3 {
        var _result: Vector3 = Vector3 ()
        gi.object_method_bind_ptrcall(GridMap.method_get_cell_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_cell_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_scale")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_cell_scale(_ scale: Double) {
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_cell_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_cell_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_scale")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_cell_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GridMap.method_get_cell_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_octant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_octant_size")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_octant_size(_ size: Int32) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_octant_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_octant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_octant_size")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_octant_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(GridMap.method_get_octant_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_cell_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_item")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3449088946)!
            }
            
        }
        
    }()
    
    /// Sets the mesh index for the cell referenced by its grid coordinates.
    /// 
    /// A negative item index such as ``invalidCellItem`` will clear the cell.
    /// 
    /// Optionally, the item's orientation can be passed. For valid orientation values, see ``getOrthogonalIndexFromBasis(_:)``.
    /// 
    public final func setCellItem(position: Vector3i, item: Int32, orientation: Int32 = 0) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: item) { pArg1 in
                withUnsafePointer(to: orientation) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(GridMap.method_set_cell_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_cell_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_item")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3724960147)!
            }
            
        }
        
    }()
    
    /// The ``MeshLibrary`` item index located at the given grid coordinates. If the cell is empty, ``invalidCellItem`` will be returned.
    public final func getCellItem(position: Vector3i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_cell_item, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_item_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_item_orientation")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3724960147)!
            }
            
        }
        
    }()
    
    /// The orientation of the cell at the given grid coordinates. `-1` is returned if the cell is empty.
    public final func getCellItemOrientation(position: Vector3i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_cell_item_orientation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_item_basis: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_item_basis")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3493604918)!
            }
            
        }
        
    }()
    
    /// Returns the basis that gives the specified cell its orientation.
    public final func getCellItemBasis(position: Vector3i) -> Basis {
        var _result: Basis = Basis ()
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_cell_item_basis, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_basis_with_orthogonal_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_basis_with_orthogonal_index")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2816196998)!
            }
            
        }
        
    }()
    
    /// Returns one of 24 possible rotations that lie along the vectors (x,y,z) with each component being either -1, 0, or 1. For further details, refer to the Godot source code.
    public final func getBasisWithOrthogonalIndex(_ index: Int32) -> Basis {
        var _result: Basis = Basis ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_basis_with_orthogonal_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_orthogonal_index_from_basis: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_orthogonal_index_from_basis")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4210359952)!
            }
            
        }
        
    }()
    
    /// This function considers a discretization of rotations into 24 points on unit sphere, lying along the vectors (x,y,z) with each component being either -1, 0, or 1, and returns the index (in the range from 0 to 23) of the point best representing the orientation of the object. For further details, refer to the Godot source code.
    public final func getOrthogonalIndexFromBasis(_ basis: Basis) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: basis) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_orthogonal_index_from_basis, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_local_to_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("local_to_map")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1257687843)!
            }
            
        }
        
    }()
    
    /// Returns the map coordinates of the cell containing the given `localPosition`. If `localPosition` is in global coordinates, consider using ``Node3D/toLocal(globalPoint:)`` before passing it to this method. See also ``mapToLocal(mapPosition:)``.
    public final func localToMap(localPosition: Vector3) -> Vector3i {
        var _result: Vector3i = Vector3i ()
        withUnsafePointer(to: localPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_local_to_map, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_map_to_local: GDExtensionMethodBindPtr = {
        let methodName = StringName("map_to_local")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1088329196)!
            }
            
        }
        
    }()
    
    /// Returns the position of a grid cell in the GridMap's local coordinate space. To convert the returned value into global coordinates, use ``Node3D/toGlobal(localPoint:)``. See also ``localToMap(localPosition:)``.
    public final func mapToLocal(mapPosition: Vector3i) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: mapPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_map_to_local, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_resource_changed: GDExtensionMethodBindPtr = {
        let methodName = StringName("resource_changed")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 968641751)!
            }
            
        }
        
    }()
    
    /// This method does nothing.
    public final func resourceChanged(resource: Resource?) {
        withUnsafePointer(to: resource?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_resource_changed, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_center_x: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_center_x")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_center_x(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_center_x, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_center_x: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_center_x")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_center_x() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GridMap.method_get_center_x, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_center_y: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_center_y")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_center_y(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_center_y, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_center_y: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_center_y")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_center_y() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GridMap.method_get_center_y, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_center_z: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_center_z")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_center_z(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_set_center_z, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_center_z: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_center_z")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_center_z() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GridMap.method_get_center_z, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clear all cells.
    public final func clear() {
        gi.object_method_bind_ptrcall(GridMap.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_used_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an array of ``Vector3`` with the non-empty cell coordinates in the grid map.
    public final func getUsedCells() -> VariantCollection<Vector3i> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(GridMap.method_get_used_cells, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<Vector3i>(content: _result)
    }
    
    fileprivate static var method_get_used_cells_by_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells_by_item")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 663333327)!
            }
            
        }
        
    }()
    
    /// Returns an array of all cells with the given item index specified in `item`.
    public final func getUsedCellsByItem(_ item: Int32) -> VariantCollection<Vector3i> {
        var _result: Int64 = 0
        withUnsafePointer(to: item) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_used_cells_by_item, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<Vector3i>(content: _result)
    }
    
    fileprivate static var method_get_meshes: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_meshes")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an array of ``Transform3D`` and ``Mesh`` references corresponding to the non-empty cells in the grid. The transforms are specified in local space.
    public final func getMeshes() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(GridMap.method_get_meshes, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_bake_meshes: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_meshes")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Returns an array of ``ArrayMesh``es and ``Transform3D`` references of all bake meshes that exist within the current GridMap.
    public final func getBakeMeshes() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(GridMap.method_get_bake_meshes, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_bake_mesh_instance: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_mesh_instance")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 937000113)!
            }
            
        }
        
    }()
    
    /// Returns ``RID`` of a baked mesh with the given `idx`.
    public final func getBakeMeshInstance(idx: Int32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GridMap.method_get_bake_mesh_instance, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clear_baked_meshes: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_baked_meshes")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all baked meshes. See ``makeBakedMeshes(genLightmapUv:lightmapUvTexelSize:)``.
    public final func clearBakedMeshes() {
        gi.object_method_bind_ptrcall(GridMap.method_clear_baked_meshes, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_make_baked_meshes: GDExtensionMethodBindPtr = {
        let methodName = StringName("make_baked_meshes")
        return withUnsafePointer(to: &GridMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3609286057)!
            }
            
        }
        
    }()
    
    /// Bakes lightmap data for all meshes in the assigned ``MeshLibrary``.
    public final func makeBakedMeshes(genLightmapUv: Bool = false, lightmapUvTexelSize: Double = 0.1) {
        withUnsafePointer(to: genLightmapUv) { pArg0 in
            withUnsafePointer(to: lightmapUvTexelSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GridMap.method_make_baked_meshes, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ cellSize: Vector3) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector3 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when ``cellSize`` changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.cellSizeChanged.connect { cellSize in
    ///    print ("caught signal")
    /// }
    /// ```
    public var cellSizeChanged: Signal1 { Signal1 (target: self, signalName: "cell_size_changed") }
    
    /// Emitted when the ``MeshLibrary`` of this GridMap changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.changed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var changed: SimpleSignal { SimpleSignal (target: self, signalName: "changed") }
    
}

