// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Data transformation (marshaling) and encoding helpers.
/// 
/// Provides data transformation and encoding utility functions.
open class Marshalls: Object {
    /// The shared instance of this class
    public static var shared: Marshalls = {
        return withUnsafePointer (to: &Marshalls.godotClassName.content) { ptr in
            Marshalls (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "Marshalls" }
    /* Methods */
    fileprivate static var method_variant_to_base64: GDExtensionMethodBindPtr = {
        let methodName = StringName("variant_to_base64")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3876248563)!
            }
            
        }
        
    }()
    
    /// Returns a Base64-encoded string of the ``Variant`` `variant`. If `fullObjects` is `true`, encoding objects is allowed (and can potentially include code).
    /// 
    /// Internally, this uses the same encoding mechanism as the ``@GlobalScope.var_to_bytes`` method.
    /// 
    public static func variantToBase64(variant: Variant?, fullObjects: Bool = false) -> String {
        let _result = GString ()
        withUnsafePointer(to: variant.content) { pArg0 in
            withUnsafePointer(to: fullObjects) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_variant_to_base64, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_base64_to_variant: GDExtensionMethodBindPtr = {
        let methodName = StringName("base64_to_variant")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 218087648)!
            }
            
        }
        
    }()
    
    /// Returns a decoded ``Variant`` corresponding to the Base64-encoded string `base64Str`. If `allowObjects` is `true`, decoding objects is allowed.
    /// 
    /// Internally, this uses the same decoding mechanism as the ``@GlobalScope.bytes_to_var`` method.
    /// 
    /// > Warning: Deserialized objects can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats such as remote code execution.
    /// 
    public static func base64ToVariant(base64Str: String, allowObjects: Bool = false) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        let base64Str = GString(base64Str)
        withUnsafePointer(to: base64Str.content) { pArg0 in
            withUnsafePointer(to: allowObjects) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_base64_to_variant, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_raw_to_base64: GDExtensionMethodBindPtr = {
        let methodName = StringName("raw_to_base64")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3999417757)!
            }
            
        }
        
    }()
    
    /// Returns a Base64-encoded string of a given ``PackedByteArray``.
    public static func rawToBase64(array: PackedByteArray) -> String {
        let _result = GString ()
        withUnsafePointer(to: array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_raw_to_base64, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_base64_to_raw: GDExtensionMethodBindPtr = {
        let methodName = StringName("base64_to_raw")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 659035735)!
            }
            
        }
        
    }()
    
    /// Returns a decoded ``PackedByteArray`` corresponding to the Base64-encoded string `base64Str`.
    public static func base64ToRaw(base64Str: String) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        let base64Str = GString(base64Str)
        withUnsafePointer(to: base64Str.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_base64_to_raw, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_utf8_to_base64: GDExtensionMethodBindPtr = {
        let methodName = StringName("utf8_to_base64")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1703090593)!
            }
            
        }
        
    }()
    
    /// Returns a Base64-encoded string of the UTF-8 string `utf8Str`.
    public static func utf8ToBase64(utf8Str: String) -> String {
        let _result = GString ()
        let utf8Str = GString(utf8Str)
        withUnsafePointer(to: utf8Str.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_utf8_to_base64, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_base64_to_utf8: GDExtensionMethodBindPtr = {
        let methodName = StringName("base64_to_utf8")
        return withUnsafePointer(to: &Marshalls.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1703090593)!
            }
            
        }
        
    }()
    
    /// Returns a decoded string corresponding to the Base64-encoded string `base64Str`.
    public static func base64ToUtf8(base64Str: String) -> String {
        let _result = GString ()
        let base64Str = GString(base64Str)
        withUnsafePointer(to: base64Str.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_base64_to_utf8, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
}

