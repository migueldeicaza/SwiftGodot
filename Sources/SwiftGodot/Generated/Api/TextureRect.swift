// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control that displays a texture.
/// 
/// A control that displays a texture, for example an icon inside a GUI. The texture's placement can be controlled with the ``stretchMode`` property. It can scale, tile, or stay centered inside its bounding rectangle.
open class TextureRect: Control {
    override open class var godotClassName: StringName { "TextureRect" }
    public enum ExpandMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The minimum size will be equal to texture size, i.e. ``TextureRect`` can't be smaller than the texture.
        case keepSize = 0 // EXPAND_KEEP_SIZE
        /// The size of the texture won't be considered for minimum size calculation, so the ``TextureRect`` can be shrunk down past the texture size.
        case ignoreSize = 1 // EXPAND_IGNORE_SIZE
        /// The height of the texture will be ignored. Minimum width will be equal to the current height. Useful for horizontal layouts, e.g. inside ``HBoxContainer``.
        case fitWidth = 2 // EXPAND_FIT_WIDTH
        /// Same as ``ExpandMode/fitWidth``, but keeps texture's aspect ratio.
        case fitWidthProportional = 3 // EXPAND_FIT_WIDTH_PROPORTIONAL
        /// The width of the texture will be ignored. Minimum height will be equal to the current width. Useful for vertical layouts, e.g. inside ``VBoxContainer``.
        case fitHeight = 4 // EXPAND_FIT_HEIGHT
        /// Same as ``ExpandMode/fitHeight``, but keeps texture's aspect ratio.
        case fitHeightProportional = 5 // EXPAND_FIT_HEIGHT_PROPORTIONAL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .keepSize: return ".keepSize"
                case .ignoreSize: return ".ignoreSize"
                case .fitWidth: return ".fitWidth"
                case .fitWidthProportional: return ".fitWidthProportional"
                case .fitHeight: return ".fitHeight"
                case .fitHeightProportional: return ".fitHeightProportional"
            }
            
        }
        
    }
    
    public enum StretchMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Scale to fit the node's bounding rectangle.
        case scale = 0 // STRETCH_SCALE
        /// Tile inside the node's bounding rectangle.
        case tile = 1 // STRETCH_TILE
        /// The texture keeps its original size and stays in the bounding rectangle's top-left corner.
        case keep = 2 // STRETCH_KEEP
        /// The texture keeps its original size and stays centered in the node's bounding rectangle.
        case keepCentered = 3 // STRETCH_KEEP_CENTERED
        /// Scale the texture to fit the node's bounding rectangle, but maintain the texture's aspect ratio.
        case keepAspect = 4 // STRETCH_KEEP_ASPECT
        /// Scale the texture to fit the node's bounding rectangle, center it and maintain its aspect ratio.
        case keepAspectCentered = 5 // STRETCH_KEEP_ASPECT_CENTERED
        /// Scale the texture so that the shorter side fits the bounding rectangle. The other side clips to the node's limits.
        case keepAspectCovered = 6 // STRETCH_KEEP_ASPECT_COVERED
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .scale: return ".scale"
                case .tile: return ".tile"
                case .keep: return ".keep"
                case .keepCentered: return ".keepCentered"
                case .keepAspect: return ".keepAspect"
                case .keepAspectCentered: return ".keepAspectCentered"
                case .keepAspectCovered: return ".keepAspectCovered"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The node's ``Texture2D`` resource.
    final public var texture: Texture2D? {
        get {
            return get_texture ()
        }
        
        set {
            set_texture (newValue)
        }
        
    }
    
    /// Defines how minimum size is determined based on the texture's size. See ``TextureRect/ExpandMode`` for options.
    final public var expandMode: TextureRect.ExpandMode {
        get {
            return get_expand_mode ()
        }
        
        set {
            set_expand_mode (newValue)
        }
        
    }
    
    /// Controls the texture's behavior when resizing the node's bounding rectangle. See ``TextureRect/StretchMode``.
    final public var stretchMode: TextureRect.StretchMode {
        get {
            return get_stretch_mode ()
        }
        
        set {
            set_stretch_mode (newValue)
        }
        
    }
    
    /// If `true`, texture is flipped horizontally.
    final public var flipH: Bool {
        get {
            return is_flipped_h ()
        }
        
        set {
            set_flip_h (newValue)
        }
        
    }
    
    /// If `true`, texture is flipped vertically.
    final public var flipV: Bool {
        get {
            return is_flipped_v ()
        }
        
        set {
            set_flip_v (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_texture")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture(_ texture: Texture2D?) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextureRect.method_set_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_texture")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(TextureRect.method_get_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_expand_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_expand_mode")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1870766882)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_expand_mode(_ expandMode: TextureRect.ExpandMode) {
        withUnsafePointer(to: expandMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextureRect.method_set_expand_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_expand_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_expand_mode")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3863824733)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_expand_mode() -> TextureRect.ExpandMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TextureRect.method_get_expand_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextureRect.ExpandMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_flip_h: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_flip_h")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flip_h(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextureRect.method_set_flip_h, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_flipped_h: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_flipped_h")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flipped_h() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TextureRect.method_is_flipped_h, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_flip_v: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_flip_v")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flip_v(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextureRect.method_set_flip_v, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_flipped_v: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_flipped_v")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flipped_v() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TextureRect.method_is_flipped_v, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_stretch_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_stretch_mode")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 58788729)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_stretch_mode(_ stretchMode: TextureRect.StretchMode) {
        withUnsafePointer(to: stretchMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextureRect.method_set_stretch_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_stretch_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_stretch_mode")
        return withUnsafePointer(to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 346396079)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_stretch_mode() -> TextureRect.StretchMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TextureRect.method_get_stretch_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextureRect.StretchMode (rawValue: _result)!
    }
    
}

