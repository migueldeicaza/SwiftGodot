// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstract base class for 3D physics objects.
/// 
/// Abstract base class for 3D physics objects. ``CollisionObject3D`` can hold any number of ``Shape3D``s for collision. Each shape must be assigned to a _shape owner_. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the `shape_owner_*` methods.
/// 
/// > Warning: With a non-uniform scale, this node will likely not behave as expected. It is advised to keep its scale the same on all axes and adjust its collision shape(s) instead.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``inputEvent``
/// - ``mouseEntered``
/// - ``mouseExited``
open class CollisionObject3D: Node3D {
    override open class var godotClassName: StringName { "CollisionObject3D" }
    public enum DisableMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, remove from the physics simulation to stop all physics interactions with this ``CollisionObject3D``.
        /// 
        /// Automatically re-added to the physics simulation when the ``Node`` is processed again.
        /// 
        case remove = 0 // DISABLE_MODE_REMOVE
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, make the body static. Doesn't affect ``Area3D``. ``PhysicsBody3D`` can't be affected by forces or other bodies while static.
        /// 
        /// Automatically set ``PhysicsBody3D`` back to its original mode when the ``Node`` is processed again.
        /// 
        case makeStatic = 1 // DISABLE_MODE_MAKE_STATIC
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, do not affect the physics simulation.
        case keepActive = 2 // DISABLE_MODE_KEEP_ACTIVE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .remove: return ".remove"
                case .makeStatic: return ".makeStatic"
                case .keepActive: return ".keepActive"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// Defines the behavior in physics when ``Node/processMode`` is set to ``Node/ProcessMode/disabled``. See ``CollisionObject3D/DisableMode`` for more details about the different modes.
    final public var disableMode: CollisionObject3D.DisableMode {
        get {
            return get_disable_mode ()
        }
        
        set {
            set_disable_mode (newValue)
        }
        
    }
    
    /// The physics layers this CollisionObject3D **is in**. Collision objects can exist in one or more of 32 different layers. See also ``collisionMask``.
    /// 
    /// > Note: Object A can detect a contact with object B only if object B is in any of the layers that object A scans. See <a href="https://docs.godotengine.org/en//tutorials/physics/physics_introduction.html#collision-layers-and-masks">Collision layers and masks</a> in the documentation for more information.
    /// 
    final public var collisionLayer: UInt32 {
        get {
            return get_collision_layer ()
        }
        
        set {
            set_collision_layer (newValue)
        }
        
    }
    
    /// The physics layers this CollisionObject3D **scans**. Collision objects can scan one or more of 32 different layers. See also ``collisionLayer``.
    /// 
    /// > Note: Object A can detect a contact with object B only if object B is in any of the layers that object A scans. See <a href="https://docs.godotengine.org/en//tutorials/physics/physics_introduction.html#collision-layers-and-masks">Collision layers and masks</a> in the documentation for more information.
    /// 
    final public var collisionMask: UInt32 {
        get {
            return get_collision_mask ()
        }
        
        set {
            set_collision_mask (newValue)
        }
        
    }
    
    /// The priority used to solve colliding when occurring penetration. The higher the priority is, the lower the penetration into the object will be. This can for example be used to prevent the player from breaking through the boundaries of a level.
    final public var collisionPriority: Double {
        get {
            return get_collision_priority ()
        }
        
        set {
            set_collision_priority (newValue)
        }
        
    }
    
    /// If `true`, this object is pickable. A pickable object can detect the mouse pointer entering/leaving, and if the mouse is inside it, report input events. Requires at least one ``collisionLayer`` bit to be set.
    final public var inputRayPickable: Bool {
        get {
            return is_ray_pickable ()
        }
        
        set {
            set_ray_pickable (newValue)
        }
        
    }
    
    /// If `true`, the ``CollisionObject3D`` will continue to receive input events as the mouse is dragged across its shapes.
    final public var inputCaptureOnDrag: Bool {
        get {
            return get_capture_input_on_drag ()
        }
        
        set {
            set_capture_input_on_drag (newValue)
        }
        
    }
    
    /* Methods */
    /// Receives unhandled ``InputEvent``s. `eventPosition` is the location in world space of the mouse pointer on the surface of the shape with index `shapeIdx` and `normal` is the normal vector of the surface at that point. Connect to the [signal input_event] signal to easily pick up these events.
    /// 
    /// > Note: ``_inputEvent(camera:event:eventPosition:normal:shapeIdx:)`` requires ``inputRayPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    /// 
    @_documentation(visibility: public)
    open func _inputEvent(camera: Camera3D?, event: InputEvent?, eventPosition: Vector3, normal: Vector3, shapeIdx: Int32) {
    }
    
    /// Called when the mouse pointer enters any of this object's shapes. Requires ``inputRayPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject3D`` won't cause this function to be called.
    @_documentation(visibility: public)
    open func _mouseEnter() {
    }
    
    /// Called when the mouse pointer exits all this object's shapes. Requires ``inputRayPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject3D`` won't cause this function to be called.
    @_documentation(visibility: public)
    open func _mouseExit() {
    }
    
    fileprivate static var method_set_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_layer(_ layer: UInt32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_collision_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_layer() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_collision_layer, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_mask(_ mask: UInt32) {
        withUnsafePointer(to: mask) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_collision_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_mask() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_collision_mask, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer_value")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionLayer``, given a `layerNumber` between 1 and 32.
    public final func setCollisionLayerValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_set_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer_value")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionLayer`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionLayerValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_get_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask_value")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionMask``, given a `layerNumber` between 1 and 32.
    public final func setCollisionMaskValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_set_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask_value")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionMask`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionMaskValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_get_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_priority")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_priority(_ priority: Double) {
        withUnsafePointer(to: priority) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_collision_priority, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_priority")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_priority() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_collision_priority, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_disable_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_mode")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1623620376)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_mode(_ mode: CollisionObject3D.DisableMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_disable_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_disable_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_disable_mode")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 410164780)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_disable_mode() -> CollisionObject3D.DisableMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_disable_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return CollisionObject3D.DisableMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_ray_pickable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_ray_pickable")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_ray_pickable(_ rayPickable: Bool) {
        withUnsafePointer(to: rayPickable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_ray_pickable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_ray_pickable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_ray_pickable")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_ray_pickable() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CollisionObject3D.method_is_ray_pickable, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_capture_input_on_drag: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_capture_input_on_drag")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_capture_input_on_drag(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_set_capture_input_on_drag, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_capture_input_on_drag: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_capture_input_on_drag")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_capture_input_on_drag() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_capture_input_on_drag, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rid")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the object's ``RID``.
    public final func getRid() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_rid, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_create_shape_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_shape_owner")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3429307534)!
            }
            
        }
        
    }()
    
    /// Creates a new shape owner for the given object. Returns `owner_id` of the new owner for future reference.
    public final func createShapeOwner(_ owner: Object?) -> UInt32 {
        var _result: UInt32 = 0
        withUnsafePointer(to: owner?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_create_shape_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_shape_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_shape_owner")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the given shape owner.
    public final func removeShapeOwner(ownerId: UInt32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_remove_shape_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_shape_owners: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_shape_owners")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 969006518)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` of `owner_id` identifiers. You can use these ids in other methods that take `owner_id` as an argument.
    public final func getShapeOwners() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(CollisionObject3D.method_get_shape_owners, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_shape_owner_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_transform")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3616898986)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform3D`` of the given shape owner.
    public final func shapeOwnerSetTransform(ownerId: UInt32, transform: Transform3D) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: transform) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_set_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_transform")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the shape owner's ``Transform3D``.
    public final func shapeOwnerGetTransform(ownerId: UInt32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_get_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_get_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_owner")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3332903315)!
            }
            
        }
        
    }()
    
    /// Returns the parent object of the given shape owner.
    public final func shapeOwnerGetOwner(ownerId: UInt32) -> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_get_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_shape_owner_set_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_disabled")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `true`, disables the given shape owner.
    public final func shapeOwnerSetDisabled(ownerId: UInt32, disabled: Bool) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: disabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_set_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_shape_owner_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_shape_owner_disabled")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// If `true`, the shape owner and its shapes are disabled.
    public final func isShapeOwnerDisabled(ownerId: UInt32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_is_shape_owner_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_add_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_add_shape")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2566676345)!
            }
            
        }
        
    }()
    
    /// Adds a ``Shape3D`` to the shape owner.
    public final func shapeOwnerAddShape(ownerId: UInt32, shape: Shape3D?) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shape?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_add_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_get_shape_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape_count")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the number of shapes the given shape owner contains.
    public final func shapeOwnerGetShapeCount(ownerId: UInt32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_get_shape_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_get_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4015519174)!
            }
            
        }
        
    }()
    
    /// Returns the ``Shape3D`` with the given ID from the given shape owner.
    public final func shapeOwnerGetShape(ownerId: UInt32, shapeId: Int32) -> Shape3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_get_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_shape_owner_get_shape_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape_index")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Returns the child index of the ``Shape3D`` with the given ID from the given shape owner.
    public final func shapeOwnerGetShapeIndex(ownerId: UInt32, shapeId: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_get_shape_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_remove_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_remove_shape")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Removes a shape from the given shape owner.
    public final func shapeOwnerRemoveShape(ownerId: UInt32, shapeId: Int32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_remove_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_clear_shapes: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_clear_shapes")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes all shapes from the shape owner.
    public final func shapeOwnerClearShapes(ownerId: UInt32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_owner_clear_shapes, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_find_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_find_owner")
        return withUnsafePointer(to: &CollisionObject3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the `owner_id` of the given shape.
    public final func shapeFindOwner(shapeIndex: Int32) -> UInt32 {
        var _result: UInt32 = 0
        withUnsafePointer(to: shapeIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject3D.method_shape_find_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_input_event":
                return _CollisionObject3D_proxy_input_event
            case "_mouse_enter":
                return _CollisionObject3D_proxy_mouse_enter
            case "_mouse_exit":
                return _CollisionObject3D_proxy_mouse_exit
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ camera: Node, _ event: InputEvent, _ eventPosition: Vector3, _ normal: Vector3, _ shapeIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? lookupObject (nativeHandle: ptr_0!) ?? Node (nativeHandle: ptr_0!)
                var ptr_1: UnsafeMutableRawPointer?
                args [1]!.toType (Variant.GType.object, dest: &ptr_1)
                let arg_1 = lookupLiveObject (handleAddress: ptr_1!) as? InputEvent ?? lookupObject (nativeHandle: ptr_1!) ?? InputEvent (nativeHandle: ptr_1!)
                let arg_2 = Vector3 (args [2]!)!
                let arg_3 = Vector3 (args [3]!)!
                let arg_4 = Int64 (args [4]!)!
                
                callback (arg_0, arg_1, arg_2, arg_3, arg_4)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the object receives an unhandled ``InputEvent``. `eventPosition` is the location in world space of the mouse pointer on the surface of the shape with index `shapeIdx` and `normal` is the normal vector of the surface at that point.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.inputEvent.connect { camera, event, eventPosition, normal, shapeIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var inputEvent: Signal1 { Signal1 (target: self, signalName: "input_event") }
    
    /// Emitted when the mouse pointer enters any of this object's shapes. Requires ``inputRayPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    /// 
    /// > Note: Due to the lack of continuous collision detection, this signal may not be emitted in the expected order if the mouse moves fast enough and the ``CollisionObject3D``'s area is small. This signal may also not be emitted if another ``CollisionObject3D`` is overlapping the ``CollisionObject3D`` in question.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseEntered: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_entered") }
    
    /// Emitted when the mouse pointer exits all this object's shapes. Requires ``inputRayPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    /// 
    /// > Note: Due to the lack of continuous collision detection, this signal may not be emitted in the expected order if the mouse moves fast enough and the ``CollisionObject3D``'s area is small. This signal may also not be emitted if another ``CollisionObject3D`` is overlapping the ``CollisionObject3D`` in question.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseExited: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_exited") }
    
}

// Support methods for proxies
func _CollisionObject3D_proxy_input_event (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CollisionObject3D>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._inputEvent (camera: lookupLiveObject (handleAddress: resolved_0) as? Camera3D ?? lookupObject (nativeHandle: resolved_0)!, event: lookupLiveObject (handleAddress: resolved_1) as? InputEvent ?? lookupObject (nativeHandle: resolved_1)!, eventPosition: args [2]!.assumingMemoryBound (to: Vector3.self).pointee, normal: args [3]!.assumingMemoryBound (to: Vector3.self).pointee, shapeIdx: args [4]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _CollisionObject3D_proxy_mouse_enter (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<CollisionObject3D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseEnter ()
}

func _CollisionObject3D_proxy_mouse_exit (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<CollisionObject3D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseExit ()
}

