// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A script that is executed when exporting the project.
/// 
/// ``EditorExportPlugin``s are automatically invoked whenever the user exports the project. Their most common use is to determine what files are being included in the exported project. For each plugin, ``_exportBegin(features:isDebug:path:flags:)`` is called at the beginning of the export process and then ``_exportFile(path:type:features:)`` is called for each exported file.
/// 
/// To use ``EditorExportPlugin``, register it using the ``EditorPlugin/addExportPlugin(_:)`` method first.
/// 
open class EditorExportPlugin: RefCounted {
    override open class var godotClassName: StringName { "EditorExportPlugin" }
    /* Methods */
    /// Virtual method to be overridden by the user. Called for each exported file, providing arguments that can be used to identify the file. `path` is the path of the file, `type` is the ``Resource`` represented by the file (e.g. ``PackedScene``) and `features` is the list of features for the export.
    /// 
    /// Calling ``skip()`` inside this callback will make the file not included in the export.
    /// 
    @_documentation(visibility: public)
    open func _exportFile(path: String, type: String, features: PackedStringArray) {
    }
    
    /// Virtual method to be overridden by the user. It is called when the export starts and provides all information about the export. `features` is the list of features for the export, `isDebug` is `true` for debug builds, `path` is the target path for the exported project. `flags` is only used when running a runnable profile, e.g. when using native run on Android.
    @_documentation(visibility: public)
    open func _exportBegin(features: PackedStringArray, isDebug: Bool, path: String, flags: UInt32) {
    }
    
    /// Virtual method to be overridden by the user. Called when the export is finished.
    @_documentation(visibility: public)
    open func _exportEnd() {
    }
    
    /// Return `true` if this plugin will customize resources based on the platform and features used.
    /// 
    /// When enabled, ``_getCustomizationConfigurationHash()``, ``_customizeResource(_:path:)`` and ``_customizeScene(_:path:)`` will be called and must be implemented.
    /// 
    @_documentation(visibility: public)
    open func _beginCustomizeResources(platform: EditorExportPlatform?, features: PackedStringArray) -> Bool {
        return false
    }
    
    /// Customize a resource. If changes are made to it, return the same or a new resource. Otherwise, return `null`.
    /// 
    /// The _path_ argument is only used when customizing an actual file, otherwise this means that this resource is part of another one and it will be empty.
    /// 
    /// Implementing this method is required if ``_beginCustomizeResources(platform:features:)`` returns `true`.
    /// 
    @_documentation(visibility: public)
    open func _customizeResource(_ resource: Resource?, path: String) -> Resource? {
        return Resource ()
    }
    
    /// Return true if this plugin will customize scenes based on the platform and features used.
    @_documentation(visibility: public)
    open func _beginCustomizeScenes(platform: EditorExportPlatform?, features: PackedStringArray) -> Bool {
        return false
    }
    
    /// Customize a scene. If changes are made to it, return the same or a new scene. Otherwise, return `null`. If a new scene is returned, it is up to you to dispose of the old one.
    /// 
    /// Implementing this method is required if ``_beginCustomizeScenes(platform:features:)`` returns `true`.
    /// 
    @_documentation(visibility: public)
    open func _customizeScene(_ scene: Node?, path: String) -> Node? {
        return Node ()
    }
    
    /// Return a hash based on the configuration passed (for both scenes and resources). This helps keep separate caches for separate export configurations.
    /// 
    /// Implementing this method is required if ``_beginCustomizeResources(platform:features:)`` returns `true`.
    /// 
    @_documentation(visibility: public)
    open func _getCustomizationConfigurationHash() -> UInt {
        return 0
    }
    
    /// This is called when the customization process for scenes ends.
    @_documentation(visibility: public)
    open func _endCustomizeScenes() {
    }
    
    /// This is called when the customization process for resources ends.
    @_documentation(visibility: public)
    open func _endCustomizeResources() {
    }
    
    /// Return a list of export options that can be configured for this export plugin.
    /// 
    /// Each element in the return value is a ``GDictionary`` with the following keys:
    /// 
    /// - `option`: A dictionary with the structure documented by ``Object/getPropertyList()``, but all keys are optional.
    /// 
    /// - `default_value`: The default value for this option.
    /// 
    /// - `update_visibility`: An optional boolean value. If set to `true`, the preset will emit [signal Object.property_list_changed] when the option is changed.
    /// 
    @_documentation(visibility: public)
    open func _getExportOptions(platform: EditorExportPlatform?) -> VariantCollection<GDictionary> {
        return VariantCollection<GDictionary>()
    }
    
    /// Return a ``GDictionary`` of override values for export options, that will be used instead of user-provided values. Overridden options will be hidden from the user interface.
    /// 
    @_documentation(visibility: public)
    open func _getExportOptionsOverrides(platform: EditorExportPlatform?) -> GDictionary {
        return GDictionary ()
    }
    
    /// Return `true`, if the result of ``_getExportOptions(platform:)`` has changed and the export options of preset corresponding to `platform` should be updated.
    @_documentation(visibility: public)
    open func _shouldUpdateExportOptions(platform: EditorExportPlatform?) -> Bool {
        return false
    }
    
    /// Check the requirements for the given `option` and return a non-empty warning string if they are not met.
    /// 
    /// > Note: Use ``getOption(name:)`` to check the value of the export options.
    /// 
    @_documentation(visibility: public)
    open func _getExportOptionWarning(platform: EditorExportPlatform?, option: String) -> String {
        return String ()
    }
    
    /// Return a ``PackedStringArray`` of additional features this preset, for the given `platform`, should have.
    @_documentation(visibility: public)
    open func _getExportFeatures(platform: EditorExportPlatform?, debug: Bool) -> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Return the name identifier of this plugin (for future identification by the exporter). The plugins are sorted by name before exporting.
    /// 
    /// Implementing this method is required.
    /// 
    @_documentation(visibility: public)
    open func _getName() -> String {
        return String ()
    }
    
    /// Return `true` if the plugin supports the given `platform`.
    @_documentation(visibility: public)
    open func _supportsPlatform(_ platform: EditorExportPlatform?) -> Bool {
        return false
    }
    
    /// Virtual method to be overridden by the user. This is called to retrieve the set of Android dependencies provided by this plugin. Each returned Android dependency should have the format of an Android remote binary dependency: `org.godot.example:my-plugin:0.0.0`
    /// 
    /// For more information see <a href="https://developer.android.com/build/dependencies?agpversion=4.1#dependency-types">Android documentation on dependencies</a>.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidDependencies(platform: EditorExportPlatform?, debug: Bool) -> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Virtual method to be overridden by the user. This is called to retrieve the URLs of Maven repositories for the set of Android dependencies provided by this plugin.
    /// 
    /// For more information see <a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:maven_repo">Gradle documentation on dependency management</a>.
    /// 
    /// > Note: Google's Maven repo and the Maven Central repo are already included by default.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidDependenciesMavenRepos(platform: EditorExportPlatform?, debug: Bool) -> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Virtual method to be overridden by the user. This is called to retrieve the local paths of the Android libraries archive (AAR) files provided by this plugin.
    /// 
    /// > Note: Relative paths **must** be relative to Godot's `res://addons/` directory. For example, an AAR file located under `res://addons/hello_world_plugin/HelloWorld.release.aar` can be returned as an absolute path using `res://addons/hello_world_plugin/HelloWorld.release.aar` or a relative path using `hello_world_plugin/HelloWorld.release.aar`.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidLibraries(platform: EditorExportPlatform?, debug: Bool) -> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Virtual method to be overridden by the user. This is used at export time to update the contents of the `activity` element in the generated Android manifest.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidManifestActivityElementContents(platform: EditorExportPlatform?, debug: Bool) -> String {
        return String ()
    }
    
    /// Virtual method to be overridden by the user. This is used at export time to update the contents of the `application` element in the generated Android manifest.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidManifestApplicationElementContents(platform: EditorExportPlatform?, debug: Bool) -> String {
        return String ()
    }
    
    /// Virtual method to be overridden by the user. This is used at export time to update the contents of the `manifest` element in the generated Android manifest.
    /// 
    /// > Note: Only supported on Android and requires ``EditorExportPlatformAndroid/gradleBuild/useGradleBuild`` to be enabled.
    /// 
    @_documentation(visibility: public)
    open func _getAndroidManifestElementContents(platform: EditorExportPlatform?, debug: Bool) -> String {
        return String ()
    }
    
    fileprivate static var method_add_shared_object: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_shared_object")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3098291045)!
            }
            
        }
        
    }()
    
    /// Adds a shared object or a directory containing only shared objects with the given `tags` and destination `path`.
    /// 
    /// > Note: In case of macOS exports, those shared objects will be added to `Frameworks` directory of app bundle.
    /// 
    /// In case of a directory code-sign will error if you place non code object in directory.
    /// 
    public final func addSharedObject(path: String, tags: PackedStringArray, target: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: tags.content) { pArg1 in
                let target = GString(target)
                withUnsafePointer(to: target.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_shared_object, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_project_static_lib: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_project_static_lib")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a static lib from the given `path` to the iOS project.
    public final func addIosProjectStaticLib(path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_project_static_lib, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_file")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 527928637)!
            }
            
        }
        
    }()
    
    /// Adds a custom file to be exported. `path` is the virtual path that can be used to load the file, `file` is the binary data of the file.
    /// 
    /// When called inside ``_exportFile(path:type:features:)`` and `remap` is `true`, the current file will not be exported, but instead remapped to this custom file. `remap` is ignored when called in other places.
    /// 
    public final func addFile(path: String, file: PackedByteArray, remap: Bool) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: file.content) { pArg1 in
                withUnsafePointer(to: remap) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_file, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_framework: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_framework")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a static library (*.a) or dynamic library (*.dylib, *.framework) to Linking Phase in iOS's Xcode project.
    public final func addIosFramework(path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_framework, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_embedded_framework: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_embedded_framework")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a dynamic library (*.dylib, *.framework) to Linking Phase in iOS's Xcode project and embeds it into resulting binary.
    /// 
    /// > Note: For static libraries (*.a) works in same way as ``addIosFramework(path:)``.
    /// 
    /// > Note: This method should not be used for System libraries as they are already present on the device.
    /// 
    public final func addIosEmbeddedFramework(path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_embedded_framework, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_plist_content: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_plist_content")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds content for iOS Property List files.
    public final func addIosPlistContent(_ plistContent: String) {
        let plistContent = GString(plistContent)
        withUnsafePointer(to: plistContent.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_plist_content, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_linker_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_linker_flags")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds linker flags for the iOS export.
    public final func addIosLinkerFlags(_ flags: String) {
        let flags = GString(flags)
        withUnsafePointer(to: flags.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_linker_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_bundle_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_bundle_file")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds an iOS bundle file from the given `path` to the exported project.
    public final func addIosBundleFile(path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_bundle_file, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_ios_cpp_code: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_ios_cpp_code")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a C++ code to the iOS export. The final code is created from the code appended by each active export plugin.
    public final func addIosCppCode(_ code: String) {
        let code = GString(code)
        withUnsafePointer(to: code.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_ios_cpp_code, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_macos_plugin_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_macos_plugin_file")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds file or directory matching `path` to `PlugIns` directory of macOS app bundle.
    /// 
    /// > Note: This is useful only for macOS exports.
    /// 
    public final func addMacosPluginFile(path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_add_macos_plugin_file, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_skip: GDExtensionMethodBindPtr = {
        let methodName = StringName("skip")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// To be called inside ``_exportFile(path:type:features:)``, ``_customizeResource(_:path:)``, or ``_customizeScene(_:path:)``. Skips the current file, so it's not included in the export.
    public final func skip() {
        gi.object_method_bind_ptrcall(EditorExportPlugin.method_skip, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_option: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_option")
        return withUnsafePointer(to: &EditorExportPlugin.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2760726917)!
            }
            
        }
        
    }()
    
    /// Returns the current value of an export option supplied by ``_getExportOptions(platform:)``.
    public final func getOption(name: StringName) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorExportPlugin.method_get_option, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_begin_customize_resources":
                return _EditorExportPlugin_proxy_begin_customize_resources
            case "_begin_customize_scenes":
                return _EditorExportPlugin_proxy_begin_customize_scenes
            case "_customize_resource":
                return _EditorExportPlugin_proxy_customize_resource
            case "_customize_scene":
                return _EditorExportPlugin_proxy_customize_scene
            case "_end_customize_resources":
                return _EditorExportPlugin_proxy_end_customize_resources
            case "_end_customize_scenes":
                return _EditorExportPlugin_proxy_end_customize_scenes
            case "_export_begin":
                return _EditorExportPlugin_proxy_export_begin
            case "_export_end":
                return _EditorExportPlugin_proxy_export_end
            case "_export_file":
                return _EditorExportPlugin_proxy_export_file
            case "_get_android_dependencies":
                return _EditorExportPlugin_proxy_get_android_dependencies
            case "_get_android_dependencies_maven_repos":
                return _EditorExportPlugin_proxy_get_android_dependencies_maven_repos
            case "_get_android_libraries":
                return _EditorExportPlugin_proxy_get_android_libraries
            case "_get_android_manifest_activity_element_contents":
                return _EditorExportPlugin_proxy_get_android_manifest_activity_element_contents
            case "_get_android_manifest_application_element_contents":
                return _EditorExportPlugin_proxy_get_android_manifest_application_element_contents
            case "_get_android_manifest_element_contents":
                return _EditorExportPlugin_proxy_get_android_manifest_element_contents
            case "_get_customization_configuration_hash":
                return _EditorExportPlugin_proxy_get_customization_configuration_hash
            case "_get_export_features":
                return _EditorExportPlugin_proxy_get_export_features
            case "_get_export_option_warning":
                return _EditorExportPlugin_proxy_get_export_option_warning
            case "_get_export_options":
                return _EditorExportPlugin_proxy_get_export_options
            case "_get_export_options_overrides":
                return _EditorExportPlugin_proxy_get_export_options_overrides
            case "_get_name":
                return _EditorExportPlugin_proxy_get_name
            case "_should_update_export_options":
                return _EditorExportPlugin_proxy_should_update_export_options
            case "_supports_platform":
                return _EditorExportPlugin_proxy_supports_platform
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _EditorExportPlugin_proxy_begin_customize_resources (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._beginCustomizeResources (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), features: PackedStringArray (content: args [1]!.assumingMemoryBound (to: (Int64, Int64).self).pointee))
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _EditorExportPlugin_proxy_begin_customize_scenes (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._beginCustomizeScenes (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), features: PackedStringArray (content: args [1]!.assumingMemoryBound (to: (Int64, Int64).self).pointee))
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _EditorExportPlugin_proxy_customize_resource (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._customizeResource (lookupLiveObject (handleAddress: resolved_0) as? Resource ?? Resource (nativeHandle: resolved_0), path: GString.stringFromGStringPtr (ptr: args [1]!) ?? "")
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Resource
}

func _EditorExportPlugin_proxy_customize_scene (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._customizeScene (lookupLiveObject (handleAddress: resolved_0) as? Node ?? Node (nativeHandle: resolved_0), path: GString.stringFromGStringPtr (ptr: args [1]!) ?? "")
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Node
}

func _EditorExportPlugin_proxy_end_customize_resources (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._endCustomizeResources ()
}

func _EditorExportPlugin_proxy_end_customize_scenes (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._endCustomizeScenes ()
}

func _EditorExportPlugin_proxy_export_begin (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._exportBegin (features: PackedStringArray (content: args [0]!.assumingMemoryBound (to: (Int64, Int64).self).pointee), isDebug: args [1]!.assumingMemoryBound (to: Bool.self).pointee, path: GString.stringFromGStringPtr (ptr: args [2]!) ?? "", flags: args [3]!.assumingMemoryBound (to: UInt32.self).pointee)
}

func _EditorExportPlugin_proxy_export_end (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._exportEnd ()
}

func _EditorExportPlugin_proxy_export_file (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._exportFile (path: GString.stringFromGStringPtr (ptr: args [0]!) ?? "", type: GString.stringFromGStringPtr (ptr: args [1]!) ?? "", features: PackedStringArray (content: args [2]!.assumingMemoryBound (to: (Int64, Int64).self).pointee))
}

func _EditorExportPlugin_proxy_get_android_dependencies (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getAndroidDependencies (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _EditorExportPlugin_proxy_get_android_dependencies_maven_repos (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getAndroidDependenciesMavenRepos (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _EditorExportPlugin_proxy_get_android_libraries (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getAndroidLibraries (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _EditorExportPlugin_proxy_get_android_manifest_activity_element_contents (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = GString (swiftObject._getAndroidManifestActivityElementContents (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorExportPlugin_proxy_get_android_manifest_application_element_contents (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = GString (swiftObject._getAndroidManifestApplicationElementContents (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorExportPlugin_proxy_get_android_manifest_element_contents (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = GString (swiftObject._getAndroidManifestElementContents (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorExportPlugin_proxy_get_customization_configuration_hash (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getCustomizationConfigurationHash ()
    retPtr!.storeBytes (of: ret, as: UInt.self)
}

func _EditorExportPlugin_proxy_get_export_features (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getExportFeatures (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), debug: args [1]!.assumingMemoryBound (to: Bool.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _EditorExportPlugin_proxy_get_export_option_warning (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = GString (swiftObject._getExportOptionWarning (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0), option: GString.stringFromGStringPtr (ptr: args [1]!) ?? ""))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorExportPlugin_proxy_get_export_options (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getExportOptions (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret.array.content, as: type (of: ret.array.content)) // typedarray::Dictionary
}

func _EditorExportPlugin_proxy_get_export_options_overrides (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._getExportOptionsOverrides (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // Dictionary
    ret.content = GDictionary.zero
}

func _EditorExportPlugin_proxy_get_name (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let ret = GString (swiftObject._getName ())
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _EditorExportPlugin_proxy_should_update_export_options (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._shouldUpdateExportOptions (platform: lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _EditorExportPlugin_proxy_supports_platform (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorExportPlugin>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._supportsPlatform (lookupLiveObject (handleAddress: resolved_0) as? EditorExportPlatform ?? EditorExportPlatform (nativeHandle: resolved_0))
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

