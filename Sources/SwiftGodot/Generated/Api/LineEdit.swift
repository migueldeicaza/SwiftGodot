// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// An input field for single-line text.
/// 
/// ``LineEdit`` provides an input field for editing a single line of text. It features many built-in shortcuts that are always available ([kbd]Ctrl[/kbd] here maps to [kbd]Cmd[/kbd] on macOS):
/// 
/// - [kbd]Ctrl + C[/kbd]: Copy
/// 
/// - [kbd]Ctrl + X[/kbd]: Cut
/// 
/// - [kbd]Ctrl + V[/kbd] or [kbd]Ctrl + Y[/kbd]: Paste/"yank"
/// 
/// - [kbd]Ctrl + Z[/kbd]: Undo
/// 
/// - [kbd]Ctrl + ~[/kbd]: Swap input direction.
/// 
/// - [kbd]Ctrl + Shift + Z[/kbd]: Redo
/// 
/// - [kbd]Ctrl + U[/kbd]: Delete text from the caret position to the beginning of the line
/// 
/// - [kbd]Ctrl + K[/kbd]: Delete text from the caret position to the end of the line
/// 
/// - [kbd]Ctrl + A[/kbd]: Select all text
/// 
/// - [kbd]Up Arrow[/kbd]/[kbd]Down Arrow[/kbd]: Move the caret to the beginning/end of the line
/// 
/// On macOS, some extra keyboard shortcuts are available:
/// 
/// - [kbd]Cmd + F[/kbd]: Same as [kbd]Right Arrow[/kbd], move the caret one character right
/// 
/// - [kbd]Cmd + B[/kbd]: Same as [kbd]Left Arrow[/kbd], move the caret one character left
/// 
/// - [kbd]Cmd + P[/kbd]: Same as [kbd]Up Arrow[/kbd], move the caret to the previous line
/// 
/// - [kbd]Cmd + N[/kbd]: Same as [kbd]Down Arrow[/kbd], move the caret to the next line
/// 
/// - [kbd]Cmd + D[/kbd]: Same as [kbd]Delete[/kbd], delete the character on the right side of caret
/// 
/// - [kbd]Cmd + H[/kbd]: Same as [kbd]Backspace[/kbd], delete the character on the left side of the caret
/// 
/// - [kbd]Cmd + A[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
/// 
/// - [kbd]Cmd + E[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
/// 
/// - [kbd]Cmd + Left Arrow[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
/// 
/// - [kbd]Cmd + Right Arrow[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``textChanged``
/// - ``textChangeRejected``
/// - ``textSubmitted``
open class LineEdit: Control {
    override open class var godotClassName: StringName { "LineEdit" }
    public enum MenuItems: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Cuts (copies and clears) the selected text.
        case cut = 0 // MENU_CUT
        /// Copies the selected text.
        case copy = 1 // MENU_COPY
        /// Pastes the clipboard text over the selected text (or at the caret's position).
        /// 
        /// Non-printable escape characters are automatically stripped from the OS clipboard via ``GString/stripEscapes()``.
        /// 
        case paste = 2 // MENU_PASTE
        /// Erases the whole ``LineEdit`` text.
        case clear = 3 // MENU_CLEAR
        /// Selects the whole ``LineEdit`` text.
        case selectAll = 4 // MENU_SELECT_ALL
        /// Undoes the previous action.
        case undo = 5 // MENU_UNDO
        /// Reverse the last undo action.
        case redo = 6 // MENU_REDO
        /// ID of "Text Writing Direction" submenu.
        case submenuTextDir = 7 // MENU_SUBMENU_TEXT_DIR
        /// Sets text direction to inherited.
        case dirInherited = 8 // MENU_DIR_INHERITED
        /// Sets text direction to automatic.
        case dirAuto = 9 // MENU_DIR_AUTO
        /// Sets text direction to left-to-right.
        case dirLtr = 10 // MENU_DIR_LTR
        /// Sets text direction to right-to-left.
        case dirRtl = 11 // MENU_DIR_RTL
        /// Toggles control character display.
        case displayUcc = 12 // MENU_DISPLAY_UCC
        /// ID of "Insert Control Character" submenu.
        case submenuInsertUcc = 13 // MENU_SUBMENU_INSERT_UCC
        /// Inserts left-to-right mark (LRM) character.
        case insertLrm = 14 // MENU_INSERT_LRM
        /// Inserts right-to-left mark (RLM) character.
        case insertRlm = 15 // MENU_INSERT_RLM
        /// Inserts start of left-to-right embedding (LRE) character.
        case insertLre = 16 // MENU_INSERT_LRE
        /// Inserts start of right-to-left embedding (RLE) character.
        case insertRle = 17 // MENU_INSERT_RLE
        /// Inserts start of left-to-right override (LRO) character.
        case insertLro = 18 // MENU_INSERT_LRO
        /// Inserts start of right-to-left override (RLO) character.
        case insertRlo = 19 // MENU_INSERT_RLO
        /// Inserts pop direction formatting (PDF) character.
        case insertPdf = 20 // MENU_INSERT_PDF
        /// Inserts Arabic letter mark (ALM) character.
        case insertAlm = 21 // MENU_INSERT_ALM
        /// Inserts left-to-right isolate (LRI) character.
        case insertLri = 22 // MENU_INSERT_LRI
        /// Inserts right-to-left isolate (RLI) character.
        case insertRli = 23 // MENU_INSERT_RLI
        /// Inserts first strong isolate (FSI) character.
        case insertFsi = 24 // MENU_INSERT_FSI
        /// Inserts pop direction isolate (PDI) character.
        case insertPdi = 25 // MENU_INSERT_PDI
        /// Inserts zero width joiner (ZWJ) character.
        case insertZwj = 26 // MENU_INSERT_ZWJ
        /// Inserts zero width non-joiner (ZWNJ) character.
        case insertZwnj = 27 // MENU_INSERT_ZWNJ
        /// Inserts word joiner (WJ) character.
        case insertWj = 28 // MENU_INSERT_WJ
        /// Inserts soft hyphen (SHY) character.
        case insertShy = 29 // MENU_INSERT_SHY
        /// Represents the size of the ``LineEdit/MenuItems`` enum.
        case max = 30 // MENU_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .cut: return ".cut"
                case .copy: return ".copy"
                case .paste: return ".paste"
                case .clear: return ".clear"
                case .selectAll: return ".selectAll"
                case .undo: return ".undo"
                case .redo: return ".redo"
                case .submenuTextDir: return ".submenuTextDir"
                case .dirInherited: return ".dirInherited"
                case .dirAuto: return ".dirAuto"
                case .dirLtr: return ".dirLtr"
                case .dirRtl: return ".dirRtl"
                case .displayUcc: return ".displayUcc"
                case .submenuInsertUcc: return ".submenuInsertUcc"
                case .insertLrm: return ".insertLrm"
                case .insertRlm: return ".insertRlm"
                case .insertLre: return ".insertLre"
                case .insertRle: return ".insertRle"
                case .insertLro: return ".insertLro"
                case .insertRlo: return ".insertRlo"
                case .insertPdf: return ".insertPdf"
                case .insertAlm: return ".insertAlm"
                case .insertLri: return ".insertLri"
                case .insertRli: return ".insertRli"
                case .insertFsi: return ".insertFsi"
                case .insertPdi: return ".insertPdi"
                case .insertZwj: return ".insertZwj"
                case .insertZwnj: return ".insertZwnj"
                case .insertWj: return ".insertWj"
                case .insertShy: return ".insertShy"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum VirtualKeyboardType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Default text virtual keyboard.
        case `default` = 0 // KEYBOARD_TYPE_DEFAULT
        /// Multiline virtual keyboard.
        case multiline = 1 // KEYBOARD_TYPE_MULTILINE
        /// Virtual number keypad, useful for PIN entry.
        case number = 2 // KEYBOARD_TYPE_NUMBER
        /// Virtual number keypad, useful for entering fractional numbers.
        case numberDecimal = 3 // KEYBOARD_TYPE_NUMBER_DECIMAL
        /// Virtual phone number keypad.
        case phone = 4 // KEYBOARD_TYPE_PHONE
        /// Virtual keyboard with additional keys to assist with typing email addresses.
        case emailAddress = 5 // KEYBOARD_TYPE_EMAIL_ADDRESS
        /// Virtual keyboard for entering a password. On most platforms, this should disable autocomplete and autocapitalization.
        /// 
        /// > Note: This is not supported on Web. Instead, this behaves identically to ``VirtualKeyboardType/`default```.
        /// 
        case password = 6 // KEYBOARD_TYPE_PASSWORD
        /// Virtual keyboard with additional keys to assist with typing URLs.
        case url = 7 // KEYBOARD_TYPE_URL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .multiline: return ".multiline"
                case .number: return ".number"
                case .numberDecimal: return ".numberDecimal"
                case .phone: return ".phone"
                case .emailAddress: return ".emailAddress"
                case .password: return ".password"
                case .url: return ".url"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// String value of the ``LineEdit``.
    /// 
    /// > Note: Changing text using this property won't emit the [signal text_changed] signal.
    /// 
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// Text shown when the ``LineEdit`` is empty. It is **not** the ``LineEdit``'s default value (see ``text``).
    final public var placeholderText: String {
        get {
            return get_placeholder ()
        }
        
        set {
            set_placeholder (newValue)
        }
        
    }
    
    /// Text alignment as defined in the ``HorizontalAlignment`` enum.
    final public var alignment: HorizontalAlignment {
        get {
            return get_horizontal_alignment ()
        }
        
        set {
            set_horizontal_alignment (newValue)
        }
        
    }
    
    /// Maximum number of characters that can be entered inside the ``LineEdit``. If `0`, there is no limit.
    /// 
    /// When a limit is defined, characters that would exceed ``maxLength`` are truncated. This happens both for existing ``text`` contents when setting the max length, or for new text inserted in the ``LineEdit``, including pasting. If any input text is truncated, the [signal text_change_rejected] signal is emitted with the truncated substring as parameter.
    /// 
    /// **Example:**
    /// 
    final public var maxLength: Int32 {
        get {
            return get_max_length ()
        }
        
        set {
            set_max_length (newValue)
        }
        
    }
    
    /// If `false`, existing text cannot be modified and new text cannot be added.
    final public var editable: Bool {
        get {
            return is_editable ()
        }
        
        set {
            set_editable (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` width will increase to stay longer than the ``text``. It will **not** compress if the ``text`` is shortened.
    final public var expandToTextLength: Bool {
        get {
            return is_expand_to_text_length_enabled ()
        }
        
        set {
            set_expand_to_text_length_enabled (newValue)
        }
        
    }
    
    /// If `true`, the context menu will appear when right-clicked.
    final public var contextMenuEnabled: Bool {
        get {
            return is_context_menu_enabled ()
        }
        
        set {
            set_context_menu_enabled (newValue)
        }
        
    }
    
    /// If `true`, the native virtual keyboard is shown when focused on platforms that support it.
    final public var virtualKeyboardEnabled: Bool {
        get {
            return is_virtual_keyboard_enabled ()
        }
        
        set {
            set_virtual_keyboard_enabled (newValue)
        }
        
    }
    
    /// Specifies the type of virtual keyboard to show.
    final public var virtualKeyboardType: LineEdit.VirtualKeyboardType {
        get {
            return get_virtual_keyboard_type ()
        }
        
        set {
            set_virtual_keyboard_type (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will show a clear button if ``text`` is not empty, which can be used to clear the text quickly.
    final public var clearButtonEnabled: Bool {
        get {
            return is_clear_button_enabled ()
        }
        
        set {
            set_clear_button_enabled (newValue)
        }
        
    }
    
    /// If `false`, using shortcuts will be disabled.
    final public var shortcutKeysEnabled: Bool {
        get {
            return is_shortcut_keys_enabled ()
        }
        
        set {
            set_shortcut_keys_enabled (newValue)
        }
        
    }
    
    /// If `false`, using middle mouse button to paste clipboard will be disabled.
    /// 
    /// > Note: This method is only implemented on Linux.
    /// 
    final public var middleMousePasteEnabled: Bool {
        get {
            return is_middle_mouse_paste_enabled ()
        }
        
        set {
            set_middle_mouse_paste_enabled (newValue)
        }
        
    }
    
    /// If `false`, it's impossible to select the text using mouse nor keyboard.
    final public var selectingEnabled: Bool {
        get {
            return is_selecting_enabled ()
        }
        
        set {
            set_selecting_enabled (newValue)
        }
        
    }
    
    /// If `true`, the selected text will be deselected when focus is lost.
    final public var deselectOnFocusLossEnabled: Bool {
        get {
            return is_deselect_on_focus_loss_enabled ()
        }
        
        set {
            set_deselect_on_focus_loss_enabled (newValue)
        }
        
    }
    
    /// If `true`, allow drag and drop of selected text.
    final public var dragAndDropSelectionEnabled: Bool {
        get {
            return is_drag_and_drop_selection_enabled ()
        }
        
        set {
            set_drag_and_drop_selection_enabled (newValue)
        }
        
    }
    
    /// Sets the icon that will appear in the right end of the ``LineEdit`` if there's no ``text``, or always, if ``clearButtonEnabled`` is set to `false`.
    final public var rightIcon: Texture2D? {
        get {
            return get_right_icon ()
        }
        
        set {
            set_right_icon (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` doesn't display decoration.
    final public var flat: Bool {
        get {
            return is_flat ()
        }
        
        set {
            set_flat (newValue)
        }
        
    }
    
    /// If `true`, control characters are displayed.
    final public var drawControlChars: Bool {
        get {
            return get_draw_control_chars ()
        }
        
        set {
            set_draw_control_chars (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will select the whole text when it gains focus.
    final public var selectAllOnFocus: Bool {
        get {
            return is_select_all_on_focus ()
        }
        
        set {
            set_select_all_on_focus (newValue)
        }
        
    }
    
    /// If `true`, makes the caret blink.
    final public var caretBlink: Bool {
        get {
            return is_caret_blink_enabled ()
        }
        
        set {
            set_caret_blink_enabled (newValue)
        }
        
    }
    
    /// The interval at which the caret blinks (in seconds).
    final public var caretBlinkInterval: Double {
        get {
            return get_caret_blink_interval ()
        }
        
        set {
            set_caret_blink_interval (newValue)
        }
        
    }
    
    /// The caret's column position inside the ``LineEdit``. When set, the text may scroll to accommodate it.
    final public var caretColumn: Int32 {
        get {
            return get_caret_column ()
        }
        
        set {
            set_caret_column (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will always show the caret, even if focus is lost.
    final public var caretForceDisplayed: Bool {
        get {
            return is_caret_force_displayed ()
        }
        
        set {
            set_caret_force_displayed (newValue)
        }
        
    }
    
    /// Allow moving caret, selecting and removing the individual composite character components.
    /// 
    /// > Note: [kbd]Backspace[/kbd] is always removing individual composite character components.
    /// 
    final public var caretMidGrapheme: Bool {
        get {
            return is_caret_mid_grapheme_enabled ()
        }
        
        set {
            set_caret_mid_grapheme_enabled (newValue)
        }
        
    }
    
    /// If `true`, every character is replaced with the secret character (see ``secretCharacter``).
    final public var secret: Bool {
        get {
            return is_secret ()
        }
        
        set {
            set_secret (newValue)
        }
        
    }
    
    /// The character to use to mask secret input. Only a single character can be used as the secret character. If it is longer than one character, only the first one will be used. If it is empty, a space will be used instead.
    final public var secretCharacter: String {
        get {
            return get_secret_character ()
        }
        
        set {
            set_secret_character (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms. If left empty, current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /// Set BiDi algorithm override for the structured text.
    final public var structuredTextBidiOverride: TextServer.StructuredTextParser {
        get {
            return get_structured_text_bidi_override ()
        }
        
        set {
            set_structured_text_bidi_override (newValue)
        }
        
    }
    
    /// Set additional options for BiDi override.
    final public var structuredTextBidiOverrideOptions: GArray {
        get {
            return get_structured_text_bidi_override_options ()
        }
        
        set {
            set_structured_text_bidi_override_options (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_horizontal_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_horizontal_alignment")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2312603777)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_horizontal_alignment(_ alignment: HorizontalAlignment) {
        withUnsafePointer(to: alignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_horizontal_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_horizontal_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_horizontal_alignment")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 341400642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_horizontal_alignment() -> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(LineEdit.method_get_horizontal_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return HorizontalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Erases the ``LineEdit``'s ``text``.
    public final func clear() {
        gi.object_method_bind_ptrcall(LineEdit.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_select: GDExtensionMethodBindPtr = {
        let methodName = StringName("select")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1328111411)!
            }
            
        }
        
    }()
    
    /// Selects characters inside ``LineEdit`` between `from` and `to`. By default, `from` is at the beginning and `to` at the end.
    /// 
    public final func select(from: Int32 = 0, to: Int32 = -1) {
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(LineEdit.method_select, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_select_all: GDExtensionMethodBindPtr = {
        let methodName = StringName("select_all")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Selects the whole ``String``.
    public final func selectAll() {
        gi.object_method_bind_ptrcall(LineEdit.method_select_all, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_deselect: GDExtensionMethodBindPtr = {
        let methodName = StringName("deselect")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the current selection.
    public final func deselect() {
        gi.object_method_bind_ptrcall(LineEdit.method_deselect, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_has_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_selection")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the user has selected text.
    public final func hasSelection() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_has_selection, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selected_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selected_text")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2841200299)!
            }
            
        }
        
    }()
    
    /// Returns the text inside the selection.
    public final func getSelectedText() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_selected_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_selection_from_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selection_from_column")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the selection begin column.
    public final func getSelectionFromColumn() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(LineEdit.method_get_selection_from_column, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_to_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selection_to_column")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the selection end column.
    public final func getSelectionToColumn() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(LineEdit.method_get_selection_to_column, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text(_ text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_draw_control_chars")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_draw_control_chars() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_get_draw_control_chars, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_control_chars")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_control_chars(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_draw_control_chars, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text_direction")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction(_ direction: Control.TextDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_text_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_direction")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction() -> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(LineEdit.method_get_text_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_language")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language(_ language: String) {
        let language = GString(language)
        withUnsafePointer(to: language.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_language")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_language, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_structured_text_bidi_override")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 55961453)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override(_ parser: TextServer.StructuredTextParser) {
        withUnsafePointer(to: parser.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_structured_text_bidi_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_structured_text_bidi_override")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3385126229)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override() -> TextServer.StructuredTextParser {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(LineEdit.method_get_structured_text_bidi_override, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.StructuredTextParser (rawValue: _result)!
    }
    
    fileprivate static var method_set_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_structured_text_bidi_override_options")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override_options(_ args: GArray) {
        withUnsafePointer(to: args.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_structured_text_bidi_override_options")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override_options() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_structured_text_bidi_override_options, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_placeholder")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_placeholder(_ text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_placeholder, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_placeholder")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_placeholder() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_placeholder, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_caret_column")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_column(_ position: Int32) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_caret_column, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_caret_column")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_column() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(LineEdit.method_get_caret_column, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scroll_offset")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the scroll offset due to ``caretColumn``, as a number of characters.
    public final func getScrollOffset() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(LineEdit.method_get_scroll_offset, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_expand_to_text_length_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_expand_to_text_length_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_expand_to_text_length_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_expand_to_text_length_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_expand_to_text_length_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_expand_to_text_length_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_expand_to_text_length_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_expand_to_text_length_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_caret_blink_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_caret_blink_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_caret_blink_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_blink_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_caret_blink_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_caret_mid_grapheme_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_mid_grapheme_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_caret_mid_grapheme_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_caret_mid_grapheme_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_mid_grapheme_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_caret_mid_grapheme_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_force_displayed: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_caret_force_displayed")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_force_displayed(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_caret_force_displayed, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_caret_force_displayed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_caret_force_displayed")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_force_displayed() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_caret_force_displayed, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_caret_blink_interval")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_interval(_ interval: Double) {
        withUnsafePointer(to: interval) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_caret_blink_interval, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_caret_blink_interval")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_blink_interval() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(LineEdit.method_get_caret_blink_interval, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_max_length")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_length(_ chars: Int32) {
        withUnsafePointer(to: chars) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_max_length, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_max_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_max_length")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_length() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(LineEdit.method_get_max_length, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_insert_text_at_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName("insert_text_at_caret")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Inserts `text` at the caret. If the resulting value is longer than ``maxLength``, nothing happens.
    public final func insertTextAtCaret(text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_insert_text_at_caret, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_delete_char_at_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName("delete_char_at_caret")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Deletes one character at the caret's current position (equivalent to pressing [kbd]Delete[/kbd]).
    public final func deleteCharAtCaret() {
        gi.object_method_bind_ptrcall(LineEdit.method_delete_char_at_caret, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_delete_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("delete_text")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Deletes a section of the ``text`` going from position `fromColumn` to `toColumn`. Both parameters should be within the text's length.
    public final func deleteText(fromColumn: Int32, toColumn: Int32) {
        withUnsafePointer(to: fromColumn) { pArg0 in
            withUnsafePointer(to: toColumn) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(LineEdit.method_delete_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_editable")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_editable(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_editable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_editable")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_editable() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_editable, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_secret: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_secret")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_secret(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_secret, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_secret: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_secret")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_secret() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_secret, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_secret_character: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_secret_character")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_secret_character(_ character: String) {
        let character = GString(character)
        withUnsafePointer(to: character.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_secret_character, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_secret_character: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_secret_character")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_secret_character() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(LineEdit.method_get_secret_character, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_menu_option: GDExtensionMethodBindPtr = {
        let methodName = StringName("menu_option")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Executes a given action as defined in the ``LineEdit/MenuItems`` enum.
    public final func menuOption(_ option: Int32) {
        withUnsafePointer(to: option) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_menu_option, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_menu")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` of this ``LineEdit``. By default, this menu is displayed when right-clicking on the ``LineEdit``.
    /// 
    /// You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see ``LineEdit/MenuItems``). For example:
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getMenu() -> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(LineEdit.method_get_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_menu_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_menu_visible")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
    public final func isMenuVisible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_menu_visible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_context_menu_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_context_menu_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_context_menu_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_context_menu_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_context_menu_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_context_menu_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_virtual_keyboard_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_virtual_keyboard_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_virtual_keyboard_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_virtual_keyboard_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_virtual_keyboard_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_virtual_keyboard_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_virtual_keyboard_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_virtual_keyboard_type")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2696893573)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_virtual_keyboard_type(_ type: LineEdit.VirtualKeyboardType) {
        withUnsafePointer(to: type.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_virtual_keyboard_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_virtual_keyboard_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_virtual_keyboard_type")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1928699316)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_virtual_keyboard_type() -> LineEdit.VirtualKeyboardType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(LineEdit.method_get_virtual_keyboard_type, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return LineEdit.VirtualKeyboardType (rawValue: _result)!
    }
    
    fileprivate static var method_set_clear_button_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clear_button_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clear_button_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_clear_button_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_clear_button_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_clear_button_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_clear_button_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_clear_button_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_shortcut_keys_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_keys_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_shortcut_keys_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_shortcut_keys_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_shortcut_keys_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_middle_mouse_paste_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_middle_mouse_paste_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_middle_mouse_paste_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_middle_mouse_paste_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_middle_mouse_paste_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_middle_mouse_paste_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_selecting_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_selecting_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_selecting_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_selecting_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_selecting_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_selecting_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_deselect_on_focus_loss_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deselect_on_focus_loss_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_deselect_on_focus_loss_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deselect_on_focus_loss_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_drag_and_drop_selection_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_and_drop_selection_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drag_and_drop_selection_enabled")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drag_and_drop_selection_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_drag_and_drop_selection_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_right_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_right_icon")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_right_icon(_ icon: Texture2D?) {
        withUnsafePointer(to: icon?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_right_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_right_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_right_icon")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 255860311)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_right_icon() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(LineEdit.method_get_right_icon, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_flat")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flat(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_flat, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_flat")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flat() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_flat, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_select_all_on_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_select_all_on_focus")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_select_all_on_focus(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(LineEdit.method_set_select_all_on_focus, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_select_all_on_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_select_all_on_focus")
        return withUnsafePointer(to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_select_all_on_focus() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(LineEdit.method_is_select_all_on_focus, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ newText: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0]!)!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the text changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textChanged.connect { newText in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textChanged: Signal1 { Signal1 (target: self, signalName: "text_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ rejectedSubstring: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0]!)!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when appending text that overflows the ``maxLength``. The appended text is truncated to fit ``maxLength``, and the part that couldn't fit is passed as the `rejectedSubstring` argument.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textChangeRejected.connect { rejectedSubstring in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textChangeRejected: Signal2 { Signal2 (target: self, signalName: "text_change_rejected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ newText: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0]!)!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user presses ``Key/enter`` on the ``LineEdit``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textSubmitted.connect { newText in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textSubmitted: Signal3 { Signal3 (target: self, signalName: "text_submitted") }
    
}

