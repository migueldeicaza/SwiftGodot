// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for all windows, dialogs, and popups.
/// 
/// A node that creates a window. The window can either be a native system window or embedded inside another ``Window`` (see ``Viewport/guiEmbedSubwindows``).
/// 
/// At runtime, ``Window``s will not close automatically when requested. You need to handle it manually using the [signal close_requested] signal (this applies both to pressing the close button and clicking outside of a popup).
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``windowInput``
/// - ``filesDropped``
/// - ``mouseEntered``
/// - ``mouseExited``
/// - ``focusEntered``
/// - ``focusExited``
/// - ``closeRequested``
/// - ``goBackRequested``
/// - ``visibilityChanged``
/// - ``aboutToPopup``
/// - ``themeChanged``
/// - ``dpiChanged``
/// - ``titlebarChanged``
open class Window: Viewport {
    override open class var godotClassName: StringName { "Window" }
    public enum Mode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Windowed mode, i.e. ``Window`` doesn't occupy the whole screen (unless set to the size of the screen).
        case windowed = 0 // MODE_WINDOWED
        /// Minimized window mode, i.e. ``Window`` is not visible and available on window manager's window list. Normally happens when the minimize button is pressed.
        case minimized = 1 // MODE_MINIMIZED
        /// Maximized window mode, i.e. ``Window`` will occupy whole screen area except task bar and still display its borders. Normally happens when the maximize button is pressed.
        case maximized = 2 // MODE_MAXIMIZED
        /// Full screen mode with full multi-window support.
        /// 
        /// Full screen window covers the entire display area of a screen and has no decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Multi-window full-screen mode has a 1px border of the ``ProjectSettings/rendering/environment/defaults/defaultClearColor`` color.
        /// 
        /// **On macOS:** A new desktop is used to display the running project.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports <a href="https://docs.godotengine.org/en//tutorials/rendering/multiple_resolutions.html">multiple resolutions</a> when enabling full screen mode.
        /// 
        case fullscreen = 3 // MODE_FULLSCREEN
        /// A single window full screen mode. This mode has less overhead, but only one window can be open on a given screen at a time (opening a child window or application switching will trigger a full screen transition).
        /// 
        /// Full screen window covers the entire display area of a screen and has no border or decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Depending on video driver, full screen transition might cause screens to go black for a moment.
        /// 
        /// **On macOS:** A new desktop is used to display the running project. Exclusive full screen mode prevents Dock and Menu from showing up when the mouse pointer is hovering the edge of the screen.
        /// 
        /// **On Linux (X11):** Exclusive full screen mode bypasses compositor.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports <a href="https://docs.godotengine.org/en//tutorials/rendering/multiple_resolutions.html">multiple resolutions</a> when enabling full screen mode.
        /// 
        case exclusiveFullscreen = 4 // MODE_EXCLUSIVE_FULLSCREEN
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .windowed: return ".windowed"
                case .minimized: return ".minimized"
                case .maximized: return ".maximized"
                case .fullscreen: return ".fullscreen"
                case .exclusiveFullscreen: return ".exclusiveFullscreen"
            }
            
        }
        
    }
    
    public enum Flags: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The window can't be resized by dragging its resize grip. It's still possible to resize the window using ``size``. This flag is ignored for full screen windows. Set with ``unresizable``.
        case resizeDisabled = 0 // FLAG_RESIZE_DISABLED
        /// The window do not have native title bar and other decorations. This flag is ignored for full-screen windows. Set with ``borderless``.
        case borderless = 1 // FLAG_BORDERLESS
        /// The window is floating on top of all other windows. This flag is ignored for full-screen windows. Set with ``alwaysOnTop``.
        case alwaysOnTop = 2 // FLAG_ALWAYS_ON_TOP
        /// The window background can be transparent. Set with ``transparent``.
        /// 
        /// > Note: This flag has no effect if either ``ProjectSettings/display/window/perPixelTransparency/allowed``, or the window's ``Viewport/transparentBg`` is set to `false`.
        /// 
        case transparent = 3 // FLAG_TRANSPARENT
        /// The window can't be focused. No-focus window will ignore all input, except mouse clicks. Set with ``unfocusable``.
        case noFocus = 4 // FLAG_NO_FOCUS
        /// Window is part of menu or ``OptionButton`` dropdown. This flag can't be changed when the window is visible. An active popup window will exclusively receive all input, without stealing focus from its parent. Popup windows are automatically closed when uses click outside it, or when an application is switched. Popup window must have transient parent set (see ``transient``).
        /// 
        /// > Note: This flag has no effect in embedded windows (unless said window is a ``Popup``).
        /// 
        case popup = 5 // FLAG_POPUP
        /// Window content is expanded to the full size of the window. Unlike borderless window, the frame is left intact and can be used to resize the window, title bar is transparent, but have minimize/maximize/close buttons. Set with ``extendToTitle``.
        /// 
        /// > Note: This flag is implemented only on macOS.
        /// 
        /// > Note: This flag has no effect in embedded windows.
        /// 
        case extendToTitle = 6 // FLAG_EXTEND_TO_TITLE
        /// All mouse events are passed to the underlying window of the same application.
        /// 
        /// > Note: This flag has no effect in embedded windows.
        /// 
        case mousePassthrough = 7 // FLAG_MOUSE_PASSTHROUGH
        /// Max value of the ``Window/Flags``.
        case max = 8 // FLAG_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .resizeDisabled: return ".resizeDisabled"
                case .borderless: return ".borderless"
                case .alwaysOnTop: return ".alwaysOnTop"
                case .transparent: return ".transparent"
                case .noFocus: return ".noFocus"
                case .popup: return ".popup"
                case .extendToTitle: return ".extendToTitle"
                case .mousePassthrough: return ".mousePassthrough"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum ContentScaleMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The content will not be scaled to match the ``Window``'s size.
        case disabled = 0 // CONTENT_SCALE_MODE_DISABLED
        /// The content will be rendered at the target size. This is more performance-expensive than ``ContentScaleMode/viewport``, but provides better results.
        case canvasItems = 1 // CONTENT_SCALE_MODE_CANVAS_ITEMS
        /// The content will be rendered at the base size and then scaled to the target size. More performant than ``ContentScaleMode/canvasItems``, but results in pixelated image.
        case viewport = 2 // CONTENT_SCALE_MODE_VIEWPORT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .canvasItems: return ".canvasItems"
                case .viewport: return ".viewport"
            }
            
        }
        
    }
    
    public enum ContentScaleAspect: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The aspect will be ignored. Scaling will simply stretch the content to fit the target size.
        case ignore = 0 // CONTENT_SCALE_ASPECT_IGNORE
        /// The content's aspect will be preserved. If the target size has different aspect from the base one, the image will be centered and black bars will appear on left and right sides.
        case keep = 1 // CONTENT_SCALE_ASPECT_KEEP
        /// The content can be expanded vertically. Scaling horizontally will result in keeping the width ratio and then black bars on left and right sides.
        case keepWidth = 2 // CONTENT_SCALE_ASPECT_KEEP_WIDTH
        /// The content can be expanded horizontally. Scaling vertically will result in keeping the height ratio and then black bars on top and bottom sides.
        case keepHeight = 3 // CONTENT_SCALE_ASPECT_KEEP_HEIGHT
        /// The content's aspect will be preserved. If the target size has different aspect from the base one, the content will stay in the top-left corner and add an extra visible area in the stretched space.
        case expand = 4 // CONTENT_SCALE_ASPECT_EXPAND
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .ignore: return ".ignore"
                case .keep: return ".keep"
                case .keepWidth: return ".keepWidth"
                case .keepHeight: return ".keepHeight"
                case .expand: return ".expand"
            }
            
        }
        
    }
    
    public enum ContentScaleStretch: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The content will be stretched according to a fractional factor. This fills all the space available in the window, but allows "pixel wobble" to occur due to uneven pixel scaling.
        case fractional = 0 // CONTENT_SCALE_STRETCH_FRACTIONAL
        /// The content will be stretched only according to an integer factor, preserving sharp pixels. This may leave a black background visible on the window's edges depending on the window size.
        case integer = 1 // CONTENT_SCALE_STRETCH_INTEGER
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .fractional: return ".fractional"
                case .integer: return ".integer"
            }
            
        }
        
    }
    
    public enum LayoutDirection: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Automatic layout direction, determined from the parent window layout direction.
        case inherited = 0 // LAYOUT_DIRECTION_INHERITED
        /// Automatic layout direction, determined from the current locale.
        case locale = 1 // LAYOUT_DIRECTION_LOCALE
        /// Left-to-right layout direction.
        case ltr = 2 // LAYOUT_DIRECTION_LTR
        /// Right-to-left layout direction.
        case rtl = 3 // LAYOUT_DIRECTION_RTL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .inherited: return ".inherited"
                case .locale: return ".locale"
                case .ltr: return ".ltr"
                case .rtl: return ".rtl"
            }
            
        }
        
    }
    
    public enum WindowInitialPosition: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Initial window position is determined by ``position``.
        case absolute = 0 // WINDOW_INITIAL_POSITION_ABSOLUTE
        /// Initial window position is the center of the primary screen.
        case centerPrimaryScreen = 1 // WINDOW_INITIAL_POSITION_CENTER_PRIMARY_SCREEN
        /// Initial window position is the center of the main window screen.
        case centerMainWindowScreen = 2 // WINDOW_INITIAL_POSITION_CENTER_MAIN_WINDOW_SCREEN
        /// Initial window position is the center of ``currentScreen`` screen.
        case centerOtherScreen = 3 // WINDOW_INITIAL_POSITION_CENTER_OTHER_SCREEN
        /// Initial window position is the center of the screen containing the mouse pointer.
        case centerScreenWithMouseFocus = 4 // WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_MOUSE_FOCUS
        /// Initial window position is the center of the screen containing the window with the keyboard focus.
        case centerScreenWithKeyboardFocus = 5 // WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_KEYBOARD_FOCUS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .absolute: return ".absolute"
                case .centerPrimaryScreen: return ".centerPrimaryScreen"
                case .centerMainWindowScreen: return ".centerMainWindowScreen"
                case .centerOtherScreen: return ".centerOtherScreen"
                case .centerScreenWithMouseFocus: return ".centerScreenWithMouseFocus"
                case .centerScreenWithKeyboardFocus: return ".centerScreenWithKeyboardFocus"
            }
            
        }
        
    }
    
    /* Constants */
    /// Emitted when ``Window``'s visibility changes, right before [signal visibility_changed].
    public static let notificationVisibilityChanged = 30
    /// Sent when the node needs to refresh its theme items. This happens in one of the following cases:
    /// 
    /// - The ``theme`` property is changed on this node or any of its ancestors.
    /// 
    /// - The ``themeTypeVariation`` property is changed on this node.
    /// 
    /// - The node enters the scene tree.
    /// 
    /// > Note: As an optimization, this notification won't be sent from changes that occur while this node is outside of the scene tree. Instead, all of the theme item updates can be applied at once when the node enters the scene tree.
    /// 
    public static let notificationThemeChanged = 32
    
    /* Properties */
    
    /// Set's the window's current mode.
    /// 
    /// > Note: Fullscreen mode is not exclusive full screen on Windows and Linux.
    /// 
    /// > Note: This method only works with native windows, i.e. the main window and ``Window``-derived nodes when ``Viewport/guiEmbedSubwindows`` is disabled in the main viewport.
    /// 
    final public var mode: Window.Mode {
        get {
            return get_mode ()
        }
        
        set {
            set_mode (newValue)
        }
        
    }
    
    /// The window's title. If the ``Window`` is native, title styles set in ``Theme`` will have no effect.
    final public var title: String {
        get {
            return get_title ()
        }
        
        set {
            set_title (newValue)
        }
        
    }
    
    /// Specifies the initial type of position for the ``Window``. See ``Window/WindowInitialPosition`` constants.
    final public var initialPosition: Window.WindowInitialPosition {
        get {
            return get_initial_position ()
        }
        
        set {
            set_initial_position (newValue)
        }
        
    }
    
    /// The window's position in pixels.
    /// 
    /// If ``ProjectSettings/display/window/subwindows/embedSubwindows`` is `false`, the position is in absolute screen coordinates. This typically applies to editor plugins. If the setting is `true`, the window's position is in the coordinates of its parent ``Viewport``.
    /// 
    /// > Note: This property only works if ``initialPosition`` is set to ``WindowInitialPosition/absolute``.
    /// 
    final public var position: Vector2i {
        get {
            return get_position ()
        }
        
        set {
            set_position (newValue)
        }
        
    }
    
    /// The window's size in pixels.
    final public var size: Vector2i {
        get {
            return get_size ()
        }
        
        set {
            set_size (newValue)
        }
        
    }
    
    /// The screen the window is currently on.
    final public var currentScreen: Int32 {
        get {
            return get_current_screen ()
        }
        
        set {
            set_current_screen (newValue)
        }
        
    }
    
    /// Sets a polygonal region of the window which accepts mouse events. Mouse events outside the region will be passed through.
    /// 
    /// Passing an empty array will disable passthrough support (all mouse events will be intercepted by the window, which is the default behavior).
    /// 
    /// > Note: This property is ignored if ``mousePassthrough`` is set to `true`.
    /// 
    /// > Note: On Windows, the portion of a window that lies outside the region is not drawn, while on Linux (X11) and macOS it is.
    /// 
    /// > Note: This property is implemented on Linux (X11), macOS and Windows.
    /// 
    final public var mousePassthroughPolygon: PackedVector2Array {
        get {
            return get_mouse_passthrough_polygon ()
        }
        
        set {
            set_mouse_passthrough_polygon (newValue)
        }
        
    }
    
    /// If `true`, the window is visible.
    final public var visible: Bool {
        get {
            return is_visible ()
        }
        
        set {
            set_visible (newValue)
        }
        
    }
    
    /// If `true`, the window's size will automatically update when a child node is added or removed, ignoring ``minSize`` if the new size is bigger.
    /// 
    /// If `false`, you need to call ``childControlsChanged()`` manually.
    /// 
    final public var wrapControls: Bool {
        get {
            return is_wrapping_controls ()
        }
        
        set {
            set_wrap_controls (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` is transient, i.e. it's considered a child of another ``Window``. The transient window will be destroyed with its transient parent and will return focus to their parent when closed. The transient window is displayed on top of a non-exclusive full-screen parent window. Transient windows can't enter full-screen mode.
    /// 
    /// Note that behavior might be different depending on the platform.
    /// 
    final public var transient: Bool {
        get {
            return is_transient ()
        }
        
        set {
            set_transient (newValue)
        }
        
    }
    
    /// If `true`, and the ``Window`` is ``transient``, this window will (at the time of becoming visible) become transient to the currently focused window instead of the immediate parent window in the hierarchy. Note that the transient parent is assigned at the time this window becomes visible, so changing it afterwards has no effect until re-shown.
    final public var transientToFocused: Bool {
        get {
            return is_transient_to_focused ()
        }
        
        set {
            set_transient_to_focused (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` will be in exclusive mode. Exclusive windows are always on top of their parent and will block all input going to the parent ``Window``.
    /// 
    /// Needs ``transient`` enabled to work.
    /// 
    final public var exclusive: Bool {
        get {
            return is_exclusive ()
        }
        
        set {
            set_exclusive (newValue)
        }
        
    }
    
    /// If `true`, the window can't be resized. Minimize and maximize buttons are disabled.
    final public var unresizable: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 0)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 0)!, newValue)
        }
        
    }
    
    /// If `true`, the window will have no borders.
    final public var borderless: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 1)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 1)!, newValue)
        }
        
    }
    
    /// If `true`, the window will be on top of all other windows. Does not work if ``transient`` is enabled.
    final public var alwaysOnTop: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 2)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 2)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window``'s background can be transparent. This is best used with embedded windows.
    /// 
    /// > Note: Transparency support is implemented on Linux, macOS and Windows, but availability might vary depending on GPU driver, display manager, and compositor capabilities.
    /// 
    /// > Note: This property has no effect if ``ProjectSettings/display/window/perPixelTransparency/allowed`` is set to `false`.
    /// 
    final public var transparent: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 3)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 3)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` can't be focused nor interacted with. It can still be visible.
    final public var unfocusable: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 4)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 4)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` will be considered a popup. Popups are sub-windows that don't show as separate windows in system's window manager's window list and will send close request when anything is clicked outside of them (unless ``exclusive`` is enabled).
    final public var popupWindow: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 5)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 5)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` contents is expanded to the full size of the window, window title bar is transparent.
    /// 
    /// > Note: This property is implemented only on macOS.
    /// 
    /// > Note: This property only works with native windows.
    /// 
    final public var extendToTitle: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 6)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 6)!, newValue)
        }
        
    }
    
    /// If `true`, all mouse events will be passed to the underlying window of the same application. See also ``mousePassthroughPolygon``.
    /// 
    /// > Note: This property is implemented on Linux (X11), macOS and Windows.
    /// 
    /// > Note: This property only works with native windows.
    /// 
    final public var mousePassthrough: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 7)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 7)!, newValue)
        }
        
    }
    
    /// If `true`, native window will be used regardless of parent viewport and project settings.
    final public var forceNative: Bool {
        get {
            return get_force_native ()
        }
        
        set {
            set_force_native (newValue)
        }
        
    }
    
    /// If non-zero, the ``Window`` can't be resized to be smaller than this size.
    /// 
    /// > Note: This property will be ignored in favor of ``getContentsMinimumSize()`` if ``wrapControls`` is enabled and if its size is bigger.
    /// 
    final public var minSize: Vector2i {
        get {
            return get_min_size ()
        }
        
        set {
            set_min_size (newValue)
        }
        
    }
    
    /// If non-zero, the ``Window`` can't be resized to be bigger than this size.
    /// 
    /// > Note: This property will be ignored if the value is lower than ``minSize``.
    /// 
    final public var maxSize: Vector2i {
        get {
            return get_max_size ()
        }
        
        set {
            set_max_size (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` width is expanded to keep the title bar text fully visible.
    final public var keepTitleVisible: Bool {
        get {
            return get_keep_title_visible ()
        }
        
        set {
            set_keep_title_visible (newValue)
        }
        
    }
    
    /// Base size of the content (i.e. nodes that are drawn inside the window). If non-zero, ``Window``'s content will be scaled when the window is resized to a different size.
    final public var contentScaleSize: Vector2i {
        get {
            return get_content_scale_size ()
        }
        
        set {
            set_content_scale_size (newValue)
        }
        
    }
    
    /// Specifies how the content is scaled when the ``Window`` is resized.
    final public var contentScaleMode: Window.ContentScaleMode {
        get {
            return get_content_scale_mode ()
        }
        
        set {
            set_content_scale_mode (newValue)
        }
        
    }
    
    /// Specifies how the content's aspect behaves when the ``Window`` is resized. The base aspect is determined by ``contentScaleSize``.
    final public var contentScaleAspect: Window.ContentScaleAspect {
        get {
            return get_content_scale_aspect ()
        }
        
        set {
            set_content_scale_aspect (newValue)
        }
        
    }
    
    /// The policy to use to determine the final scale factor for 2D elements. This affects how ``contentScaleFactor`` is applied, in addition to the automatic scale factor determined by ``contentScaleSize``.
    final public var contentScaleStretch: Window.ContentScaleStretch {
        get {
            return get_content_scale_stretch ()
        }
        
        set {
            set_content_scale_stretch (newValue)
        }
        
    }
    
    /// Specifies the base scale of ``Window``'s content when its ``size`` is equal to ``contentScaleSize``.
    final public var contentScaleFactor: Double {
        get {
            return get_content_scale_factor ()
        }
        
        set {
            set_content_scale_factor (newValue)
        }
        
    }
    
    /// Toggles if any text should automatically change to its translated version depending on the current locale.
    final public var autoTranslate: Bool {
        get {
            return is_auto_translating ()
        }
        
        set {
            set_auto_translate (newValue)
        }
        
    }
    
    /// The ``Theme`` resource this node and all its ``Control`` and ``Window`` children use. If a child node has its own ``Theme`` resource set, theme items are merged with child's definitions having higher priority.
    /// 
    /// > Note: ``Window`` styles will have no effect unless the window is embedded.
    /// 
    final public var theme: Theme? {
        get {
            return get_theme ()
        }
        
        set {
            set_theme (newValue)
        }
        
    }
    
    /// The name of a theme type variation used by this ``Window`` to look up its own theme items. See ``Control/themeTypeVariation`` for more details.
    final public var themeTypeVariation: StringName {
        get {
            return get_theme_type_variation ()
        }
        
        set {
            set_theme_type_variation (newValue)
        }
        
    }
    
    /* Methods */
    /// Virtual method to be implemented by the user. Overrides the value returned by ``getContentsMinimumSize()``.
    @_documentation(visibility: public)
    open func _getContentsMinimumSize() -> Vector2 {
        return Vector2 ()
    }
    
    fileprivate static var method_set_title: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_title")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_title(_ title: String) {
        let title = GString(title)
        withUnsafePointer(to: title.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_title, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_title: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_title")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_title() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Window.method_get_title, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_window_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_window_id")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the window.
    public final func getWindowId() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Window.method_get_window_id, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_initial_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_initial_position")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4084468099)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_initial_position(_ initialPosition: Window.WindowInitialPosition) {
        withUnsafePointer(to: initialPosition.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_initial_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_initial_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_initial_position")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4294066647)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_initial_position() -> Window.WindowInitialPosition {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_initial_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.WindowInitialPosition (rawValue: _result)!
    }
    
    fileprivate static var method_set_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_current_screen")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_screen(_ index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_current_screen, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_current_screen")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_screen() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Window.method_get_current_screen, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_position")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_position(_ position: Vector2i) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_position")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_position() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_move_to_center: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_to_center")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Centers a native window on the current screen and an embedded window on its embedder ``Viewport``.
    public final func moveToCenter() {
        gi.object_method_bind_ptrcall(Window.method_move_to_center, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_size(_ size: Vector2i) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_size() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_reset_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("reset_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Resets the size to the minimum size, which is the max of ``minSize`` and (if ``wrapControls`` is enabled) ``getContentsMinimumSize()``. This is equivalent to calling `set_size(Vector2i())` (or any size below the minimum).
    public final func resetSize() {
        gi.object_method_bind_ptrcall(Window.method_reset_size, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_position_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_position_with_decorations")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the window's position including its border.
    /// 
    /// > Note: If ``visible`` is `false`, this method returns the same value as ``position``.
    /// 
    public final func getPositionWithDecorations() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_position_with_decorations, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_size_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_size_with_decorations")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the window's size including its border.
    /// 
    /// > Note: If ``visible`` is `false`, this method returns the same value as ``size``.
    /// 
    public final func getSizeWithDecorations() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_size_with_decorations, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_max_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_size(_ maxSize: Vector2i) {
        withUnsafePointer(to: maxSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_max_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_max_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_size() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_max_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_min_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_min_size(_ minSize: Vector2i) {
        withUnsafePointer(to: minSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_min_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_min_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_min_size() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_min_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_mode")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3095236531)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mode(_ mode: Window.Mode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mode")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2566346114)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mode() -> Window.Mode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.Mode (rawValue: _result)!
    }
    
    fileprivate static var method_set_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_flag")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3426449779)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets a specified window flag.
    fileprivate final func set_flag(_ flag: Window.Flags, _ enabled: Bool) {
        withUnsafePointer(to: flag.rawValue) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_set_flag, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_flag")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3062752289)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns `true` if the `flag` is set.
    fileprivate final func get_flag(_ flag: Window.Flags) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: flag.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_get_flag, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_maximize_allowed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_maximize_allowed")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window can be maximized (the maximize button is enabled).
    public final func isMaximizeAllowed() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_maximize_allowed, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_request_attention: GDExtensionMethodBindPtr = {
        let methodName = StringName("request_attention")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Tells the OS that the ``Window`` needs an attention. This makes the window stand out in some way depending on the system, e.g. it might blink on the task bar.
    public final func requestAttention() {
        gi.object_method_bind_ptrcall(Window.method_request_attention, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_move_to_foreground: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_to_foreground")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Causes the window to grab focus, allowing it to receive user input.
    public final func moveToForeground() {
        gi.object_method_bind_ptrcall(Window.method_move_to_foreground, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visible")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible(_ visible: Bool) {
        withUnsafePointer(to: visible) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_visible, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_visible")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_visible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_visible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_hide: GDExtensionMethodBindPtr = {
        let methodName = StringName("hide")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Hides the window. This is not the same as minimized state. Hidden window can't be interacted with and needs to be made visible with ``show()``.
    public final func hide() {
        gi.object_method_bind_ptrcall(Window.method_hide, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_show: GDExtensionMethodBindPtr = {
        let methodName = StringName("show")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Makes the ``Window`` appear. This enables interactions with the ``Window`` and doesn't change any of its property other than visibility (unlike e.g. ``popup(rect:)``).
    public final func show() {
        gi.object_method_bind_ptrcall(Window.method_show, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_transient: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_transient")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transient(_ transient: Bool) {
        withUnsafePointer(to: transient) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_transient, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_transient: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_transient")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_transient() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_transient, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_transient_to_focused: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_transient_to_focused")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transient_to_focused(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_transient_to_focused, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_transient_to_focused: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_transient_to_focused")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_transient_to_focused() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_transient_to_focused, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_exclusive")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_exclusive(_ exclusive: Bool) {
        withUnsafePointer(to: exclusive) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_exclusive, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_exclusive")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_exclusive() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_exclusive, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_unparent_when_invisible: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_unparent_when_invisible")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `unparent` is `true`, the window is automatically unparented when going invisible.
    /// 
    /// > Note: Make sure to keep a reference to the node, otherwise it will be orphaned. You also need to manually call ``Node/queueFree()`` to free the window if it's not parented.
    /// 
    public final func setUnparentWhenInvisible(unparent: Bool) {
        withUnsafePointer(to: unparent) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_unparent_when_invisible, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_can_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName("can_draw")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the window is being drawn to the screen.
    public final func canDraw() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_can_draw, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_focus")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window is focused.
    public final func hasFocus() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_has_focus, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_grab_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("grab_focus")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Causes the window to grab focus, allowing it to receive user input.
    public final func grabFocus() {
        gi.object_method_bind_ptrcall(Window.method_grab_focus, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_ime_active: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_ime_active")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `active` is `true`, enables system's native IME (Input Method Editor).
    public final func setImeActive(_ active: Bool) {
        withUnsafePointer(to: active) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_ime_active, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_ime_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_ime_position")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    /// Moves IME to the given position.
    public final func setImePosition(_ position: Vector2i) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_ime_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_embedded: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_embedded")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window is currently embedded in another window.
    public final func isEmbedded() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_embedded, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_contents_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_contents_minimum_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the combined minimum size from the child ``Control`` nodes of the window. Use ``childControlsChanged()`` to update it when child nodes have changed.
    /// 
    /// The value returned by this method can be overridden with ``_getContentsMinimumSize()``.
    /// 
    public final func getContentsMinimumSize() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Window.method_get_contents_minimum_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_force_native: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_force_native")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_force_native(_ forceNative: Bool) {
        withUnsafePointer(to: forceNative) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_force_native, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_force_native: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_force_native")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_force_native() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_get_force_native, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_content_scale_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_size(_ size: Vector2i) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_content_scale_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_content_scale_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_scale_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_size() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Window.method_get_content_scale_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_content_scale_mode")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2937716473)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_mode(_ mode: Window.ContentScaleMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_content_scale_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_content_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_scale_mode")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 161585230)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_mode() -> Window.ContentScaleMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_content_scale_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.ContentScaleMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_content_scale_aspect: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_content_scale_aspect")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2370399418)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_aspect(_ aspect: Window.ContentScaleAspect) {
        withUnsafePointer(to: aspect.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_content_scale_aspect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_content_scale_aspect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_scale_aspect")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4158790715)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_aspect() -> Window.ContentScaleAspect {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_content_scale_aspect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.ContentScaleAspect (rawValue: _result)!
    }
    
    fileprivate static var method_set_content_scale_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_content_scale_stretch")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 349355940)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_stretch(_ stretch: Window.ContentScaleStretch) {
        withUnsafePointer(to: stretch.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_content_scale_stretch, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_content_scale_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_scale_stretch")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 536857316)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_stretch() -> Window.ContentScaleStretch {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_content_scale_stretch, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.ContentScaleStretch (rawValue: _result)!
    }
    
    fileprivate static var method_set_keep_title_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_keep_title_visible")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_keep_title_visible(_ titleVisible: Bool) {
        withUnsafePointer(to: titleVisible) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_keep_title_visible, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_keep_title_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_keep_title_visible")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_keep_title_visible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_get_keep_title_visible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_factor: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_content_scale_factor")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_factor(_ factor: Double) {
        withUnsafePointer(to: factor) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_content_scale_factor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_content_scale_factor: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_scale_factor")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_factor() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Window.method_get_content_scale_factor, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_font_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_font_oversampling")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables font oversampling. This makes fonts look better when they are scaled up.
    public final func setUseFontOversampling(enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_use_font_oversampling, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_font_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_font_oversampling")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if font oversampling is enabled. See ``setUseFontOversampling(enable:)``.
    public final func isUsingFontOversampling() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_using_font_oversampling, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_mouse_passthrough_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_mouse_passthrough_polygon")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1509147220)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mouse_passthrough_polygon(_ polygon: PackedVector2Array) {
        withUnsafePointer(to: polygon.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_mouse_passthrough_polygon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mouse_passthrough_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mouse_passthrough_polygon")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2961356807)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mouse_passthrough_polygon() -> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        gi.object_method_bind_ptrcall(Window.method_get_mouse_passthrough_polygon, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_wrap_controls: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_wrap_controls")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_wrap_controls(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_wrap_controls, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_wrapping_controls: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_wrapping_controls")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_wrapping_controls() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_wrapping_controls, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_child_controls_changed: GDExtensionMethodBindPtr = {
        let methodName = StringName("child_controls_changed")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Requests an update of the ``Window`` size to fit underlying ``Control`` nodes.
    public final func childControlsChanged() {
        gi.object_method_bind_ptrcall(Window.method_child_controls_changed, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_theme")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2326690814)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme(_ theme: Theme?) {
        withUnsafePointer(to: theme?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_theme, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3846893731)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme() -> Theme? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Window.method_get_theme, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_theme_type_variation")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme_type_variation(_ themeType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_theme_type_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_type_variation")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme_type_variation() -> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall(Window.method_get_theme_type_variation, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_begin_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("begin_bulk_theme_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Prevents `*_theme_*_override` methods from emitting ``notificationThemeChanged`` until ``endBulkThemeOverride()`` is called.
    public final func beginBulkThemeOverride() {
        gi.object_method_bind_ptrcall(Window.method_begin_bulk_theme_override, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_end_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("end_bulk_theme_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends a bulk theme override update. See ``beginBulkThemeOverride()``.
    public final func endBulkThemeOverride() {
        gi.object_method_bind_ptrcall(Window.method_end_bulk_theme_override, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_add_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_icon_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1373065600)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme icon with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeIconOverride(name:)``.
    /// 
    /// See also ``getThemeIcon(name:themeType:)``.
    /// 
    public final func addThemeIconOverride(name: StringName, texture: Texture2D?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: texture?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_stylebox_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4188838905)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``StyleBox`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeStyleboxOverride(name:)``.
    /// 
    /// See also ``getThemeStylebox(name:themeType:)`` and ``Control/addThemeStyleboxOverride(name:stylebox:)`` for more details.
    /// 
    public final func addThemeStyleboxOverride(name: StringName, stylebox: StyleBox?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: stylebox?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_font_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3518018674)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Font`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontOverride(name:)``.
    /// 
    /// See also ``getThemeFont(name:themeType:)``.
    /// 
    public final func addThemeFontOverride(name: StringName, font: Font?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: font?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_font_size_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme font size with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontSizeOverride(name:)``.
    /// 
    /// See also ``getThemeFontSize(name:themeType:)``.
    /// 
    public final func addThemeFontSizeOverride(name: StringName, fontSize: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: fontSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_color_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4260178595)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Color`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeColorOverride(name:)``.
    /// 
    /// See also ``getThemeColor(name:themeType:)`` and ``Control/addThemeColorOverride(name:color:)`` for more details.
    /// 
    public final func addThemeColorOverride(name: StringName, color: Color) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_constant_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme constant with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeConstantOverride(name:)``.
    /// 
    /// See also ``getThemeConstant(name:themeType:)``.
    /// 
    public final func addThemeConstantOverride(name: StringName, constant: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: constant) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_add_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_icon_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme icon with the specified `name` previously added by ``addThemeIconOverride(name:texture:)`` or via the Inspector dock.
    public final func removeThemeIconOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_stylebox_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``StyleBox`` with the specified `name` previously added by ``addThemeStyleboxOverride(name:stylebox:)`` or via the Inspector dock.
    public final func removeThemeStyleboxOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_font_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Font`` with the specified `name` previously added by ``addThemeFontOverride(name:font:)`` or via the Inspector dock.
    public final func removeThemeFontOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_font_size_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme font size with the specified `name` previously added by ``addThemeFontSizeOverride(name:fontSize:)`` or via the Inspector dock.
    public final func removeThemeFontSizeOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_color_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Color`` with the specified `name` previously added by ``addThemeColorOverride(name:color:)`` or via the Inspector dock.
    public final func removeThemeColorOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_constant_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme constant with the specified `name` previously added by ``addThemeConstantOverride(name:constant:)`` or via the Inspector dock.
    public final func removeThemeConstantOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_remove_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_icon")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2336455395)!
            }
            
        }
        
    }()
    
    /// Returns an icon from the first matching ``Theme`` in the tree if that ``Theme`` has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeIcon(name: StringName, themeType: StringName = StringName ("")) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_stylebox")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2759935355)!
            }
            
        }
        
    }()
    
    /// Returns a ``StyleBox`` from the first matching ``Theme`` in the tree if that ``Theme`` has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeStylebox(name: StringName, themeType: StringName = StringName ("")) -> StyleBox? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_font")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 387378635)!
            }
            
        }
        
    }()
    
    /// Returns a ``Font`` from the first matching ``Theme`` in the tree if that ``Theme`` has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFont(name: StringName, themeType: StringName = StringName ("")) -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_font_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229578101)!
            }
            
        }
        
    }()
    
    /// Returns a font size from the first matching ``Theme`` in the tree if that ``Theme`` has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFontSize(name: StringName, themeType: StringName = StringName ("")) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_color")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2377051548)!
            }
            
        }
        
    }()
    
    /// Returns a ``Color`` from the first matching ``Theme`` in the tree if that ``Theme`` has a color item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for more details.
    /// 
    public final func getThemeColor(name: StringName, themeType: StringName = StringName ("")) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_constant")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229578101)!
            }
            
        }
        
    }()
    
    /// Returns a constant from the first matching ``Theme`` in the tree if that ``Theme`` has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for more details.
    /// 
    public final func getThemeConstant(name: StringName, themeType: StringName = StringName ("")) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_get_theme_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_icon_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme icon with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeIconOverride(name:texture:)``.
    /// 
    public final func hasThemeIconOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_stylebox_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``StyleBox`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeStyleboxOverride(name:stylebox:)``.
    /// 
    public final func hasThemeStyleboxOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Font`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontOverride(name:font:)``.
    /// 
    public final func hasThemeFontOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_size_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme font size with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontSizeOverride(name:fontSize:)``.
    /// 
    public final func hasThemeFontSizeOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_color_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Color`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeColorOverride(name:color:)``.
    /// 
    public final func hasThemeColorOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_constant_override")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme constant with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeConstantOverride(name:constant:)``.
    /// 
    public final func hasThemeConstantOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_has_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_icon")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeIcon(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_stylebox")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeStylebox(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFont(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFontSize(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_color")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a color item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeColor(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_constant")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeConstant(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_has_theme_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_base_scale")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the default base scale value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultBaseScale`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultBaseScale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Window.method_get_theme_default_base_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_theme_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_font")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3229501585)!
            }
            
        }
        
    }()
    
    /// Returns the default font from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFont`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFont() -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Window.method_get_theme_default_font, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_font_size")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the default font size value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFontSize`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFontSize() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Window.method_get_theme_default_font_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layout_direction")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3094704184)!
            }
            
        }
        
    }()
    
    /// Sets layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
    public final func setLayoutDirection(_ direction: Window.LayoutDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_layout_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layout_direction")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3909617982)!
            }
            
        }
        
    }()
    
    /// Returns layout direction and text writing direction.
    public final func getLayoutDirection() -> Window.LayoutDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Window.method_get_layout_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Window.LayoutDirection (rawValue: _result)!
    }
    
    fileprivate static var method_is_layout_rtl: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_layout_rtl")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if layout is right-to-left.
    public final func isLayoutRtl() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_layout_rtl, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_translate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_translate")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_translate(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_set_auto_translate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_auto_translating: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_auto_translating")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_translating() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Window.method_is_auto_translating, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1680304321)!
            }
            
        }
        
    }()
    
    /// Shows the ``Window`` and makes it transient (see ``transient``). If `rect` is provided, it will be set as the ``Window``'s size. Fails if called on the main window.
    public final func popup(rect: Rect2i = Rect2i (x: 0, y: 0, width: 0, height: 0)) {
        withUnsafePointer(to: rect) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_popup, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_on_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_on_parent")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1763793166)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` with a position shifted by parent ``Window``'s position. If the ``Window`` is embedded, has the same effect as ``popup(rect:)``.
    public final func popupOnParent(parentRect: Rect2i) {
        withUnsafePointer(to: parentRect) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_popup_on_parent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_centered: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_centered")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3447975422)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` at the center of the current screen, with optionally given minimum size. If the ``Window`` is embedded, it will be centered in the parent ``Viewport`` instead.
    /// 
    /// > Note: Calling it with the default value of `minsize` is equivalent to calling it with ``size``.
    /// 
    public final func popupCentered(minsize: Vector2i = Vector2i (x: 0, y: 0)) {
        withUnsafePointer(to: minsize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_popup_centered, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_centered_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_centered_ratio")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1014814997)!
            }
            
        }
        
    }()
    
    /// If ``Window`` is embedded, popups the ``Window`` centered inside its embedder and sets its size as a `ratio` of embedder's size.
    /// 
    /// If ``Window`` is a native window, popups the ``Window`` centered inside the screen of its parent ``Window`` and sets its size as a `ratio` of the screen size.
    /// 
    public final func popupCenteredRatio(_ ratio: Double = 0.8) {
        withUnsafePointer(to: ratio) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Window.method_popup_centered_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_centered_clamped: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_centered_clamped")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2613752477)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` centered inside its parent ``Window``. `fallbackRatio` determines the maximum size of the ``Window``, in relation to its parent.
    /// 
    /// > Note: Calling it with the default value of `minsize` is equivalent to calling it with ``size``.
    /// 
    public final func popupCenteredClamped(minsize: Vector2i = Vector2i (x: 0, y: 0), fallbackRatio: Double = 0.75) {
        withUnsafePointer(to: minsize) { pArg0 in
            withUnsafePointer(to: fallbackRatio) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_popup_centered_clamped, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_exclusive")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2134721627)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popup(rect:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusive(fromNode: Node?, rect: Rect2i = Rect2i (x: 0, y: 0, width: 0, height: 0)) {
        withUnsafePointer(to: fromNode?.handle) { pArg0 in
            withUnsafePointer(to: rect) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_popup_exclusive, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_exclusive_on_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_exclusive_on_parent")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2344671043)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupOnParent(parentRect:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveOnParent(fromNode: Node?, parentRect: Rect2i) {
        withUnsafePointer(to: fromNode?.handle) { pArg0 in
            withUnsafePointer(to: parentRect) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_popup_exclusive_on_parent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_exclusive_centered: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_exclusive_centered")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3357594017)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCentered(minsize:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCentered(fromNode: Node?, minsize: Vector2i = Vector2i (x: 0, y: 0)) {
        withUnsafePointer(to: fromNode?.handle) { pArg0 in
            withUnsafePointer(to: minsize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_popup_exclusive_centered, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_exclusive_centered_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_exclusive_centered_ratio")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2284776287)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCenteredRatio(_:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCenteredRatio(fromNode: Node?, ratio: Double = 0.8) {
        withUnsafePointer(to: fromNode?.handle) { pArg0 in
            withUnsafePointer(to: ratio) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Window.method_popup_exclusive_centered_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_popup_exclusive_centered_clamped: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup_exclusive_centered_clamped")
        return withUnsafePointer(to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2612708785)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCenteredClamped(minsize:fallbackRatio:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCenteredClamped(fromNode: Node?, minsize: Vector2i = Vector2i (x: 0, y: 0), fallbackRatio: Double = 0.75) {
        withUnsafePointer(to: fromNode?.handle) { pArg0 in
            withUnsafePointer(to: minsize) { pArg1 in
                withUnsafePointer(to: fallbackRatio) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Window.method_popup_exclusive_centered_clamped, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_contents_minimum_size":
                return _Window_proxy_get_contents_minimum_size
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ event: InputEvent) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? InputEvent ?? lookupObject (nativeHandle: ptr_0!) ?? InputEvent (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the ``Window`` is currently focused and receives any input, passing the received event as an argument. The event's position, if present, is in the embedder's coordinate system.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.windowInput.connect { event in
    ///    print ("caught signal")
    /// }
    /// ```
    public var windowInput: Signal1 { Signal1 (target: self, signalName: "window_input") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ files: PackedStringArray) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = PackedStringArray (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when files are dragged from the OS file manager and dropped in the game window. The argument is a list of file paths.
    /// 
    /// Note that this method only works with native windows, i.e. the main window and ``Window``-derived nodes when ``Viewport/guiEmbedSubwindows`` is disabled in the main viewport.
    /// 
    /// Example usage:
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.filesDropped.connect { files in
    ///    print ("caught signal")
    /// }
    /// ```
    public var filesDropped: Signal2 { Signal2 (target: self, signalName: "files_dropped") }
    
    /// Emitted when the mouse cursor enters the ``Window``'s visible area, that is not occluded behind other ``Control``s or windows, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseEntered: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_entered") }
    
    /// Emitted when the mouse cursor leaves the ``Window``'s visible area, that is not occluded behind other ``Control``s or windows, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseExited: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_exited") }
    
    /// Emitted when the ``Window`` gains focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusEntered: SimpleSignal { SimpleSignal (target: self, signalName: "focus_entered") }
    
    /// Emitted when the ``Window`` loses its focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusExited: SimpleSignal { SimpleSignal (target: self, signalName: "focus_exited") }
    
    /// Emitted when the ``Window``'s close button is pressed or when ``popupWindow`` is enabled and user clicks outside the window.
    /// 
    /// This signal can be used to handle window closing, e.g. by connecting it to ``hide()``.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.closeRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var closeRequested: SimpleSignal { SimpleSignal (target: self, signalName: "close_requested") }
    
    /// Emitted when a go back request is sent (e.g. pressing the "Back" button on Android), right after ``Node/notificationWmGoBackRequest``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.goBackRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var goBackRequested: SimpleSignal { SimpleSignal (target: self, signalName: "go_back_requested") }
    
    /// Emitted when ``Window`` is made visible or disappears.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.visibilityChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var visibilityChanged: SimpleSignal { SimpleSignal (target: self, signalName: "visibility_changed") }
    
    /// Emitted right after ``popup(rect:)`` call, before the ``Window`` appears or does anything.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.aboutToPopup.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var aboutToPopup: SimpleSignal { SimpleSignal (target: self, signalName: "about_to_popup") }
    
    /// Emitted when the ``notificationThemeChanged`` notification is sent.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.themeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var themeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "theme_changed") }
    
    /// Emitted when the ``Window``'s DPI changes as a result of OS-level changes (e.g. moving the window from a Retina display to a lower resolution one).
    /// 
    /// > Note: Only implemented on macOS.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.dpiChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var dpiChanged: SimpleSignal { SimpleSignal (target: self, signalName: "dpi_changed") }
    
    /// Emitted when window title bar decorations are changed, e.g. macOS window enter/exit full screen mode, or extend-to-title flag is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.titlebarChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var titlebarChanged: SimpleSignal { SimpleSignal (target: self, signalName: "titlebar_changed") }
    
}

// Support methods for proxies
func _Window_proxy_get_contents_minimum_size (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Window>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getContentsMinimumSize ()
    retPtr!.storeBytes (of: ret, as: Vector2.self)
}

