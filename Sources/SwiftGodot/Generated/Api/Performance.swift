// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Exposes performance-related data.
/// 
/// This class provides access to a number of different monitors related to performance, such as memory usage, draw calls, and FPS. These are the same as the values displayed in the **Monitor** tab in the editor's **Debugger** panel. By using the ``getMonitor(_:)`` method of this class, you can access this data from your code.
/// 
/// You can add custom monitors using the ``addCustomMonitor(id:callable:arguments:)`` method. Custom monitors are available in **Monitor** tab in the editor's **Debugger** panel together with built-in monitors.
/// 
/// > Note: Some of the built-in monitors are only available in debug mode and will always return `0` when used in a project exported in release mode.
/// 
/// > Note: Some of the built-in monitors are not updated in real-time for performance reasons, so there may be a delay of up to 1 second between changes.
/// 
/// > Note: Custom monitors do not support negative values. Negative values are clamped to 0.
/// 
open class Performance: Object {
    /// The shared instance of this class
    public static var shared: Performance = {
        return withUnsafePointer (to: &Performance.godotClassName.content) { ptr in
            Performance (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "Performance" }
    public enum Monitor: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The number of frames rendered in the last second. This metric is only updated once per second, even if queried more often. _Higher is better._
        case timeFps = 0 // TIME_FPS
        /// Time it took to complete one frame, in seconds. _Lower is better._
        case timeProcess = 1 // TIME_PROCESS
        /// Time it took to complete one physics frame, in seconds. _Lower is better._
        case timePhysicsProcess = 2 // TIME_PHYSICS_PROCESS
        /// Time it took to complete one navigation step, in seconds. This includes navigation map updates as well as agent avoidance calculations. _Lower is better._
        case timeNavigationProcess = 3 // TIME_NAVIGATION_PROCESS
        /// Static memory currently used, in bytes. Not available in release builds. _Lower is better._
        case memoryStatic = 4 // MEMORY_STATIC
        /// Available static memory. Not available in release builds. _Lower is better._
        case memoryStaticMax = 5 // MEMORY_STATIC_MAX
        /// Largest amount of memory the message queue buffer has used, in bytes. The message queue is used for deferred functions calls and notifications. _Lower is better._
        case memoryMessageBufferMax = 6 // MEMORY_MESSAGE_BUFFER_MAX
        /// Number of objects currently instantiated (including nodes). _Lower is better._
        case objectCount = 7 // OBJECT_COUNT
        /// Number of resources currently used. _Lower is better._
        case objectResourceCount = 8 // OBJECT_RESOURCE_COUNT
        /// Number of nodes currently instantiated in the scene tree. This also includes the root node. _Lower is better._
        case objectNodeCount = 9 // OBJECT_NODE_COUNT
        /// Number of orphan nodes, i.e. nodes which are not parented to a node of the scene tree. _Lower is better._
        case objectOrphanNodeCount = 10 // OBJECT_ORPHAN_NODE_COUNT
        /// The total number of objects in the last rendered frame. This metric doesn't include culled objects (either via hiding nodes, frustum culling or occlusion culling). _Lower is better._
        case renderTotalObjectsInFrame = 11 // RENDER_TOTAL_OBJECTS_IN_FRAME
        /// The total number of vertices or indices rendered in the last rendered frame. This metric doesn't include primitives from culled objects (either via hiding nodes, frustum culling or occlusion culling). Due to the depth prepass and shadow passes, the number of primitives is always higher than the actual number of vertices in the scene (typically double or triple the original vertex count). _Lower is better._
        case renderTotalPrimitivesInFrame = 12 // RENDER_TOTAL_PRIMITIVES_IN_FRAME
        /// The total number of draw calls performed in the last rendered frame. This metric doesn't include culled objects (either via hiding nodes, frustum culling or occlusion culling), since they do not result in draw calls. _Lower is better._
        case renderTotalDrawCallsInFrame = 13 // RENDER_TOTAL_DRAW_CALLS_IN_FRAME
        /// The amount of video memory used (texture and vertex memory combined, in bytes). Since this metric also includes miscellaneous allocations, this value is always greater than the sum of ``Monitor/renderTextureMemUsed`` and ``Monitor/renderBufferMemUsed``. _Lower is better._
        case renderVideoMemUsed = 14 // RENDER_VIDEO_MEM_USED
        /// The amount of texture memory used (in bytes). _Lower is better._
        case renderTextureMemUsed = 15 // RENDER_TEXTURE_MEM_USED
        /// The amount of render buffer memory used (in bytes). _Lower is better._
        case renderBufferMemUsed = 16 // RENDER_BUFFER_MEM_USED
        /// Number of active ``RigidBody2D`` nodes in the game. _Lower is better._
        case physics2dActiveObjects = 17 // PHYSICS_2D_ACTIVE_OBJECTS
        /// Number of collision pairs in the 2D physics engine. _Lower is better._
        case physics2dCollisionPairs = 18 // PHYSICS_2D_COLLISION_PAIRS
        /// Number of islands in the 2D physics engine. _Lower is better._
        case physics2dIslandCount = 19 // PHYSICS_2D_ISLAND_COUNT
        /// Number of active ``RigidBody3D`` and ``VehicleBody3D`` nodes in the game. _Lower is better._
        case physics3dActiveObjects = 20 // PHYSICS_3D_ACTIVE_OBJECTS
        /// Number of collision pairs in the 3D physics engine. _Lower is better._
        case physics3dCollisionPairs = 21 // PHYSICS_3D_COLLISION_PAIRS
        /// Number of islands in the 3D physics engine. _Lower is better._
        case physics3dIslandCount = 22 // PHYSICS_3D_ISLAND_COUNT
        /// Output latency of the ``AudioServer``. Equivalent to calling ``AudioServer/getOutputLatency()``, it is not recommended to call this every frame.
        case audioOutputLatency = 23 // AUDIO_OUTPUT_LATENCY
        /// Number of active navigation maps in the ``NavigationServer3D``. This also includes the two empty default navigation maps created by World2D and World3D.
        case navigationActiveMaps = 24 // NAVIGATION_ACTIVE_MAPS
        /// Number of active navigation regions in the ``NavigationServer3D``.
        case navigationRegionCount = 25 // NAVIGATION_REGION_COUNT
        /// Number of active navigation agents processing avoidance in the ``NavigationServer3D``.
        case navigationAgentCount = 26 // NAVIGATION_AGENT_COUNT
        /// Number of active navigation links in the ``NavigationServer3D``.
        case navigationLinkCount = 27 // NAVIGATION_LINK_COUNT
        /// Number of navigation mesh polygons in the ``NavigationServer3D``.
        case navigationPolygonCount = 28 // NAVIGATION_POLYGON_COUNT
        /// Number of navigation mesh polygon edges in the ``NavigationServer3D``.
        case navigationEdgeCount = 29 // NAVIGATION_EDGE_COUNT
        /// Number of navigation mesh polygon edges that were merged due to edge key overlap in the ``NavigationServer3D``.
        case navigationEdgeMergeCount = 30 // NAVIGATION_EDGE_MERGE_COUNT
        /// Number of polygon edges that are considered connected by edge proximity ``NavigationServer3D``.
        case navigationEdgeConnectionCount = 31 // NAVIGATION_EDGE_CONNECTION_COUNT
        /// Number of navigation mesh polygon edges that could not be merged in the ``NavigationServer3D``. The edges still may be connected by edge proximity or with links.
        case navigationEdgeFreeCount = 32 // NAVIGATION_EDGE_FREE_COUNT
        /// Represents the size of the ``Performance/Monitor`` enum.
        case monitorMax = 33 // MONITOR_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .timeFps: return ".timeFps"
                case .timeProcess: return ".timeProcess"
                case .timePhysicsProcess: return ".timePhysicsProcess"
                case .timeNavigationProcess: return ".timeNavigationProcess"
                case .memoryStatic: return ".memoryStatic"
                case .memoryStaticMax: return ".memoryStaticMax"
                case .memoryMessageBufferMax: return ".memoryMessageBufferMax"
                case .objectCount: return ".objectCount"
                case .objectResourceCount: return ".objectResourceCount"
                case .objectNodeCount: return ".objectNodeCount"
                case .objectOrphanNodeCount: return ".objectOrphanNodeCount"
                case .renderTotalObjectsInFrame: return ".renderTotalObjectsInFrame"
                case .renderTotalPrimitivesInFrame: return ".renderTotalPrimitivesInFrame"
                case .renderTotalDrawCallsInFrame: return ".renderTotalDrawCallsInFrame"
                case .renderVideoMemUsed: return ".renderVideoMemUsed"
                case .renderTextureMemUsed: return ".renderTextureMemUsed"
                case .renderBufferMemUsed: return ".renderBufferMemUsed"
                case .physics2dActiveObjects: return ".physics2dActiveObjects"
                case .physics2dCollisionPairs: return ".physics2dCollisionPairs"
                case .physics2dIslandCount: return ".physics2dIslandCount"
                case .physics3dActiveObjects: return ".physics3dActiveObjects"
                case .physics3dCollisionPairs: return ".physics3dCollisionPairs"
                case .physics3dIslandCount: return ".physics3dIslandCount"
                case .audioOutputLatency: return ".audioOutputLatency"
                case .navigationActiveMaps: return ".navigationActiveMaps"
                case .navigationRegionCount: return ".navigationRegionCount"
                case .navigationAgentCount: return ".navigationAgentCount"
                case .navigationLinkCount: return ".navigationLinkCount"
                case .navigationPolygonCount: return ".navigationPolygonCount"
                case .navigationEdgeCount: return ".navigationEdgeCount"
                case .navigationEdgeMergeCount: return ".navigationEdgeMergeCount"
                case .navigationEdgeConnectionCount: return ".navigationEdgeConnectionCount"
                case .navigationEdgeFreeCount: return ".navigationEdgeFreeCount"
                case .monitorMax: return ".monitorMax"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_monitor: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_monitor")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1943275655)!
            }
            
        }
        
    }()
    
    /// Returns the value of one of the available built-in monitors. You should provide one of the ``Performance/Monitor`` constants as the argument, like this:
    /// 
    /// See ``getCustomMonitor(id:)`` to query custom performance monitors' values.
    /// 
    public static func getMonitor(_ monitor: Performance.Monitor) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: monitor.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_monitor, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_custom_monitor: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_custom_monitor")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4099036814)!
            }
            
        }
        
    }()
    
    /// Adds a custom monitor with the name `id`. You can specify the category of the monitor using slash delimiters in `id` (for example: `"Game/NumberOfNPCs"`). If there is more than one slash delimiter, then the default category is used. The default category is `"Custom"`. Prints an error if given `id` is already present.
    /// 
    /// The debugger calls the callable to get the value of custom monitor. The callable must return a zero or positive integer or floating-point number.
    /// 
    /// Callables are called with arguments supplied in argument array.
    /// 
    public static func addCustomMonitor(id: StringName, callable: Callable, arguments: GArray = GArray ()) {
        withUnsafePointer(to: id.content) { pArg0 in
            withUnsafePointer(to: callable.content) { pArg1 in
                withUnsafePointer(to: arguments.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_add_custom_monitor, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_custom_monitor: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_custom_monitor")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes the custom monitor with given `id`. Prints an error if the given `id` is already absent.
    public static func removeCustomMonitor(id: StringName) {
        withUnsafePointer(to: id.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_remove_custom_monitor, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_custom_monitor: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_custom_monitor")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2041966384)!
            }
            
        }
        
    }()
    
    /// Returns `true` if custom monitor with the given `id` is present, `false` otherwise.
    public static func hasCustomMonitor(id: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: id.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_has_custom_monitor, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_custom_monitor: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_custom_monitor")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2138907829)!
            }
            
        }
        
    }()
    
    /// Returns the value of custom monitor with given `id`. The callable is called to get the value of custom monitor. See also ``hasCustomMonitor(id:)``. Prints an error if the given `id` is absent.
    public static func getCustomMonitor(id: StringName) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: id.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_custom_monitor, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_get_monitor_modification_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_monitor_modification_time")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2455072627)!
            }
            
        }
        
    }()
    
    /// Returns the last tick in which custom monitor was added/removed (in microseconds since the engine started). This is set to ``Time/getTicksUsec()`` when the monitor is updated.
    public static func getMonitorModificationTime() -> UInt {
        var _result: UInt = 0
        gi.object_method_bind_ptrcall(method_get_monitor_modification_time, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_custom_monitor_names: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_custom_monitor_names")
        return withUnsafePointer(to: &Performance.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Returns the names of active custom monitors in an ``GArray``.
    public static func getCustomMonitorNames() -> VariantCollection<StringName> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(method_get_custom_monitor_names, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return VariantCollection<StringName>(content: _result)
    }
    
}

