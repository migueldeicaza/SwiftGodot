// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstract base class for 2D physics objects.
/// 
/// Abstract base class for 2D physics objects. ``CollisionObject2D`` can hold any number of ``Shape2D``s for collision. Each shape must be assigned to a _shape owner_. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the `shape_owner_*` methods.
/// 
/// > Note: Only collisions between objects within the same canvas (``Viewport`` canvas or ``CanvasLayer``) are supported. The behavior of collisions between objects in different canvases is undefined.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``inputEvent``
/// - ``mouseEntered``
/// - ``mouseExited``
/// - ``mouseShapeEntered``
/// - ``mouseShapeExited``
open class CollisionObject2D: Node2D {
    override open class var godotClassName: StringName { "CollisionObject2D" }
    public enum DisableMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, remove from the physics simulation to stop all physics interactions with this ``CollisionObject2D``.
        /// 
        /// Automatically re-added to the physics simulation when the ``Node`` is processed again.
        /// 
        case remove = 0 // DISABLE_MODE_REMOVE
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, make the body static. Doesn't affect ``Area2D``. ``PhysicsBody2D`` can't be affected by forces or other bodies while static.
        /// 
        /// Automatically set ``PhysicsBody2D`` back to its original mode when the ``Node`` is processed again.
        /// 
        case makeStatic = 1 // DISABLE_MODE_MAKE_STATIC
        /// When ``Node/processMode`` is set to ``Node/ProcessMode/disabled``, do not affect the physics simulation.
        case keepActive = 2 // DISABLE_MODE_KEEP_ACTIVE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .remove: return ".remove"
                case .makeStatic: return ".makeStatic"
                case .keepActive: return ".keepActive"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// Defines the behavior in physics when ``Node/processMode`` is set to ``Node/ProcessMode/disabled``. See ``CollisionObject2D/DisableMode`` for more details about the different modes.
    final public var disableMode: CollisionObject2D.DisableMode {
        get {
            return get_disable_mode ()
        }
        
        set {
            set_disable_mode (newValue)
        }
        
    }
    
    /// The physics layers this CollisionObject2D is in. Collision objects can exist in one or more of 32 different layers. See also ``collisionMask``.
    /// 
    /// > Note: Object A can detect a contact with object B only if object B is in any of the layers that object A scans. See <a href="https://docs.godotengine.org/en//tutorials/physics/physics_introduction.html#collision-layers-and-masks">Collision layers and masks</a> in the documentation for more information.
    /// 
    final public var collisionLayer: UInt32 {
        get {
            return get_collision_layer ()
        }
        
        set {
            set_collision_layer (newValue)
        }
        
    }
    
    /// The physics layers this CollisionObject2D scans. Collision objects can scan one or more of 32 different layers. See also ``collisionLayer``.
    /// 
    /// > Note: Object A can detect a contact with object B only if object B is in any of the layers that object A scans. See <a href="https://docs.godotengine.org/en//tutorials/physics/physics_introduction.html#collision-layers-and-masks">Collision layers and masks</a> in the documentation for more information.
    /// 
    final public var collisionMask: UInt32 {
        get {
            return get_collision_mask ()
        }
        
        set {
            set_collision_mask (newValue)
        }
        
    }
    
    /// The priority used to solve colliding when occurring penetration. The higher the priority is, the lower the penetration into the object will be. This can for example be used to prevent the player from breaking through the boundaries of a level.
    final public var collisionPriority: Double {
        get {
            return get_collision_priority ()
        }
        
        set {
            set_collision_priority (newValue)
        }
        
    }
    
    /// If `true`, this object is pickable. A pickable object can detect the mouse pointer entering/leaving, and if the mouse is inside it, report input events. Requires at least one ``collisionLayer`` bit to be set.
    final public var inputPickable: Bool {
        get {
            return is_pickable ()
        }
        
        set {
            set_pickable (newValue)
        }
        
    }
    
    /* Methods */
    /// Accepts unhandled ``InputEvent``s. `shapeIdx` is the child index of the clicked ``Shape2D``. Connect to [signal input_event] to easily pick up these events.
    /// 
    /// > Note: ``_inputEvent(viewport:event:shapeIdx:)`` requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    /// 
    @_documentation(visibility: public)
    open func _inputEvent(viewport: Viewport?, event: InputEvent?, shapeIdx: Int32) {
    }
    
    /// Called when the mouse pointer enters any of this object's shapes. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject2D`` won't cause this function to be called.
    @_documentation(visibility: public)
    open func _mouseEnter() {
    }
    
    /// Called when the mouse pointer exits all this object's shapes. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject2D`` won't cause this function to be called.
    @_documentation(visibility: public)
    open func _mouseExit() {
    }
    
    /// Called when the mouse pointer enters any of this object's shapes or moves from one shape to another. `shapeIdx` is the child index of the newly entered ``Shape2D``. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be called.
    @_documentation(visibility: public)
    open func _mouseShapeEnter(shapeIdx: Int32) {
    }
    
    /// Called when the mouse pointer exits any of this object's shapes. `shapeIdx` is the child index of the exited ``Shape2D``. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be called.
    @_documentation(visibility: public)
    open func _mouseShapeExit(shapeIdx: Int32) {
    }
    
    fileprivate static var method_get_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rid")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the object's ``RID``.
    public final func getRid() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_rid, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_layer(_ layer: UInt32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_set_collision_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_layer() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_collision_layer, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_mask(_ mask: UInt32) {
        withUnsafePointer(to: mask) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_set_collision_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_mask() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_collision_mask, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_layer_value")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionLayer``, given a `layerNumber` between 1 and 32.
    public final func setCollisionLayerValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_set_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_layer_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_layer_value")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionLayer`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionLayerValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_get_collision_layer_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_mask_value")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Based on `value`, enables or disables the specified layer in the ``collisionMask``, given a `layerNumber` between 1 and 32.
    public final func setCollisionMaskValue(layerNumber: Int32, value: Bool) {
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_set_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_mask_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_mask_value")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether or not the specified layer of the ``collisionMask`` is enabled, given a `layerNumber` between 1 and 32.
    public final func getCollisionMaskValue(layerNumber: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layerNumber) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_get_collision_mask_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_priority")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_priority(_ priority: Double) {
        withUnsafePointer(to: priority) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_set_collision_priority, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_priority")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_priority() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_collision_priority, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_disable_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_mode")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1919204045)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_mode(_ mode: CollisionObject2D.DisableMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_set_disable_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_disable_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_disable_mode")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3172846349)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_disable_mode() -> CollisionObject2D.DisableMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_disable_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return CollisionObject2D.DisableMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_pickable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pickable")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pickable(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_set_pickable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_pickable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_pickable")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_pickable() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CollisionObject2D.method_is_pickable, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_create_shape_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_shape_owner")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3429307534)!
            }
            
        }
        
    }()
    
    /// Creates a new shape owner for the given object. Returns `owner_id` of the new owner for future reference.
    public final func createShapeOwner(_ owner: Object?) -> UInt32 {
        var _result: UInt32 = 0
        withUnsafePointer(to: owner?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_create_shape_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_shape_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_shape_owner")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the given shape owner.
    public final func removeShapeOwner(ownerId: UInt32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_remove_shape_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_shape_owners: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_shape_owners")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 969006518)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` of `owner_id` identifiers. You can use these ids in other methods that take `owner_id` as an argument.
    public final func getShapeOwners() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(CollisionObject2D.method_get_shape_owners, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_shape_owner_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_transform")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 30160968)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform2D`` of the given shape owner.
    public final func shapeOwnerSetTransform(ownerId: UInt32, transform: Transform2D) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: transform) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_set_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_transform")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3836996910)!
            }
            
        }
        
    }()
    
    /// Returns the shape owner's ``Transform2D``.
    public final func shapeOwnerGetTransform(ownerId: UInt32) -> Transform2D {
        var _result: Transform2D = Transform2D ()
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_get_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_get_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_owner")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3332903315)!
            }
            
        }
        
    }()
    
    /// Returns the parent object of the given shape owner.
    public final func shapeOwnerGetOwner(ownerId: UInt32) -> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_get_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_shape_owner_set_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_disabled")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `true`, disables the given shape owner.
    public final func shapeOwnerSetDisabled(ownerId: UInt32, disabled: Bool) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: disabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_set_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_shape_owner_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_shape_owner_disabled")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// If `true`, the shape owner and its shapes are disabled.
    public final func isShapeOwnerDisabled(ownerId: UInt32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_is_shape_owner_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_set_one_way_collision: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_one_way_collision")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `enable` is `true`, collisions for the shape owner originating from this ``CollisionObject2D`` will not be reported to collided with ``CollisionObject2D``s.
    public final func shapeOwnerSetOneWayCollision(ownerId: UInt32, enable: Bool) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_set_one_way_collision, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_shape_owner_one_way_collision_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_shape_owner_one_way_collision_enabled")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if collisions for the shape owner originating from this ``CollisionObject2D`` will not be reported to collided with ``CollisionObject2D``s.
    public final func isShapeOwnerOneWayCollisionEnabled(ownerId: UInt32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_is_shape_owner_one_way_collision_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_set_one_way_collision_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_set_one_way_collision_margin")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1602489585)!
            }
            
        }
        
    }()
    
    /// Sets the `one_way_collision_margin` of the shape owner identified by given `ownerId` to `margin` pixels.
    public final func shapeOwnerSetOneWayCollisionMargin(ownerId: UInt32, margin: Double) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: margin) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_set_one_way_collision_margin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_shape_owner_one_way_collision_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_shape_owner_one_way_collision_margin")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2339986948)!
            }
            
        }
        
    }()
    
    /// Returns the `one_way_collision_margin` of the shape owner identified by given `ownerId`.
    public final func getShapeOwnerOneWayCollisionMargin(ownerId: UInt32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_get_shape_owner_one_way_collision_margin, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_add_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_add_shape")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2077425081)!
            }
            
        }
        
    }()
    
    /// Adds a ``Shape2D`` to the shape owner.
    public final func shapeOwnerAddShape(ownerId: UInt32, shape: Shape2D?) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shape?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_add_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_get_shape_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape_count")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the number of shapes the given shape owner contains.
    public final func shapeOwnerGetShapeCount(ownerId: UInt32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_get_shape_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_get_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3106725749)!
            }
            
        }
        
    }()
    
    /// Returns the ``Shape2D`` with the given ID from the given shape owner.
    public final func shapeOwnerGetShape(ownerId: UInt32, shapeId: Int32) -> Shape2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_get_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_shape_owner_get_shape_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_get_shape_index")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Returns the child index of the ``Shape2D`` with the given ID from the given shape owner.
    public final func shapeOwnerGetShapeIndex(ownerId: UInt32, shapeId: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_get_shape_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shape_owner_remove_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_remove_shape")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Removes a shape from the given shape owner.
    public final func shapeOwnerRemoveShape(ownerId: UInt32, shapeId: Int32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: shapeId) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_remove_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_owner_clear_shapes: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_owner_clear_shapes")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes all shapes from the shape owner.
    public final func shapeOwnerClearShapes(ownerId: UInt32) {
        withUnsafePointer(to: ownerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_owner_clear_shapes, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shape_find_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("shape_find_owner")
        return withUnsafePointer(to: &CollisionObject2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the `owner_id` of the given shape.
    public final func shapeFindOwner(shapeIndex: Int32) -> UInt32 {
        var _result: UInt32 = 0
        withUnsafePointer(to: shapeIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CollisionObject2D.method_shape_find_owner, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_input_event":
                return _CollisionObject2D_proxy_input_event
            case "_mouse_enter":
                return _CollisionObject2D_proxy_mouse_enter
            case "_mouse_exit":
                return _CollisionObject2D_proxy_mouse_exit
            case "_mouse_shape_enter":
                return _CollisionObject2D_proxy_mouse_shape_enter
            case "_mouse_shape_exit":
                return _CollisionObject2D_proxy_mouse_shape_exit
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ viewport: Node, _ event: InputEvent, _ shapeIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? lookupObject (nativeHandle: ptr_0!) ?? Node (nativeHandle: ptr_0!)
                var ptr_1: UnsafeMutableRawPointer?
                args [1]!.toType (Variant.GType.object, dest: &ptr_1)
                let arg_1 = lookupLiveObject (handleAddress: ptr_1!) as? InputEvent ?? lookupObject (nativeHandle: ptr_1!) ?? InputEvent (nativeHandle: ptr_1!)
                let arg_2 = Int64 (args [2]!)!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an input event occurs. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. See ``_inputEvent(viewport:event:shapeIdx:)`` for details.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.inputEvent.connect { viewport, event, shapeIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var inputEvent: Signal1 { Signal1 (target: self, signalName: "input_event") }
    
    /// Emitted when the mouse pointer enters any of this object's shapes. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject2D`` won't cause this signal to be emitted.
    /// 
    /// > Note: Due to the lack of continuous collision detection, this signal may not be emitted in the expected order if the mouse moves fast enough and the ``CollisionObject2D``'s area is small. This signal may also not be emitted if another ``CollisionObject2D`` is overlapping the ``CollisionObject2D`` in question.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseEntered: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_entered") }
    
    /// Emitted when the mouse pointer exits all this object's shapes. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set. Note that moving between different shapes within a single ``CollisionObject2D`` won't cause this signal to be emitted.
    /// 
    /// > Note: Due to the lack of continuous collision detection, this signal may not be emitted in the expected order if the mouse moves fast enough and the ``CollisionObject2D``'s area is small. This signal may also not be emitted if another ``CollisionObject2D`` is overlapping the ``CollisionObject2D`` in question.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseExited: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_exited") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ shapeIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the mouse pointer enters any of this object's shapes or moves from one shape to another. `shapeIdx` is the child index of the newly entered ``Shape2D``. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseShapeEntered.connect { shapeIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseShapeEntered: Signal2 { Signal2 (target: self, signalName: "mouse_shape_entered") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ shapeIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the mouse pointer exits any of this object's shapes. `shapeIdx` is the child index of the exited ``Shape2D``. Requires ``inputPickable`` to be `true` and at least one ``collisionLayer`` bit to be set.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseShapeExited.connect { shapeIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseShapeExited: Signal3 { Signal3 (target: self, signalName: "mouse_shape_exited") }
    
}

// Support methods for proxies
func _CollisionObject2D_proxy_input_event (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CollisionObject2D>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._inputEvent (viewport: lookupLiveObject (handleAddress: resolved_0) as? Viewport ?? lookupObject (nativeHandle: resolved_0)!, event: lookupLiveObject (handleAddress: resolved_1) as? InputEvent ?? lookupObject (nativeHandle: resolved_1)!, shapeIdx: args [2]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _CollisionObject2D_proxy_mouse_enter (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<CollisionObject2D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseEnter ()
}

func _CollisionObject2D_proxy_mouse_exit (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<CollisionObject2D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseExit ()
}

func _CollisionObject2D_proxy_mouse_shape_enter (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CollisionObject2D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseShapeEnter (shapeIdx: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _CollisionObject2D_proxy_mouse_shape_exit (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CollisionObject2D>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._mouseShapeExit (shapeIdx: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

