// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Provides access to the Java Native Interface.
/// 
/// The JavaClassWrapper singleton provides a way for the Godot application to send and receive data through the <a href="https://developer.android.com/training/articles/perf-jni">Java Native Interface</a> (JNI).
/// 
/// > Note: This singleton is only available in Android builds.
/// 
open class JavaClassWrapper: Object {
    /// The shared instance of this class
    public static var shared: JavaClassWrapper = {
        return withUnsafePointer (to: &JavaClassWrapper.godotClassName.content) { ptr in
            JavaClassWrapper (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "JavaClassWrapper" }
    /* Methods */
    fileprivate static var method_wrap: GDExtensionMethodBindPtr = {
        let methodName = StringName("wrap")
        return withUnsafePointer(to: &JavaClassWrapper.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1124367868)!
            }
            
        }
        
    }()
    
    /// Wraps a class defined in Java, and returns it as a ``JavaClass`` ``Object`` type that Godot can interact with.
    /// 
    /// > Note: This method only works on Android. On every other platform, this method does nothing and returns an empty ``JavaClass``.
    /// 
    public static func wrap(name: String) -> JavaClass? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_wrap, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
}

