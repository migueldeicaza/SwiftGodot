// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node for 2D tile-based maps.
/// 
/// Node for 2D tile-based maps. Tilemaps use a ``TileSet`` which contain a list of tiles which are used to create grid-based maps. A TileMap may have several layers, layouting tiles on top of each other.
/// 
/// For performance reasons, all TileMap updates are batched at the end of a frame. Notably, this means that scene tiles from a ``TileSetScenesCollectionSource`` may be initialized after their parent. This is only queued when inside the scene tree.
/// 
/// To force an update earlier on, call ``updateInternals()``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``changed``
open class TileMap: Node2D {
    override open class var godotClassName: StringName { "TileMap" }
    public enum VisibilityMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Use the debug settings to determine visibility.
        case `default` = 0 // VISIBILITY_MODE_DEFAULT
        /// Always hide.
        case forceHide = 2 // VISIBILITY_MODE_FORCE_HIDE
        /// Always show.
        case forceShow = 1 // VISIBILITY_MODE_FORCE_SHOW
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .forceHide: return ".forceHide"
                case .forceShow: return ".forceShow"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The ``TileSet`` used by this ``TileMap``. The textures, collisions, and additional behavior of all available tiles are stored here.
    final public var tileSet: TileSet? {
        get {
            return get_tileset ()
        }
        
        set {
            set_tileset (newValue)
        }
        
    }
    
    /// The TileMap's quadrant size. A quadrant is a group of tiles to be drawn together on a single canvas item, for optimization purposes. ``renderingQuadrantSize`` defines the length of a square's side, in the map's coordinate system, that forms the quadrant. Thus, the default quadrant size groups together `16 * 16 = 256` tiles.
    /// 
    /// The quadrant size does not apply on Y-sorted layers, as tiles are grouped by Y position instead in that case.
    /// 
    /// > Note: As quadrants are created according to the map's coordinate system, the quadrant's "square shape" might not look like square in the TileMap's local coordinate system.
    /// 
    final public var renderingQuadrantSize: Int32 {
        get {
            return get_rendering_quadrant_size ()
        }
        
        set {
            set_rendering_quadrant_size (newValue)
        }
        
    }
    
    /// If enabled, the TileMap will see its collisions synced to the physics tick and change its collision type from static to kinematic. This is required to create TileMap-based moving platform.
    /// 
    /// > Note: Enabling ``collisionAnimatable`` may have a small performance impact, only do it if the TileMap is moving and has colliding tiles.
    /// 
    final public var collisionAnimatable: Bool {
        get {
            return is_collision_animatable ()
        }
        
        set {
            set_collision_animatable (newValue)
        }
        
    }
    
    /// Show or hide the TileMap's collision shapes. If set to ``VisibilityMode/`default```, this depends on the show collision debug settings.
    final public var collisionVisibilityMode: TileMap.VisibilityMode {
        get {
            return get_collision_visibility_mode ()
        }
        
        set {
            set_collision_visibility_mode (newValue)
        }
        
    }
    
    /// Show or hide the TileMap's navigation meshes. If set to ``VisibilityMode/`default```, this depends on the show navigation debug settings.
    final public var navigationVisibilityMode: TileMap.VisibilityMode {
        get {
            return get_navigation_visibility_mode ()
        }
        
        set {
            set_navigation_visibility_mode (newValue)
        }
        
    }
    
    /* Methods */
    /// Should return `true` if the tile at coordinates `coords` on layer `layer` requires a runtime update.
    /// 
    /// > Warning: Make sure this function only return `true` when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
    /// 
    /// > Note: If the result of this function should changed, use ``notifyRuntimeTileDataUpdate(layer:)`` to notify the TileMap it needs an update.
    /// 
    @_documentation(visibility: public)
    open func _useTileDataRuntimeUpdate(layer: Int32, coords: Vector2i) -> Bool {
        return false
    }
    
    /// Called with a TileData object about to be used internally by the TileMap, allowing its modification at runtime.
    /// 
    /// This method is only called if ``_useTileDataRuntimeUpdate(layer:coords:)`` is implemented and returns `true` for the given tile `coords` and `layer`.
    /// 
    /// > Warning: The `tileData` object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
    /// 
    /// > Note: If the properties of `tileData` object should change over time, use ``notifyRuntimeTileDataUpdate(layer:)`` to notify the TileMap it needs an update.
    /// 
    @_documentation(visibility: public)
    open func _tileDataRuntimeUpdate(layer: Int32, coords: Vector2i, tileData: TileData?) {
    }
    
    fileprivate static var method_set_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_map")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Assigns `map` as a ``NavigationServer2D`` navigation map for the specified TileMap layer `layer`.
    public final func setNavigationMap(layer: Int32, map: RID) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: map.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_navigation_map")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 495598643)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of the ``NavigationServer2D`` navigation map assigned to the specified TileMap layer `layer`.
    public final func getNavigationMap(layer: Int32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_force_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_update")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Forces the TileMap and the layer `layer` to update.
    public final func forceUpdate(layer: Int32 = -1) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_force_update, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_tileset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tileset")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 774531446)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tileset(_ tileset: TileSet?) {
        withUnsafePointer(to: tileset?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_set_tileset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tileset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tileset")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2678226422)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tileset() -> TileSet? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(TileMap.method_get_tileset, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_rendering_quadrant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_rendering_quadrant_size")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_rendering_quadrant_size(_ size: Int32) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_set_rendering_quadrant_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_rendering_quadrant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rendering_quadrant_size")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_rendering_quadrant_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(TileMap.method_get_rendering_quadrant_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_layers_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layers_count")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of layers in the TileMap.
    public final func getLayersCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(TileMap.method_get_layers_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_layer")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a layer at the given position `toPosition` in the array. If `toPosition` is negative, the position is counted from the end, with `-1` adding the layer at the end of the array.
    public final func addLayer(toPosition: Int32) {
        withUnsafePointer(to: toPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_add_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_move_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_layer")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Moves the layer at index `layer` to the given position `toPosition` in the array.
    public final func moveLayer(_ layer: Int32, toPosition: Int32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: toPosition) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_move_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_layer")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the layer at index `layer`.
    public final func removeLayer(_ layer: Int32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_remove_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_layer_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_name")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets a layer's name. This is mostly useful in the editor.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerName(layer: Int32, name: String) {
        withUnsafePointer(to: layer) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layer_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_name")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns a TileMap layer's name.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getLayerName(layer: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_layer_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables or disables the layer `layer`. A disabled layer is not processed at all (no rendering, no physics, etc.).
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerEnabled(layer: Int32, enabled: Bool) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_layer_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_layer_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if a layer is enabled.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func isLayerEnabled(layer: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_is_layer_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_modulate")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets a layer's color. It will be multiplied by tile's color and TileMap's modulate.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerModulate(layer: Int32, modulate: Color) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: modulate) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_modulate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layer_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_modulate")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3457211756)!
            }
            
        }
        
    }()
    
    /// Returns a TileMap layer's modulate.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getLayerModulate(layer: Int32) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_modulate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_y_sort_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_y_sort_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables or disables a layer's Y-sorting. If a layer is Y-sorted, the layer will behave as a CanvasItem node where each of its tile gets Y-sorted.
    /// 
    /// Y-sorted layers should usually be on different Z-index values than not Y-sorted layers, otherwise, each of those layer will be Y-sorted as whole with the Y-sorted one. This is usually an undesired behavior.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerYSortEnabled(layer: Int32, ySortEnabled: Bool) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: ySortEnabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_y_sort_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_layer_y_sort_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_layer_y_sort_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if a layer Y-sorts its tiles.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func isLayerYSortEnabled(layer: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_is_layer_y_sort_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_y_sort_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_y_sort_origin")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets a layer's Y-sort origin value. This Y-sort origin value is added to each tile's Y-sort origin value.
    /// 
    /// This allows, for example, to fake a different height level on each layer. This can be useful for top-down view games.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerYSortOrigin(layer: Int32, ySortOrigin: Int32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: ySortOrigin) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_y_sort_origin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layer_y_sort_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_y_sort_origin")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns a TileMap layer's Y sort origin.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getLayerYSortOrigin(layer: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_y_sort_origin, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_z_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_z_index")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets a layers Z-index value. This Z-index is added to each tile's Z-index value.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerZIndex(layer: Int32, zIndex: Int32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: zIndex) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_z_index, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layer_z_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_z_index")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns a TileMap layer's Z-index value.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getLayerZIndex(layer: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_z_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_navigation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_navigation_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables or disables a layer's built-in navigation regions generation. Disable this if you need to bake navigation regions from a TileMap using a ``NavigationRegion2D`` node.
    public final func setLayerNavigationEnabled(layer: Int32, enabled: Bool) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_navigation_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_layer_navigation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_layer_navigation_enabled")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if a layer's built-in navigation regions generation is enabled.
    public final func isLayerNavigationEnabled(layer: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_is_layer_navigation_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_layer_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layer_navigation_map")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Assigns `map` as a ``NavigationServer2D`` navigation map for the specified TileMap layer `layer`.
    /// 
    /// By default the TileMap uses the default ``World2D`` navigation map for the first TileMap layer. For each additional TileMap layer a new navigation map is created for the additional layer.
    /// 
    /// In order to make ``NavigationAgent2D`` switch between TileMap layer navigation maps use ``NavigationAgent2D/setNavigationMap(_:)`` with the navigation map received from ``getLayerNavigationMap(layer:)``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setLayerNavigationMap(layer: Int32, map: RID) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: map.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_set_layer_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layer_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_navigation_map")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 495598643)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of the ``NavigationServer2D`` navigation map assigned to the specified TileMap layer `layer`.
    /// 
    /// By default the TileMap uses the default ``World2D`` navigation map for the first TileMap layer. For each additional TileMap layer a new navigation map is created for the additional layer.
    /// 
    /// In order to make ``NavigationAgent2D`` switch between TileMap layer navigation maps use ``NavigationAgent2D/setNavigationMap(_:)`` with the navigation map received from ``getLayerNavigationMap(layer:)``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getLayerNavigationMap(layer: Int32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_collision_animatable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_animatable")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_animatable(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_set_collision_animatable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_collision_animatable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_collision_animatable")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_collision_animatable() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMap.method_is_collision_animatable, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_visibility_mode")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3193440636)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_visibility_mode(_ collisionVisibilityMode: TileMap.VisibilityMode) {
        withUnsafePointer(to: collisionVisibilityMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_set_collision_visibility_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_visibility_mode")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1697018252)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_visibility_mode() -> TileMap.VisibilityMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TileMap.method_get_collision_visibility_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TileMap.VisibilityMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_navigation_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_visibility_mode")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3193440636)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_navigation_visibility_mode(_ navigationVisibilityMode: TileMap.VisibilityMode) {
        withUnsafePointer(to: navigationVisibilityMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_set_navigation_visibility_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_navigation_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_navigation_visibility_mode")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1697018252)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_navigation_visibility_mode() -> TileMap.VisibilityMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TileMap.method_get_navigation_visibility_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TileMap.VisibilityMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 966713560)!
            }
            
        }
        
    }()
    
    /// Sets the tile identifiers for the cell on layer `layer` at coordinates `coords`. Each tile of the ``TileSet`` is identified using three parts:
    /// 
    /// - The source identifier `sourceId` identifies a ``TileSetSource`` identifier. See ``TileSet/setSourceId(_:newSourceId:)``,
    /// 
    /// - The atlas coordinates identifier `atlasCoords` identifies a tile coordinates in the atlas (if the source is a ``TileSetAtlasSource``). For ``TileSetScenesCollectionSource`` it should always be `Vector2i(0, 0)`),
    /// 
    /// - The alternative tile identifier `alternativeTile` identifies a tile alternative in the atlas (if the source is a ``TileSetAtlasSource``), and the scene for a ``TileSetScenesCollectionSource``.
    /// 
    /// If `sourceId` is set to `-1`, `atlasCoords` to `Vector2i(-1, -1)` or `alternativeTile` to `-1`, the cell will be erased. An erased cell gets **all** its identifiers automatically set to their respective invalid values, namely `-1`, `Vector2i(-1, -1)` and `-1`.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setCell(layer: Int32, coords: Vector2i, sourceId: Int32 = -1, atlasCoords: Vector2i = Vector2i (x: -1, y: -1), alternativeTile: Int32 = 0) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: sourceId) { pArg2 in
                    withUnsafePointer(to: atlasCoords) { pArg3 in
                        withUnsafePointer(to: alternativeTile) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TileMap.method_set_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_erase_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("erase_cell")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2311374912)!
            }
            
        }
        
    }()
    
    /// Erases the cell on layer `layer` at coordinates `coords`.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func eraseCell(layer: Int32, coords: Vector2i) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_erase_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_cell_source_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_source_id")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 551761942)!
            }
            
        }
        
    }()
    
    /// Returns the tile source ID of the cell on layer `layer` at coordinates `coords`. Returns `-1` if the cell does not exist.
    /// 
    /// If `useProxies` is `false`, ignores the ``TileSet``'s tile proxies, returning the raw source identifier. See ``TileSet/mapTileProxy(sourceFrom:coordsFrom:alternativeFrom:)``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getCellSourceId(layer: Int32, coords: Vector2i, useProxies: Bool = false) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: useProxies) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_get_cell_source_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_atlas_coords: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_atlas_coords")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1869815066)!
            }
            
        }
        
    }()
    
    /// Returns the tile atlas coordinates ID of the cell on layer `layer` at coordinates `coords`. Returns `Vector2i(-1, -1)` if the cell does not exist.
    /// 
    /// If `useProxies` is `false`, ignores the ``TileSet``'s tile proxies, returning the raw atlas coordinate identifier. See ``TileSet/mapTileProxy(sourceFrom:coordsFrom:alternativeFrom:)``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getCellAtlasCoords(layer: Int32, coords: Vector2i, useProxies: Bool = false) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: useProxies) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_get_cell_atlas_coords, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_alternative_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_alternative_tile")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 551761942)!
            }
            
        }
        
    }()
    
    /// Returns the tile alternative ID of the cell on layer `layer` at `coords`.
    /// 
    /// If `useProxies` is `false`, ignores the ``TileSet``'s tile proxies, returning the raw alternative identifier. See ``TileSet/mapTileProxy(sourceFrom:coordsFrom:alternativeFrom:)``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getCellAlternativeTile(layer: Int32, coords: Vector2i, useProxies: Bool = false) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: useProxies) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_get_cell_alternative_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_tile_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_tile_data")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2849631287)!
            }
            
        }
        
    }()
    
    /// Returns the ``TileData`` object associated with the given cell, or `null` if the cell does not exist or is not a ``TileSetAtlasSource``.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    /// If `useProxies` is `false`, ignores the ``TileSet``'s tile proxies. See ``TileSet/mapTileProxy(sourceFrom:coordsFrom:alternativeFrom:)``.
    /// 
    public final func getCellTileData(layer: Int32, coords: Vector2i, useProxies: Bool = false) -> TileData? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: useProxies) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_get_cell_tile_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_coords_for_body_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_coords_for_body_rid")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 291584212)!
            }
            
        }
        
    }()
    
    /// Returns the coordinates of the tile for given physics body RID. Such RID can be retrieved from ``KinematicCollision2D/getColliderRid()``, when colliding with a tile.
    public final func getCoordsForBodyRid(body: RID) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: body.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_coords_for_body_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_layer_for_body_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layer_for_body_rid")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3917799429)!
            }
            
        }
        
    }()
    
    /// Returns the tilemap layer of the tile for given physics body RID. Such RID can be retrieved from ``KinematicCollision2D/getColliderRid()``, when colliding with a tile.
    public final func getLayerForBodyRid(body: RID) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: body.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_layer_for_body_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pattern")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2833570986)!
            }
            
        }
        
    }()
    
    /// Creates a new ``TileMapPattern`` from the given layer and set of cells.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getPattern(layer: Int32, coordsArray: VariantCollection<Vector2i>) -> TileMapPattern? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: coordsArray.array.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_get_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_map_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("map_pattern")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1864516957)!
            }
            
        }
        
    }()
    
    /// Returns for the given coordinate `coordsInPattern` in a ``TileMapPattern`` the corresponding cell coordinates if the pattern was pasted at the `positionInTilemap` coordinates (see ``setPattern(layer:position:pattern:)``). This mapping is required as in half-offset tile shapes, the mapping might not work by calculating `position_in_tile_map + coords_in_pattern`.
    public final func mapPattern(positionInTilemap: Vector2i, coordsInPattern: Vector2i, pattern: TileMapPattern?) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: positionInTilemap) { pArg0 in
            withUnsafePointer(to: coordsInPattern) { pArg1 in
                withUnsafePointer(to: pattern?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_map_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pattern")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1195853946)!
            }
            
        }
        
    }()
    
    /// Paste the given ``TileMapPattern`` at the given `position` and `layer` in the tile map.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func setPattern(layer: Int32, position: Vector2i, pattern: TileMapPattern?) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: pattern?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMap.method_set_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cells_terrain_connect: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cells_terrain_connect")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3578627656)!
            }
            
        }
        
    }()
    
    /// Update all the cells in the `cells` coordinates array so that they use the given `terrain` for the given `terrainSet`. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
    /// 
    /// If `ignoreEmptyTerrains` is true, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    /// > Note: To work correctly, this method requires the TileMap's TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
    /// 
    public final func setCellsTerrainConnect(layer: Int32, cells: VariantCollection<Vector2i>, terrainSet: Int32, terrain: Int32, ignoreEmptyTerrains: Bool = true) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: cells.array.content) { pArg1 in
                withUnsafePointer(to: terrainSet) { pArg2 in
                    withUnsafePointer(to: terrain) { pArg3 in
                        withUnsafePointer(to: ignoreEmptyTerrains) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TileMap.method_set_cells_terrain_connect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cells_terrain_path: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cells_terrain_path")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3578627656)!
            }
            
        }
        
    }()
    
    /// Update all the cells in the `path` coordinates array so that they use the given `terrain` for the given `terrainSet`. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
    /// 
    /// If `ignoreEmptyTerrains` is true, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    /// > Note: To work correctly, this method requires the TileMap's TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
    /// 
    public final func setCellsTerrainPath(layer: Int32, path: VariantCollection<Vector2i>, terrainSet: Int32, terrain: Int32, ignoreEmptyTerrains: Bool = true) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: path.array.content) { pArg1 in
                withUnsafePointer(to: terrainSet) { pArg2 in
                    withUnsafePointer(to: terrain) { pArg3 in
                        withUnsafePointer(to: ignoreEmptyTerrains) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TileMap.method_set_cells_terrain_path, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_fix_invalid_tiles: GDExtensionMethodBindPtr = {
        let methodName = StringName("fix_invalid_tiles")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears cells that do not exist in the tileset.
    public final func fixInvalidTiles() {
        gi.object_method_bind_ptrcall(TileMap.method_fix_invalid_tiles, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_clear_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_layer")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Clears all cells on the given layer.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func clearLayer(_ layer: Int32) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_clear_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all cells.
    public final func clear() {
        gi.object_method_bind_ptrcall(TileMap.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_update_internals: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_internals")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Triggers a direct update of the TileMap. Usually, calling this function is not needed, as TileMap node updates automatically when one of its properties or cells is modified.
    /// 
    /// However, for performance reasons, those updates are batched and delayed to the end of the frame. Calling this function will force the TileMap to update right away instead.
    /// 
    /// > Warning: Updating the TileMap is computationally expensive and may impact performance. Try to limit the number of updates and how many tiles they impact.
    /// 
    public final func updateInternals() {
        gi.object_method_bind_ptrcall(TileMap.method_update_internals, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_notify_runtime_tile_data_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("notify_runtime_tile_data_update")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Notifies the TileMap node that calls to ``_useTileDataRuntimeUpdate(layer:coords:)`` or ``_tileDataRuntimeUpdate(layer:coords:tileData:)`` will lead to different results. This will thus trigger a TileMap update.
    /// 
    /// If `layer` is provided, only notifies changes for the given layer. Providing the `layer` argument (when applicable) is usually preferred for performance reasons.
    /// 
    /// > Warning: Updating the TileMap is computationally expensive and may impact performance. Try to limit the number of calls to this function to avoid unnecessary update.
    /// 
    /// > Note: This does not trigger a direct update of the TileMap, the update will be done at the end of the frame as usual (unless you call ``updateInternals()``).
    /// 
    public final func notifyRuntimeTileDataUpdate(layer: Int32 = -1) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_notify_runtime_tile_data_update, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_surrounding_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_surrounding_cells")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2673526557)!
            }
            
        }
        
    }()
    
    /// Returns the list of all neighbourings cells to the one at `coords`.
    public final func getSurroundingCells(coords: Vector2i) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_surrounding_cells, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_used_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 663333327)!
            }
            
        }
        
    }()
    
    /// Returns a ``Vector2i`` array with the positions of all cells containing a tile in the given layer. A cell is considered empty if its source identifier equals -1, its atlas coordinates identifiers is `Vector2(-1, -1)` and its alternative identifier is -1.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getUsedCells(layer: Int32) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_get_used_cells, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_used_cells_by_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells_by_id")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2931012785)!
            }
            
        }
        
    }()
    
    /// Returns a ``Vector2i`` array with the positions of all cells containing a tile in the given layer. Tiles may be filtered according to their source (`sourceId`), their atlas coordinates (`atlasCoords`) or alternative id (`alternativeTile`).
    /// 
    /// If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default value, this method returns the same result as ``getUsedCells(layer:)``.
    /// 
    /// A cell is considered empty if its source identifier equals -1, its atlas coordinates identifiers is `Vector2(-1, -1)` and its alternative identifier is -1.
    /// 
    /// If `layer` is negative, the layers are accessed from the last one.
    /// 
    public final func getUsedCellsById(layer: Int32, sourceId: Int32 = -1, atlasCoords: Vector2i = Vector2i (x: -1, y: -1), alternativeTile: Int32 = -1) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: sourceId) { pArg1 in
                withUnsafePointer(to: atlasCoords) { pArg2 in
                    withUnsafePointer(to: alternativeTile) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TileMap.method_get_used_cells_by_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_used_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_rect")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 410525958)!
            }
            
        }
        
    }()
    
    /// Returns a rectangle enclosing the used (non-empty) tiles of the map, including all layers.
    public final func getUsedRect() -> Rect2i {
        var _result: Rect2i = Rect2i ()
        gi.object_method_bind_ptrcall(TileMap.method_get_used_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_map_to_local: GDExtensionMethodBindPtr = {
        let methodName = StringName("map_to_local")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 108438297)!
            }
            
        }
        
    }()
    
    /// Returns the centered position of a cell in the TileMap's local coordinate space. To convert the returned value into global coordinates, use ``Node2D/toGlobal(localPoint:)``. See also ``localToMap(localPosition:)``.
    /// 
    /// > Note: This may not correspond to the visual position of the tile, i.e. it ignores the ``TileData/textureOrigin`` property of individual tiles.
    /// 
    public final func mapToLocal(mapPosition: Vector2i) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: mapPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_map_to_local, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_local_to_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("local_to_map")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 837806996)!
            }
            
        }
        
    }()
    
    /// Returns the map coordinates of the cell containing the given `localPosition`. If `localPosition` is in global coordinates, consider using ``Node2D/toLocal(globalPoint:)`` before passing it to this method. See also ``mapToLocal(mapPosition:)``.
    public final func localToMap(localPosition: Vector2) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: localPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMap.method_local_to_map, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_neighbor_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_neighbor_cell")
        return withUnsafePointer(to: &TileMap.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 986575103)!
            }
            
        }
        
    }()
    
    /// Returns the neighboring cell to the one at coordinates `coords`, identified by the `neighbor` direction. This method takes into account the different layouts a TileMap can take.
    public final func getNeighborCell(coords: Vector2i, neighbor: TileSet.CellNeighbor) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: neighbor.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMap.method_get_neighbor_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_tile_data_runtime_update":
                return _TileMap_proxy_tile_data_runtime_update
            case "_use_tile_data_runtime_update":
                return _TileMap_proxy_use_tile_data_runtime_update
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when the ``TileSet`` of this TileMap changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.changed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var changed: SimpleSignal { SimpleSignal (target: self, signalName: "changed") }
    
}

// Support methods for proxies
func _TileMap_proxy_tile_data_runtime_update (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TileMap>.fromOpaque(instance).takeUnretainedValue()
    let resolved_2 = args [2]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._tileDataRuntimeUpdate (layer: args [0]!.assumingMemoryBound (to: Int32.self).pointee, coords: args [1]!.assumingMemoryBound (to: Vector2i.self).pointee, tileData: lookupLiveObject (handleAddress: resolved_2) as? TileData ?? TileData (nativeHandle: resolved_2))
}

func _TileMap_proxy_use_tile_data_runtime_update (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TileMap>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._useTileDataRuntimeUpdate (layer: args [0]!.assumingMemoryBound (to: Int32.self).pointee, coords: args [1]!.assumingMemoryBound (to: Vector2i.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

