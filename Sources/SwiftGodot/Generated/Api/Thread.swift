// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A unit of execution in a process.
/// 
/// A unit of execution in a process. Can run methods on ``Object``s simultaneously. The use of synchronization via ``Mutex`` or ``Semaphore`` is advised if working with shared objects.
/// 
/// > Warning:
/// 
/// To ensure proper cleanup without crashes or deadlocks, when a ``Thread``'s reference count reaches zero and it is therefore destroyed, the following conditions must be met:
/// 
/// - It must not have any ``Mutex`` objects locked.
/// 
/// - It must not be waiting on any ``Semaphore`` objects.
/// 
/// - ``waitToFinish()`` should have been called on it.
/// 
open class Thread: RefCounted {
    override open class var godotClassName: StringName { "Thread" }
    public enum Priority: Int64, CaseIterable, CustomDebugStringConvertible {
        /// A thread running with lower priority than normally.
        case low = 0 // PRIORITY_LOW
        /// A thread with a standard priority.
        case normal = 1 // PRIORITY_NORMAL
        /// A thread running with higher priority than normally.
        case high = 2 // PRIORITY_HIGH
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .low: return ".low"
                case .normal: return ".normal"
                case .high: return ".high"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_start: GDExtensionMethodBindPtr = {
        let methodName = StringName("start")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1327203254)!
            }
            
        }
        
    }()
    
    /// Starts a new ``Thread`` that calls `callable`.
    /// 
    /// If the method takes some arguments, you can pass them using ``Callable/bind()``.
    /// 
    /// The `priority` of the ``Thread`` can be changed by passing a value from the ``Thread/Priority`` enum.
    /// 
    /// Returns ``GodotError/ok`` on success, or ``GodotError/errCantCreate`` on failure.
    /// 
    public final func start(callable: Callable, priority: Thread.Priority = .normal) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: callable.content) { pArg0 in
            withUnsafePointer(to: priority.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Thread.method_start, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_get_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_id")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the current ``Thread``'s ID, uniquely identifying it among all threads. If the ``Thread`` has not started running or if ``waitToFinish()`` has been called, this returns an empty string.
    public final func getId() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Thread.method_get_id, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_is_started: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_started")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this ``Thread`` has been started. Once started, this will return `true` until it is joined using ``waitToFinish()``. For checking if a ``Thread`` is still executing its task, use ``isAlive()``.
    public final func isStarted() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Thread.method_is_started, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_alive: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_alive")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this ``Thread`` is currently running the provided function. This is useful for determining if ``waitToFinish()`` can be called without blocking the calling thread.
    /// 
    /// To check if a ``Thread`` is joinable, use ``isStarted()``.
    /// 
    public final func isAlive() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Thread.method_is_alive, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_wait_to_finish: GDExtensionMethodBindPtr = {
        let methodName = StringName("wait_to_finish")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1460262497)!
            }
            
        }
        
    }()
    
    /// Joins the ``Thread`` and waits for it to finish. Returns the output of the ``Callable`` passed to ``start(callable:priority:)``.
    /// 
    /// Should either be used when you want to retrieve the value returned from the method called by the ``Thread`` or before freeing the instance that contains the ``Thread``.
    /// 
    /// To determine if this can be called without blocking the calling thread, check if ``isAlive()`` is `false`.
    /// 
    public final func waitToFinish() -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        gi.object_method_bind_ptrcall(Thread.method_wait_to_finish, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_set_thread_safety_checks_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_thread_safety_checks_enabled")
        return withUnsafePointer(to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets whether the thread safety checks the engine normally performs in methods of certain classes (e.g., ``Node``) should happen **on the current thread**.
    /// 
    /// The default, for every thread, is that they are enabled (as if called with `enabled` being `true`).
    /// 
    /// Those checks are conservative. That means that they will only succeed in considering a call thread-safe (and therefore allow it to happen) if the engine can guarantee such safety.
    /// 
    /// Because of that, there may be cases where the user may want to disable them (`enabled` being `false`) to make certain operations allowed again. By doing so, it becomes the user's responsibility to ensure thread safety (e.g., by using ``Mutex``) for those objects that are otherwise protected by the engine.
    /// 
    /// > Note: This is an advanced usage of the engine. You are advised to use it only if you know what you are doing and there is no safer way.
    /// 
    /// > Note: This is useful for scripts running on either arbitrary ``Thread`` objects or tasks submitted to the ``WorkerThreadPool``. It doesn't apply to code running during ``Node`` group processing, where the checks will be always performed.
    /// 
    /// > Note: Even in the case of having disabled the checks in a ``WorkerThreadPool`` task, there's no need to re-enable them at the end. The engine will do so.
    /// 
    public static func setThreadSafetyChecksEnabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_set_thread_safety_checks_enabled, nil, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
}

