// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Image datatype.
/// 
/// Native image datatype. Contains image data which can be converted to an ``ImageTexture`` and provides commonly used _image processing_ methods. The maximum width and height for an ``Image`` are ``maxWidth`` and ``maxHeight``.
/// 
/// An ``Image`` cannot be assigned to a texture property of an object directly (such as ``Sprite2D/texture``), and has to be converted manually to an ``ImageTexture`` first.
/// 
/// > Note: The maximum image size is 16384×16384 pixels due to graphics hardware limitations. Larger images may fail to import.
/// 
open class Image: Resource {
    override open class var godotClassName: StringName { "Image" }
    public enum Format: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Texture format with a single 8-bit depth representing luminance.
        case l8 = 0 // FORMAT_L8
        /// OpenGL texture format with two values, luminance and alpha each stored with 8 bits.
        case la8 = 1 // FORMAT_LA8
        /// OpenGL texture format `RED` with a single component and a bitdepth of 8.
        case r8 = 2 // FORMAT_R8
        /// OpenGL texture format `RG` with two components and a bitdepth of 8 for each.
        case rg8 = 3 // FORMAT_RG8
        /// OpenGL texture format `RGB` with three components, each with a bitdepth of 8.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case rgb8 = 4 // FORMAT_RGB8
        /// OpenGL texture format `RGBA` with four components, each with a bitdepth of 8.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case rgba8 = 5 // FORMAT_RGBA8
        /// OpenGL texture format `RGBA` with four components, each with a bitdepth of 4.
        case rgba4444 = 6 // FORMAT_RGBA4444
        /// OpenGL texture format `RGB` with three components. Red and blue have a bitdepth of 5, and green has a bitdepth of 6.
        case rgb565 = 7 // FORMAT_RGB565
        /// OpenGL texture format `GL_R32F` where there's one component, a 32-bit floating-point value.
        case rf = 8 // FORMAT_RF
        /// OpenGL texture format `GL_RG32F` where there are two components, each a 32-bit floating-point values.
        case rgf = 9 // FORMAT_RGF
        /// OpenGL texture format `GL_RGB32F` where there are three components, each a 32-bit floating-point values.
        case rgbf = 10 // FORMAT_RGBF
        /// OpenGL texture format `GL_RGBA32F` where there are four components, each a 32-bit floating-point values.
        case rgbaf = 11 // FORMAT_RGBAF
        /// OpenGL texture format `GL_R16F` where there's one component, a 16-bit "half-precision" floating-point value.
        case rh = 12 // FORMAT_RH
        /// OpenGL texture format `GL_RG16F` where there are two components, each a 16-bit "half-precision" floating-point value.
        case rgh = 13 // FORMAT_RGH
        /// OpenGL texture format `GL_RGB16F` where there are three components, each a 16-bit "half-precision" floating-point value.
        case rgbh = 14 // FORMAT_RGBH
        /// OpenGL texture format `GL_RGBA16F` where there are four components, each a 16-bit "half-precision" floating-point value.
        case rgbah = 15 // FORMAT_RGBAH
        /// A special OpenGL texture format where the three color components have 9 bits of precision and all three share a single 5-bit exponent.
        case rgbe9995 = 16 // FORMAT_RGBE9995
        /// The <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">S3TC</a> texture format that uses Block Compression 1, and is the smallest variation of S3TC, only providing 1 bit of alpha and color data being premultiplied with alpha.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case dxt1 = 17 // FORMAT_DXT1
        /// The <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">S3TC</a> texture format that uses Block Compression 2, and color data is interpreted as not having been premultiplied by alpha. Well suited for images with sharp alpha transitions between translucent and opaque areas.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case dxt3 = 18 // FORMAT_DXT3
        /// The <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">S3TC</a> texture format also known as Block Compression 3 or BC3 that contains 64 bits of alpha channel data followed by 64 bits of DXT1-encoded color data. Color data is not premultiplied by alpha, same as DXT3. DXT5 generally produces superior results for transparent gradients compared to DXT3.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case dxt5 = 19 // FORMAT_DXT5
        /// Texture format that uses <a href="https://www.khronos.org/opengl/wiki/Red_Green_Texture_Compression">Red Green Texture Compression</a>, normalizing the red channel data using the same compression algorithm that DXT5 uses for the alpha channel.
        case rgtcR = 20 // FORMAT_RGTC_R
        /// Texture format that uses <a href="https://www.khronos.org/opengl/wiki/Red_Green_Texture_Compression">Red Green Texture Compression</a>, normalizing the red and green channel data using the same compression algorithm that DXT5 uses for the alpha channel.
        case rgtcRg = 21 // FORMAT_RGTC_RG
        /// Texture format that uses <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression">BPTC</a> compression with unsigned normalized RGBA components.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case bptcRgba = 22 // FORMAT_BPTC_RGBA
        /// Texture format that uses <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression">BPTC</a> compression with signed floating-point RGB components.
        case bptcRgbf = 23 // FORMAT_BPTC_RGBF
        /// Texture format that uses <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression">BPTC</a> compression with unsigned floating-point RGB components.
        case bptcRgbfu = 24 // FORMAT_BPTC_RGBFU
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC1">Ericsson Texture Compression format 1</a>, also referred to as "ETC1", and is part of the OpenGL ES graphics standard. This format cannot store an alpha channel.
        case etc = 25 // FORMAT_ETC
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`R11_EAC` variant), which provides one channel of unsigned data.
        case etc2R11 = 26 // FORMAT_ETC2_R11
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`SIGNED_R11_EAC` variant), which provides one channel of signed data.
        case etc2R11s = 27 // FORMAT_ETC2_R11S
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`RG11_EAC` variant), which provides two channels of unsigned data.
        case etc2Rg11 = 28 // FORMAT_ETC2_RG11
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`SIGNED_RG11_EAC` variant), which provides two channels of signed data.
        case etc2Rg11s = 29 // FORMAT_ETC2_RG11S
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`RGB8` variant), which is a follow-up of ETC1 and compresses RGB888 data.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case etc2Rgb8 = 30 // FORMAT_ETC2_RGB8
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`RGBA8`variant), which compresses RGBA8888 data with full alpha support.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case etc2Rgba8 = 31 // FORMAT_ETC2_RGBA8
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`RGB8_PUNCHTHROUGH_ALPHA1` variant), which compresses RGBA data to make alpha either fully transparent or fully opaque.
        /// 
        /// > Note: When creating an ``ImageTexture``, an sRGB to linear color space conversion is performed.
        /// 
        case etc2Rgb8a1 = 32 // FORMAT_ETC2_RGB8A1
        /// <a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC">Ericsson Texture Compression format 2</a> (`RGBA8` variant), which compresses RA data and interprets it as two channels (red and green). See also ``Format/etc2Rgba8``.
        case etc2RaAsRg = 33 // FORMAT_ETC2_RA_AS_RG
        /// The <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">S3TC</a> texture format also known as Block Compression 3 or BC3, which compresses RA data and interprets it as two channels (red and green). See also ``Format/dxt5``.
        case dxt5RaAsRg = 34 // FORMAT_DXT5_RA_AS_RG
        /// <a href="https://en.wikipedia.org/wiki/Adaptive_scalable_texture_compression">Adaptive Scalable Texture Compression</a>. This implements the 4×4 (high quality) mode.
        case astc4x4 = 35 // FORMAT_ASTC_4x4
        /// Same format as ``Format/astc4x4``, but with the hint to let the GPU know it is used for HDR.
        case astc4x4Hdr = 36 // FORMAT_ASTC_4x4_HDR
        /// <a href="https://en.wikipedia.org/wiki/Adaptive_scalable_texture_compression">Adaptive Scalable Texture Compression</a>. This implements the 8×8 (low quality) mode.
        case astc8x8 = 37 // FORMAT_ASTC_8x8
        /// Same format as ``Format/astc8x8``, but with the hint to let the GPU know it is used for HDR.
        case astc8x8Hdr = 38 // FORMAT_ASTC_8x8_HDR
        /// Represents the size of the ``Image/Format`` enum.
        case max = 39 // FORMAT_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .l8: return ".l8"
                case .la8: return ".la8"
                case .r8: return ".r8"
                case .rg8: return ".rg8"
                case .rgb8: return ".rgb8"
                case .rgba8: return ".rgba8"
                case .rgba4444: return ".rgba4444"
                case .rgb565: return ".rgb565"
                case .rf: return ".rf"
                case .rgf: return ".rgf"
                case .rgbf: return ".rgbf"
                case .rgbaf: return ".rgbaf"
                case .rh: return ".rh"
                case .rgh: return ".rgh"
                case .rgbh: return ".rgbh"
                case .rgbah: return ".rgbah"
                case .rgbe9995: return ".rgbe9995"
                case .dxt1: return ".dxt1"
                case .dxt3: return ".dxt3"
                case .dxt5: return ".dxt5"
                case .rgtcR: return ".rgtcR"
                case .rgtcRg: return ".rgtcRg"
                case .bptcRgba: return ".bptcRgba"
                case .bptcRgbf: return ".bptcRgbf"
                case .bptcRgbfu: return ".bptcRgbfu"
                case .etc: return ".etc"
                case .etc2R11: return ".etc2R11"
                case .etc2R11s: return ".etc2R11s"
                case .etc2Rg11: return ".etc2Rg11"
                case .etc2Rg11s: return ".etc2Rg11s"
                case .etc2Rgb8: return ".etc2Rgb8"
                case .etc2Rgba8: return ".etc2Rgba8"
                case .etc2Rgb8a1: return ".etc2Rgb8a1"
                case .etc2RaAsRg: return ".etc2RaAsRg"
                case .dxt5RaAsRg: return ".dxt5RaAsRg"
                case .astc4x4: return ".astc4x4"
                case .astc4x4Hdr: return ".astc4x4Hdr"
                case .astc8x8: return ".astc8x8"
                case .astc8x8Hdr: return ".astc8x8Hdr"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum Interpolation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Performs nearest-neighbor interpolation. If the image is resized, it will be pixelated.
        case nearest = 0 // INTERPOLATE_NEAREST
        /// Performs bilinear interpolation. If the image is resized, it will be blurry. This mode is faster than ``Interpolation/cubic``, but it results in lower quality.
        case bilinear = 1 // INTERPOLATE_BILINEAR
        /// Performs cubic interpolation. If the image is resized, it will be blurry. This mode often gives better results compared to ``Interpolation/bilinear``, at the cost of being slower.
        case cubic = 2 // INTERPOLATE_CUBIC
        /// Performs bilinear separately on the two most-suited mipmap levels, then linearly interpolates between them.
        /// 
        /// It's slower than ``Interpolation/bilinear``, but produces higher-quality results with far fewer aliasing artifacts.
        /// 
        /// If the image does not have mipmaps, they will be generated and used internally, but no mipmaps will be generated on the resulting image.
        /// 
        /// > Note: If you intend to scale multiple copies of the original image, it's better to call ``generateMipmaps(renormalize:)``] on it in advance, to avoid wasting processing power in generating them again and again.
        /// 
        /// On the other hand, if the image already has mipmaps, they will be used, and a new set will be generated for the resulting image.
        /// 
        case trilinear = 3 // INTERPOLATE_TRILINEAR
        /// Performs Lanczos interpolation. This is the slowest image resizing mode, but it typically gives the best results, especially when downscaling images.
        case lanczos = 4 // INTERPOLATE_LANCZOS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .nearest: return ".nearest"
                case .bilinear: return ".bilinear"
                case .cubic: return ".cubic"
                case .trilinear: return ".trilinear"
                case .lanczos: return ".lanczos"
            }
            
        }
        
    }
    
    public enum AlphaMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Image does not have alpha.
        case none = 0 // ALPHA_NONE
        /// Image stores alpha in a single bit.
        case bit = 1 // ALPHA_BIT
        /// Image uses alpha.
        case blend = 2 // ALPHA_BLEND
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .bit: return ".bit"
                case .blend: return ".blend"
            }
            
        }
        
    }
    
    public enum CompressMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Use S3TC compression.
        case s3tc = 0 // COMPRESS_S3TC
        /// Use ETC compression.
        case etc = 1 // COMPRESS_ETC
        /// Use ETC2 compression.
        case etc2 = 2 // COMPRESS_ETC2
        /// Use BPTC compression.
        case bptc = 3 // COMPRESS_BPTC
        /// Use ASTC compression.
        case astc = 4 // COMPRESS_ASTC
        /// Represents the size of the ``Image/CompressMode`` enum.
        case max = 5 // COMPRESS_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .s3tc: return ".s3tc"
                case .etc: return ".etc"
                case .etc2: return ".etc2"
                case .bptc: return ".bptc"
                case .astc: return ".astc"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum UsedChannels: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The image only uses one channel for luminance (grayscale).
        case l = 0 // USED_CHANNELS_L
        /// The image uses two channels for luminance and alpha, respectively.
        case la = 1 // USED_CHANNELS_LA
        /// The image only uses the red channel.
        case r = 2 // USED_CHANNELS_R
        /// The image uses two channels for red and green.
        case rg = 3 // USED_CHANNELS_RG
        /// The image uses three channels for red, green, and blue.
        case rgb = 4 // USED_CHANNELS_RGB
        /// The image uses four channels for red, green, blue, and alpha.
        case rgba = 5 // USED_CHANNELS_RGBA
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .l: return ".l"
                case .la: return ".la"
                case .r: return ".r"
                case .rg: return ".rg"
                case .rgb: return ".rgb"
                case .rgba: return ".rgba"
            }
            
        }
        
    }
    
    public enum CompressSource: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Source texture (before compression) is a regular texture. Default for all textures.
        case generic = 0 // COMPRESS_SOURCE_GENERIC
        /// Source texture (before compression) is in sRGB space.
        case srgb = 1 // COMPRESS_SOURCE_SRGB
        /// Source texture (before compression) is a normal texture (e.g. it can be compressed into two channels).
        case normal = 2 // COMPRESS_SOURCE_NORMAL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .generic: return ".generic"
                case .srgb: return ".srgb"
                case .normal: return ".normal"
            }
            
        }
        
    }
    
    public enum ASTCFormat: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Hint to indicate that the high quality 4×4 ASTC compression format should be used.
        case astcFormat4x4 = 0 // ASTC_FORMAT_4x4
        /// Hint to indicate that the low quality 8×8 ASTC compression format should be used.
        case astcFormat8x8 = 1 // ASTC_FORMAT_8x8
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .astcFormat4x4: return ".astcFormat4x4"
                case .astcFormat8x8: return ".astcFormat8x8"
            }
            
        }
        
    }
    
    /* Constants */
    /// The maximal width allowed for ``Image`` resources.
    public static let maxWidth = 16777216
    /// The maximal height allowed for ``Image`` resources.
    public static let maxHeight = 16777216
    
    /* Properties */
    
    /* Methods */
    fileprivate static var method_get_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_width")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the image's width.
    public final func getWidth() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Image.method_get_width, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_height: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_height")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the image's height.
    public final func getHeight() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Image.method_get_height, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_size")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the image's size (width and height).
    public final func getSize() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(Image.method_get_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_mipmaps")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the image has generated mipmaps.
    public final func hasMipmaps() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Image.method_has_mipmaps, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_format: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_format")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3847873762)!
            }
            
        }
        
    }()
    
    /// Returns the image's format. See ``Image/Format`` constants.
    public final func getFormat() -> Image.Format {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Image.method_get_format, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Image.Format (rawValue: _result)!
    }
    
    fileprivate static var method_get_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_data")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2362200018)!
            }
            
        }
        
    }()
    
    /// Returns a copy of the image's raw data.
    public final func getData() -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        gi.object_method_bind_ptrcall(Image.method_get_data, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_data_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_data_size")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns size (in bytes) of the image's raw data.
    public final func getDataSize() -> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall(Image.method_get_data_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_convert: GDExtensionMethodBindPtr = {
        let methodName = StringName("convert")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2120693146)!
            }
            
        }
        
    }()
    
    /// Converts the image's format. See ``Image/Format`` constants.
    public final func convert(format: Image.Format) {
        withUnsafePointer(to: format.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_convert, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mipmap_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mipmap_count")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of mipmap levels or 0 if the image has no mipmaps. The largest main level image is not counted as a mipmap level by this method, so if you want to include it you can add 1 to this count.
    public final func getMipmapCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Image.method_get_mipmap_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_mipmap_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mipmap_offset")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the offset where the image's mipmap with index `mipmap` is stored in the ``data`` dictionary.
    public final func getMipmapOffset(mipmap: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: mipmap) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_get_mipmap_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_resize_to_po2: GDExtensionMethodBindPtr = {
        let methodName = StringName("resize_to_po2")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4189212329)!
            }
            
        }
        
    }()
    
    /// Resizes the image to the nearest power of 2 for the width and height. If `square` is `true` then set width and height to be the same. New pixels are calculated using the `interpolation` mode defined via ``Image/Interpolation`` constants.
    public final func resizeToPo2(square: Bool = false, interpolation: Image.Interpolation = .bilinear) {
        withUnsafePointer(to: square) { pArg0 in
            withUnsafePointer(to: interpolation.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_resize_to_po2, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_resize: GDExtensionMethodBindPtr = {
        let methodName = StringName("resize")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 994498151)!
            }
            
        }
        
    }()
    
    /// Resizes the image to the given `width` and `height`. New pixels are calculated using the `interpolation` mode defined via ``Image/Interpolation`` constants.
    public final func resize(width: Int32, height: Int32, interpolation: Image.Interpolation = .bilinear) {
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: interpolation.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_resize, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shrink_x2: GDExtensionMethodBindPtr = {
        let methodName = StringName("shrink_x2")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Shrinks the image by a factor of 2 on each axis (this divides the pixel count by 4).
    public final func shrinkX2() {
        gi.object_method_bind_ptrcall(Image.method_shrink_x2, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_crop: GDExtensionMethodBindPtr = {
        let methodName = StringName("crop")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Crops the image to the given `width` and `height`. If the specified size is larger than the current size, the extra area is filled with black pixels.
    public final func crop(width: Int32, height: Int32) {
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_crop, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_flip_x: GDExtensionMethodBindPtr = {
        let methodName = StringName("flip_x")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Flips the image horizontally.
    public final func flipX() {
        gi.object_method_bind_ptrcall(Image.method_flip_x, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_flip_y: GDExtensionMethodBindPtr = {
        let methodName = StringName("flip_y")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Flips the image vertically.
    public final func flipY() {
        gi.object_method_bind_ptrcall(Image.method_flip_y, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_generate_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("generate_mipmaps")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1633102583)!
            }
            
        }
        
    }()
    
    /// Generates mipmaps for the image. Mipmaps are precalculated lower-resolution copies of the image that are automatically used if the image needs to be scaled down when rendered. They help improve image quality and performance when rendering. This method returns an error if the image is compressed, in a custom format, or if the image's width/height is `0`. Enabling `renormalize` when generating mipmaps for normal map textures will make sure all resulting vector values are normalized.
    /// 
    /// It is possible to check if the image has mipmaps by calling ``hasMipmaps()`` or ``getMipmapCount()``. Calling ``generateMipmaps(renormalize:)`` on an image that already has mipmaps will replace existing mipmaps in the image.
    /// 
    public final func generateMipmaps(renormalize: Bool = false) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: renormalize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_generate_mipmaps, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_clear_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_mipmaps")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes the image's mipmaps.
    public final func clearMipmaps() {
        gi.object_method_bind_ptrcall(Image.method_clear_mipmaps, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("create")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 986942177)!
            }
            
        }
        
    }()
    
    /// Creates an empty image of given size and format. See ``Image/Format`` constants. If `useMipmaps` is `true`, then generate mipmaps for this image. See the ``generateMipmaps(renormalize:)``.
    public static func create(width: Int32, height: Int32, useMipmaps: Bool, format: Image.Format) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: useMipmaps) { pArg2 in
                    withUnsafePointer(to: format.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(method_create, nil, pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_empty: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_empty")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 986942177)!
            }
            
        }
        
    }()
    
    /// Creates an empty image of given size and format. See ``Image/Format`` constants. If `useMipmaps` is `true`, then generate mipmaps for this image. See the ``generateMipmaps(renormalize:)``.
    public static func createEmpty(width: Int32, height: Int32, useMipmaps: Bool, format: Image.Format) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: useMipmaps) { pArg2 in
                    withUnsafePointer(to: format.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(method_create_empty, nil, pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_from_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_from_data")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 299398494)!
            }
            
        }
        
    }()
    
    /// Creates a new image of given size and format. See ``Image/Format`` constants. Fills the image with the given raw data. If `useMipmaps` is `true` then loads mipmaps for this image from `data`. See ``generateMipmaps(renormalize:)``.
    public static func createFromData(width: Int32, height: Int32, useMipmaps: Bool, format: Image.Format, data: PackedByteArray) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: useMipmaps) { pArg2 in
                    withUnsafePointer(to: format.rawValue) { pArg3 in
                        withUnsafePointer(to: data.content) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(method_create_from_data, nil, pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_data")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2740482212)!
            }
            
        }
        
    }()
    
    /// Overwrites data of an existing ``Image``. Non-static equivalent of ``createFromData(width:height:useMipmaps:format:data:)``.
    public final func setData(width: Int32, height: Int32, useMipmaps: Bool, format: Image.Format, data: PackedByteArray) {
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: height) { pArg1 in
                withUnsafePointer(to: useMipmaps) { pArg2 in
                    withUnsafePointer(to: format.rawValue) { pArg3 in
                        withUnsafePointer(to: data.content) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(Image.method_set_data, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_empty: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_empty")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the image has no data.
    public final func isEmpty() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Image.method_is_empty, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_load: GDExtensionMethodBindPtr = {
        let methodName = StringName("load")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166001499)!
            }
            
        }
        
    }()
    
    /// Loads an image from file `path`. See <a href="https://docs.godotengine.org/en//tutorials/assets_pipeline/importing_images.html#supported-image-formats">Supported image formats</a> for a list of supported image formats and limitations.
    /// 
    /// > Warning: This method should only be used in the editor or in cases when you need to load external images at run-time, such as images located at the `user://` directory, and may not work in exported projects.
    /// 
    /// See also ``ImageTexture`` description for usage examples.
    /// 
    public final func load(path: String) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_from_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_from_file")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 736337515)!
            }
            
        }
        
    }()
    
    /// Creates a new ``Image`` and loads data from the specified file.
    public static func loadFromFile(path: String) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_load_from_file, nil, pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_save_png: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_png")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2113323047)!
            }
            
        }
        
    }()
    
    /// Saves the image as a PNG file to the file at `path`.
    public final func savePng(path: String) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_save_png, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_save_png_to_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_png_to_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2362200018)!
            }
            
        }
        
    }()
    
    /// Saves the image as a PNG file to a byte array.
    public final func savePngToBuffer() -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        gi.object_method_bind_ptrcall(Image.method_save_png_to_buffer, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_save_jpg: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_jpg")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2800019068)!
            }
            
        }
        
    }()
    
    /// Saves the image as a JPEG file to `path` with the specified `quality` between `0.01` and `1.0` (inclusive). Higher `quality` values result in better-looking output at the cost of larger file sizes. Recommended `quality` values are between `0.75` and `0.90`. Even at quality `1.00`, JPEG compression remains lossy.
    /// 
    /// > Note: JPEG does not save an alpha channel. If the ``Image`` contains an alpha channel, the image will still be saved, but the resulting JPEG file won't contain the alpha channel.
    /// 
    public final func saveJpg(path: String, quality: Double = 0.75) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: quality) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_save_jpg, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_save_jpg_to_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_jpg_to_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 592235273)!
            }
            
        }
        
    }()
    
    /// Saves the image as a JPEG file to a byte array with the specified `quality` between `0.01` and `1.0` (inclusive). Higher `quality` values result in better-looking output at the cost of larger byte array sizes (and therefore memory usage). Recommended `quality` values are between `0.75` and `0.90`. Even at quality `1.00`, JPEG compression remains lossy.
    /// 
    /// > Note: JPEG does not save an alpha channel. If the ``Image`` contains an alpha channel, the image will still be saved, but the resulting byte array won't contain the alpha channel.
    /// 
    public final func saveJpgToBuffer(quality: Double = 0.75) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: quality) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_save_jpg_to_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_save_exr: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_exr")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3108122999)!
            }
            
        }
        
    }()
    
    /// Saves the image as an EXR file to `path`. If `grayscale` is `true` and the image has only one channel, it will be saved explicitly as monochrome rather than one red channel. This function will return ``GodotError/errUnavailable`` if Godot was compiled without the TinyEXR module.
    /// 
    /// > Note: The TinyEXR module is disabled in non-editor builds, which means ``saveExr(path:grayscale:)`` will return ``GodotError/errUnavailable`` when it is called from an exported project.
    /// 
    public final func saveExr(path: String, grayscale: Bool = false) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: grayscale) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_save_exr, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_save_exr_to_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_exr_to_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3178917920)!
            }
            
        }
        
    }()
    
    /// Saves the image as an EXR file to a byte array. If `grayscale` is `true` and the image has only one channel, it will be saved explicitly as monochrome rather than one red channel. This function will return an empty byte array if Godot was compiled without the TinyEXR module.
    /// 
    /// > Note: The TinyEXR module is disabled in non-editor builds, which means ``saveExr(path:grayscale:)`` will return an empty byte array when it is called from an exported project.
    /// 
    public final func saveExrToBuffer(grayscale: Bool = false) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: grayscale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_save_exr_to_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_save_webp: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_webp")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2781156876)!
            }
            
        }
        
    }()
    
    /// Saves the image as a WebP (Web Picture) file to the file at `path`. By default it will save lossless. If `lossy` is true, the image will be saved lossy, using the `quality` setting between 0.0 and 1.0 (inclusive). Lossless WebP offers more efficient compression than PNG.
    /// 
    /// > Note: The WebP format is limited to a size of 16383×16383 pixels, while PNG can save larger images.
    /// 
    public final func saveWebp(path: String, lossy: Bool = false, quality: Double = 0.75) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: lossy) { pArg1 in
                withUnsafePointer(to: quality) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_save_webp, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_save_webp_to_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_webp_to_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1214628238)!
            }
            
        }
        
    }()
    
    /// Saves the image as a WebP (Web Picture) file to a byte array. By default it will save lossless. If `lossy` is true, the image will be saved lossy, using the `quality` setting between 0.0 and 1.0 (inclusive). Lossless WebP offers more efficient compression than PNG.
    /// 
    /// > Note: The WebP format is limited to a size of 16383×16383 pixels, while PNG can save larger images.
    /// 
    public final func saveWebpToBuffer(lossy: Bool = false, quality: Double = 0.75) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: lossy) { pArg0 in
            withUnsafePointer(to: quality) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_save_webp_to_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_detect_alpha: GDExtensionMethodBindPtr = {
        let methodName = StringName("detect_alpha")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2030116505)!
            }
            
        }
        
    }()
    
    /// Returns ``AlphaMode/blend`` if the image has data for alpha values. Returns ``AlphaMode/bit`` if all the alpha values are stored in a single bit. Returns ``AlphaMode/none`` if no data for alpha values is found.
    public final func detectAlpha() -> Image.AlphaMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Image.method_detect_alpha, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Image.AlphaMode (rawValue: _result)!
    }
    
    fileprivate static var method_is_invisible: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_invisible")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if all the image's pixels have an alpha value of 0. Returns `false` if any pixel has an alpha value higher than 0.
    public final func isInvisible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Image.method_is_invisible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_detect_used_channels: GDExtensionMethodBindPtr = {
        let methodName = StringName("detect_used_channels")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2703139984)!
            }
            
        }
        
    }()
    
    /// Returns the color channels used by this image, as one of the ``Image/UsedChannels`` constants. If the image is compressed, the original `source` must be specified.
    public final func detectUsedChannels(source: Image.CompressSource = .generic) -> Image.UsedChannels {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: source.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_detect_used_channels, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Image.UsedChannels (rawValue: _result)!
    }
    
    fileprivate static var method_compress: GDExtensionMethodBindPtr = {
        let methodName = StringName("compress")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2975424957)!
            }
            
        }
        
    }()
    
    /// Compresses the image to use less memory. Can not directly access pixel data while the image is compressed. Returns error if the chosen compression mode is not available.
    /// 
    /// The `source` parameter helps to pick the best compression method for DXT and ETC2 formats. It is ignored for ASTC compression.
    /// 
    /// For ASTC compression, the `astcFormat` parameter must be supplied.
    /// 
    public final func compress(mode: Image.CompressMode, source: Image.CompressSource = .generic, astcFormat: Image.ASTCFormat = .astcFormat4x4) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: source.rawValue) { pArg1 in
                withUnsafePointer(to: astcFormat.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_compress, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_compress_from_channels: GDExtensionMethodBindPtr = {
        let methodName = StringName("compress_from_channels")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4212890953)!
            }
            
        }
        
    }()
    
    /// Compresses the image to use less memory. Can not directly access pixel data while the image is compressed. Returns error if the chosen compression mode is not available.
    /// 
    /// This is an alternative to ``compress(mode:source:astcFormat:)`` that lets the user supply the channels used in order for the compressor to pick the best DXT and ETC2 formats. For other formats (non DXT or ETC2), this argument is ignored.
    /// 
    /// For ASTC compression, the `astcFormat` parameter must be supplied.
    /// 
    public final func compressFromChannels(mode: Image.CompressMode, channels: Image.UsedChannels, astcFormat: Image.ASTCFormat = .astcFormat4x4) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: channels.rawValue) { pArg1 in
                withUnsafePointer(to: astcFormat.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_compress_from_channels, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_decompress: GDExtensionMethodBindPtr = {
        let methodName = StringName("decompress")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Decompresses the image if it is VRAM compressed in a supported format. Returns ``GodotError/ok`` if the format is supported, otherwise ``GodotError/errUnavailable``.
    /// 
    /// > Note: The following formats can be decompressed: DXT, RGTC, BPTC. The formats ETC1 and ETC2 are not supported.
    /// 
    public final func decompress() -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Image.method_decompress, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_is_compressed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_compressed")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the image is compressed.
    public final func isCompressed() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Image.method_is_compressed, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_rotate_90: GDExtensionMethodBindPtr = {
        let methodName = StringName("rotate_90")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1901204267)!
            }
            
        }
        
    }()
    
    /// Rotates the image in the specified `direction` by `90` degrees. The width and height of the image must be greater than `1`. If the width and height are not equal, the image will be resized.
    public final func rotate90(direction: ClockDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_rotate_90, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_rotate_180: GDExtensionMethodBindPtr = {
        let methodName = StringName("rotate_180")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Rotates the image by `180` degrees. The width and height of the image must be greater than `1`.
    public final func rotate180() {
        gi.object_method_bind_ptrcall(Image.method_rotate_180, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_fix_alpha_edges: GDExtensionMethodBindPtr = {
        let methodName = StringName("fix_alpha_edges")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Blends low-alpha pixels with nearby pixels.
    public final func fixAlphaEdges() {
        gi.object_method_bind_ptrcall(Image.method_fix_alpha_edges, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_premultiply_alpha: GDExtensionMethodBindPtr = {
        let methodName = StringName("premultiply_alpha")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Multiplies color values with alpha values. Resulting color values for a pixel are `(color * alpha)/256`. See also ``CanvasItemMaterial/blendMode``.
    public final func premultiplyAlpha() {
        gi.object_method_bind_ptrcall(Image.method_premultiply_alpha, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_srgb_to_linear: GDExtensionMethodBindPtr = {
        let methodName = StringName("srgb_to_linear")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Converts the raw data from the sRGB colorspace to a linear scale.
    public final func srgbToLinear() {
        gi.object_method_bind_ptrcall(Image.method_srgb_to_linear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_normal_map_to_xy: GDExtensionMethodBindPtr = {
        let methodName = StringName("normal_map_to_xy")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Converts the image's data to represent coordinates on a 3D plane. This is used when the image represents a normal map. A normal map can add lots of detail to a 3D surface without increasing the polygon count.
    public final func normalMapToXy() {
        gi.object_method_bind_ptrcall(Image.method_normal_map_to_xy, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_rgbe_to_srgb: GDExtensionMethodBindPtr = {
        let methodName = StringName("rgbe_to_srgb")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 564927088)!
            }
            
        }
        
    }()
    
    /// Converts a standard RGBE (Red Green Blue Exponent) image to an sRGB image.
    public final func rgbeToSrgb() -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Image.method_rgbe_to_srgb, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_bump_map_to_normal_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("bump_map_to_normal_map")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3423495036)!
            }
            
        }
        
    }()
    
    /// Converts a bump map to a normal map. A bump map provides a height offset per-pixel, while a normal map provides a normal direction per pixel.
    public final func bumpMapToNormalMap(bumpScale: Double = 1.0) {
        withUnsafePointer(to: bumpScale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_bump_map_to_normal_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_image_metrics: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_image_metrics")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3080961247)!
            }
            
        }
        
    }()
    
    /// Compute image metrics on the current image and the compared image.
    /// 
    /// The dictionary contains `max`, `mean`, `mean_squared`, `root_mean_squared` and `peak_snr`.
    /// 
    public final func computeImageMetrics(comparedImage: Image?, useLuma: Bool) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: comparedImage?.handle) { pArg0 in
            withUnsafePointer(to: useLuma) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_compute_image_metrics, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_blit_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("blit_rect")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2903928755)!
            }
            
        }
        
    }()
    
    /// Copies `srcRect` from `src` image to this image at coordinates `dst`, clipped accordingly to both image bounds. This image and `src` image **must** have the same format. `srcRect` with non-positive size is treated as empty.
    public final func blitRect(src: Image, srcRect: Rect2i, dst: Vector2i) {
        withUnsafePointer(to: src.handle) { pArg0 in
            withUnsafePointer(to: srcRect) { pArg1 in
                withUnsafePointer(to: dst) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_blit_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_blit_rect_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("blit_rect_mask")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3383581145)!
            }
            
        }
        
    }()
    
    /// Blits `srcRect` area from `src` image to this image at the coordinates given by `dst`, clipped accordingly to both image bounds. `src` pixel is copied onto `dst` if the corresponding `mask` pixel's alpha value is not 0. This image and `src` image **must** have the same format. `src` image and `mask` image **must** have the same size (width and height) but they can have different formats. `srcRect` with non-positive size is treated as empty.
    public final func blitRectMask(src: Image?, mask: Image?, srcRect: Rect2i, dst: Vector2i) {
        withUnsafePointer(to: src?.handle) { pArg0 in
            withUnsafePointer(to: mask?.handle) { pArg1 in
                withUnsafePointer(to: srcRect) { pArg2 in
                    withUnsafePointer(to: dst) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Image.method_blit_rect_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_blend_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("blend_rect")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2903928755)!
            }
            
        }
        
    }()
    
    /// Alpha-blends `srcRect` from `src` image to this image at coordinates `dst`, clipped accordingly to both image bounds. This image and `src` image **must** have the same format. `srcRect` with non-positive size is treated as empty.
    public final func blendRect(src: Image?, srcRect: Rect2i, dst: Vector2i) {
        withUnsafePointer(to: src?.handle) { pArg0 in
            withUnsafePointer(to: srcRect) { pArg1 in
                withUnsafePointer(to: dst) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_blend_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_blend_rect_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("blend_rect_mask")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3383581145)!
            }
            
        }
        
    }()
    
    /// Alpha-blends `srcRect` from `src` image to this image using `mask` image at coordinates `dst`, clipped accordingly to both image bounds. Alpha channels are required for both `src` and `mask`. `dst` pixels and `src` pixels will blend if the corresponding mask pixel's alpha value is not 0. This image and `src` image **must** have the same format. `src` image and `mask` image **must** have the same size (width and height) but they can have different formats. `srcRect` with non-positive size is treated as empty.
    public final func blendRectMask(src: Image?, mask: Image?, srcRect: Rect2i, dst: Vector2i) {
        withUnsafePointer(to: src?.handle) { pArg0 in
            withUnsafePointer(to: mask?.handle) { pArg1 in
                withUnsafePointer(to: srcRect) { pArg2 in
                    withUnsafePointer(to: dst) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Image.method_blend_rect_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_fill: GDExtensionMethodBindPtr = {
        let methodName = StringName("fill")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Fills the image with `color`.
    public final func fill(color: Color) {
        withUnsafePointer(to: color) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_fill, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_fill_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("fill_rect")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 514693913)!
            }
            
        }
        
    }()
    
    /// Fills `rect` with `color`.
    public final func fillRect(_ rect: Rect2i, color: Color) {
        withUnsafePointer(to: rect) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_fill_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_used_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_rect")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 410525958)!
            }
            
        }
        
    }()
    
    /// Returns a ``Rect2i`` enclosing the visible portion of the image, considering each pixel with a non-zero alpha channel as visible.
    public final func getUsedRect() -> Rect2i {
        var _result: Rect2i = Rect2i ()
        gi.object_method_bind_ptrcall(Image.method_get_used_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_region: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_region")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2601441065)!
            }
            
        }
        
    }()
    
    /// Returns a new ``Image`` that is a copy of this ``Image``'s area specified with `region`.
    public final func getRegion(_ region: Rect2i) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: region) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_get_region, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_copy_from: GDExtensionMethodBindPtr = {
        let methodName = StringName("copy_from")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 532598488)!
            }
            
        }
        
    }()
    
    /// Copies `src` image to this image.
    public final func copyFrom(src: Image?) {
        withUnsafePointer(to: src?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_copy_from, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_pixelv: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pixelv")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1532707496)!
            }
            
        }
        
    }()
    
    /// Returns the color of the pixel at `point`.
    /// 
    /// This is the same as ``getPixel(x:y:)``, but with a ``Vector2i`` argument instead of two integer arguments.
    /// 
    public final func getPixelv(point: Vector2i) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: point) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_get_pixelv, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pixel")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2165839948)!
            }
            
        }
        
    }()
    
    /// Returns the color of the pixel at `(x, y)`.
    /// 
    /// This is the same as ``getPixelv(point:)``, but with two integer arguments instead of a ``Vector2i`` argument.
    /// 
    public final func getPixel(x: Int32, y: Int32) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: y) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_get_pixel, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_pixelv: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pixelv")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 287851464)!
            }
            
        }
        
    }()
    
    /// Sets the ``Color`` of the pixel at `point` to `color`.
    /// 
    /// **Example:**
    /// 
    /// This is the same as ``setPixel(x:y:color:)``, but with a ``Vector2i`` argument instead of two integer arguments.
    /// 
    public final func setPixelv(point: Vector2i, color: Color) {
        withUnsafePointer(to: point) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_set_pixelv, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pixel")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3733378741)!
            }
            
        }
        
    }()
    
    /// Sets the ``Color`` of the pixel at `(x, y)` to `color`.
    /// 
    /// **Example:**
    /// 
    /// This is the same as ``setPixelv(point:color:)``, but with a two integer arguments instead of a ``Vector2i`` argument.
    /// 
    public final func setPixel(x: Int32, y: Int32, color: Color) {
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: y) { pArg1 in
                withUnsafePointer(to: color) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_set_pixel, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_adjust_bcs: GDExtensionMethodBindPtr = {
        let methodName = StringName("adjust_bcs")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2385087082)!
            }
            
        }
        
    }()
    
    /// Adjusts this image's `brightness`, `contrast`, and `saturation` by the given values. Does not work if the image is compressed (see ``isCompressed()``).
    public final func adjustBcs(brightness: Double, contrast: Double, saturation: Double) {
        withUnsafePointer(to: brightness) { pArg0 in
            withUnsafePointer(to: contrast) { pArg1 in
                withUnsafePointer(to: saturation) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Image.method_adjust_bcs, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_load_png_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_png_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a PNG file.
    public final func loadPngFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_png_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_jpg_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_jpg_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a JPEG file.
    public final func loadJpgFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_jpg_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_webp_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_webp_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a WebP file.
    public final func loadWebpFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_webp_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_tga_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_tga_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a TGA file.
    /// 
    /// > Note: This method is only available in engine builds with the TGA module enabled. By default, the TGA module is enabled, but it can be disabled at build-time using the `module_tga_enabled=no` SCons option.
    /// 
    public final func loadTgaFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_tga_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_bmp_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_bmp_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a BMP file.
    /// 
    /// > Note: Godot's BMP module doesn't support 16-bit per pixel images. Only 1-bit, 4-bit, 8-bit, 24-bit, and 32-bit per pixel images are supported.
    /// 
    /// > Note: This method is only available in engine builds with the BMP module enabled. By default, the BMP module is enabled, but it can be disabled at build-time using the `module_bmp_enabled=no` SCons option.
    /// 
    public final func loadBmpFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_bmp_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_ktx_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_ktx_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 680677267)!
            }
            
        }
        
    }()
    
    /// Loads an image from the binary contents of a <a href="https://github.com/KhronosGroup/KTX-Software">KTX</a> file. Unlike most image formats, KTX can store VRAM-compressed data and embed mipmaps.
    /// 
    /// > Note: Godot's libktx implementation only supports 2D images. Cubemaps, texture arrays, and de-padding are not supported.
    /// 
    /// > Note: This method is only available in engine builds with the KTX module enabled. By default, the KTX module is enabled, but it can be disabled at build-time using the `module_ktx_enabled=no` SCons option.
    /// 
    public final func loadKtxFromBuffer(_ buffer: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Image.method_load_ktx_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_svg_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_svg_from_buffer")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 311853421)!
            }
            
        }
        
    }()
    
    /// Loads an image from the UTF-8 binary contents of an **uncompressed** SVG file (**.svg**).
    /// 
    /// > Note: Beware when using compressed SVG files (like **.svgz**), they need to be `decompressed` before loading.
    /// 
    /// > Note: This method is only available in engine builds with the SVG module enabled. By default, the SVG module is enabled, but it can be disabled at build-time using the `module_svg_enabled=no` SCons option.
    /// 
    public final func loadSvgFromBuffer(_ buffer: PackedByteArray, scale: Double = 1.0) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: scale) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_load_svg_from_buffer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_svg_from_string: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_svg_from_string")
        return withUnsafePointer(to: &Image.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3254053600)!
            }
            
        }
        
    }()
    
    /// Loads an image from the string contents of an SVG file (**.svg**).
    /// 
    /// > Note: This method is only available in engine builds with the SVG module enabled. By default, the SVG module is enabled, but it can be disabled at build-time using the `module_svg_enabled=no` SCons option.
    /// 
    public final func loadSvgFromString(svgStr: String, scale: Double = 1.0) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let svgStr = GString(svgStr)
        withUnsafePointer(to: svgStr.content) { pArg0 in
            withUnsafePointer(to: scale) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Image.method_load_svg_from_string, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
}

