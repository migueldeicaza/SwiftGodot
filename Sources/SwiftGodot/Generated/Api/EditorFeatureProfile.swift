// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// An editor feature profile which can be used to disable specific features.
/// 
/// An editor feature profile can be used to disable specific features of the Godot editor. When disabled, the features won't appear in the editor, which makes the editor less cluttered. This is useful in education settings to reduce confusion or when working in a team. For example, artists and level designers could use a feature profile that disables the script editor to avoid accidentally making changes to files they aren't supposed to edit.
/// 
/// To manage editor feature profiles visually, use **Editor > Manage Feature Profiles...** at the top of the editor window.
/// 
open class EditorFeatureProfile: RefCounted {
    override open class var godotClassName: StringName { "EditorFeatureProfile" }
    public enum Feature: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The 3D editor. If this feature is disabled, the 3D editor won't display but 3D nodes will still display in the Create New Node dialog.
        case feature3d = 0 // FEATURE_3D
        /// The Script tab, which contains the script editor and class reference browser. If this feature is disabled, the Script tab won't display.
        case script = 1 // FEATURE_SCRIPT
        /// The AssetLib tab. If this feature is disabled, the AssetLib tab won't display.
        case assetLib = 2 // FEATURE_ASSET_LIB
        /// Scene tree editing. If this feature is disabled, the Scene tree dock will still be visible but will be read-only.
        case sceneTree = 3 // FEATURE_SCENE_TREE
        /// The Node dock. If this feature is disabled, signals and groups won't be visible and modifiable from the editor.
        case nodeDock = 4 // FEATURE_NODE_DOCK
        /// The FileSystem dock. If this feature is disabled, the FileSystem dock won't be visible.
        case filesystemDock = 5 // FEATURE_FILESYSTEM_DOCK
        /// The Import dock. If this feature is disabled, the Import dock won't be visible.
        case importDock = 6 // FEATURE_IMPORT_DOCK
        /// The History dock. If this feature is disabled, the History dock won't be visible.
        case historyDock = 7 // FEATURE_HISTORY_DOCK
        /// Represents the size of the ``EditorFeatureProfile/Feature`` enum.
        case max = 8 // FEATURE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .feature3d: return ".feature3d"
                case .script: return ".script"
                case .assetLib: return ".assetLib"
                case .sceneTree: return ".sceneTree"
                case .nodeDock: return ".nodeDock"
                case .filesystemDock: return ".filesystemDock"
                case .importDock: return ".importDock"
                case .historyDock: return ".historyDock"
                case .max: return ".max"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_disable_class: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_class")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2524380260)!
            }
            
        }
        
    }()
    
    /// If `disable` is `true`, disables the class specified by `className`. When disabled, the class won't appear in the Create New Node dialog.
    public final func setDisableClass(className: StringName, disable: Bool) {
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: disable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(EditorFeatureProfile.method_set_disable_class, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_class_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_class_disabled")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the class specified by `className` is disabled. When disabled, the class won't appear in the Create New Node dialog.
    public final func isClassDisabled(className: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_is_class_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_disable_class_editor: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_class_editor")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2524380260)!
            }
            
        }
        
    }()
    
    /// If `disable` is `true`, disables editing for the class specified by `className`. When disabled, the class will still appear in the Create New Node dialog but the Inspector will be read-only when selecting a node that extends the class.
    public final func setDisableClassEditor(className: StringName, disable: Bool) {
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: disable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(EditorFeatureProfile.method_set_disable_class_editor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_class_editor_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_class_editor_disabled")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if editing for the class specified by `className` is disabled. When disabled, the class will still appear in the Create New Node dialog but the Inspector will be read-only when selecting a node that extends the class.
    public final func isClassEditorDisabled(className: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_is_class_editor_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_disable_class_property: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_class_property")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 865197084)!
            }
            
        }
        
    }()
    
    /// If `disable` is `true`, disables editing for `property` in the class specified by `className`. When a property is disabled, it won't appear in the Inspector when selecting a node that extends the class specified by `className`.
    public final func setDisableClassProperty(className: StringName, property: StringName, disable: Bool) {
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: disable) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(EditorFeatureProfile.method_set_disable_class_property, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_class_property_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_class_property_disabled")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 471820014)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `property` is disabled in the class specified by `className`. When a property is disabled, it won't appear in the Inspector when selecting a node that extends the class specified by `className`.
    public final func isClassPropertyDisabled(className: StringName, property: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: className.content) { pArg0 in
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(EditorFeatureProfile.method_is_class_property_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_disable_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_feature")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1884871044)!
            }
            
        }
        
    }()
    
    /// If `disable` is `true`, disables the editor feature specified in `feature`. When a feature is disabled, it will disappear from the editor entirely.
    public final func setDisableFeature(_ feature: EditorFeatureProfile.Feature, disable: Bool) {
        withUnsafePointer(to: feature.rawValue) { pArg0 in
            withUnsafePointer(to: disable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(EditorFeatureProfile.method_set_disable_feature, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_feature_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_feature_disabled")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2974403161)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the `feature` is disabled. When a feature is disabled, it will disappear from the editor entirely.
    public final func isFeatureDisabled(feature: EditorFeatureProfile.Feature) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: feature.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_is_feature_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_feature_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_feature_name")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3401335809)!
            }
            
        }
        
    }()
    
    /// Returns the specified `feature`'s human-readable name.
    public final func getFeatureName(feature: EditorFeatureProfile.Feature) -> String {
        let _result = GString ()
        withUnsafePointer(to: feature.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_get_feature_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_save_to_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_to_file")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166001499)!
            }
            
        }
        
    }()
    
    /// Saves the editor feature profile to a file in JSON format. It can then be imported using the feature profile manager's **Import** button or the ``loadFromFile(path:)`` method.
    /// 
    /// > Note: Feature profiles created via the user interface are saved in the `feature_profiles` directory, as a file with the `.profile` extension. The editor configuration folder can be found by using ``EditorPaths/getConfigDir()``.
    /// 
    public final func saveToFile(path: String) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_save_to_file, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_load_from_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_from_file")
        return withUnsafePointer(to: &EditorFeatureProfile.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166001499)!
            }
            
        }
        
    }()
    
    /// Loads an editor feature profile from a file. The file must follow the JSON format obtained by using the feature profile manager's **Export** button or the ``saveToFile(path:)`` method.
    /// 
    /// > Note: Feature profiles created via the user interface are loaded from the `feature_profiles` directory, as a file with the `.profile` extension. The editor configuration folder can be found by using ``EditorPaths/getConfigDir()``.
    /// 
    public final func loadFromFile(path: String) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorFeatureProfile.method_load_from_file, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
}

