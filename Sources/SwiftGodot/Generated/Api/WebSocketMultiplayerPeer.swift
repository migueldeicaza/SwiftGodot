// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for WebSocket server and client.
/// 
/// Base class for WebSocket server and client, allowing them to be used as multiplayer peer for the ``MultiplayerAPI``.
/// 
/// > Note: When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
/// 
open class WebSocketMultiplayerPeer: MultiplayerPeer {
    override open class var godotClassName: StringName { "WebSocketMultiplayerPeer" }
    
    /* Properties */
    
    /// The supported WebSocket sub-protocols. See ``WebSocketPeer/supportedProtocols`` for more details.
    final public var supportedProtocols: PackedStringArray {
        get {
            return get_supported_protocols ()
        }
        
        set {
            set_supported_protocols (newValue)
        }
        
    }
    
    /// The extra headers to use during handshake. See ``WebSocketPeer/handshakeHeaders`` for more details.
    final public var handshakeHeaders: PackedStringArray {
        get {
            return get_handshake_headers ()
        }
        
        set {
            set_handshake_headers (newValue)
        }
        
    }
    
    /// The inbound buffer size for connected peers. See ``WebSocketPeer/inboundBufferSize`` for more details.
    final public var inboundBufferSize: Int32 {
        get {
            return get_inbound_buffer_size ()
        }
        
        set {
            set_inbound_buffer_size (newValue)
        }
        
    }
    
    /// The outbound buffer size for connected peers. See ``WebSocketPeer/outboundBufferSize`` for more details.
    final public var outboundBufferSize: Int32 {
        get {
            return get_outbound_buffer_size ()
        }
        
        set {
            set_outbound_buffer_size (newValue)
        }
        
    }
    
    /// The maximum time each peer can stay in a connecting state before being dropped.
    final public var handshakeTimeout: Double {
        get {
            return get_handshake_timeout ()
        }
        
        set {
            set_handshake_timeout (newValue)
        }
        
    }
    
    /// The maximum number of queued packets for connected peers. See ``WebSocketPeer/maxQueuedPackets`` for more details.
    final public var maxQueuedPackets: Int32 {
        get {
            return get_max_queued_packets ()
        }
        
        set {
            set_max_queued_packets (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_create_client: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_client")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1966198364)!
            }
            
        }
        
    }()
    
    /// Starts a new multiplayer client connecting to the given `url`. TLS certificates will be verified against the hostname when connecting using the `wss://` protocol. You can pass the optional `tlsClientOptions` parameter to customize the trusted certification authorities, or disable the common name verification. See ``TLSOptions/client(trustedChain:commonNameOverride:)`` and ``TLSOptions/clientUnsafe(trustedChain:)``.
    /// 
    /// > Note: It is recommended to specify the scheme part of the URL, i.e. the `url` should start with either `ws://` or `wss://`.
    /// 
    public final func createClient(url: String, tlsClientOptions: TLSOptions? = nil) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let url = GString(url)
        withUnsafePointer(to: url.content) { pArg0 in
            withUnsafePointer(to: tlsClientOptions?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_create_client, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_create_server: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_server")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2400822951)!
            }
            
        }
        
    }()
    
    /// Starts a new multiplayer server listening on the given `port`. You can optionally specify a `bindAddress`, and provide valid `tlsServerOptions` to use TLS. See ``TLSOptions/server(key:certificate:)``.
    public final func createServer(port: Int32, bindAddress: String = "*", tlsServerOptions: TLSOptions? = nil) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: port) { pArg0 in
            let bindAddress = GString(bindAddress)
            withUnsafePointer(to: bindAddress.content) { pArg1 in
                withUnsafePointer(to: tlsServerOptions?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_create_server, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_get_peer: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_peer")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1381378851)!
            }
            
        }
        
    }()
    
    /// Returns the ``WebSocketPeer`` associated to the given `peerId`.
    public final func getPeer(peerId: Int32) -> WebSocketPeer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: peerId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_peer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_peer_address: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_peer_address")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the IP address of the given peer.
    public final func getPeerAddress(id: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_peer_address, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_peer_port: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_peer_port")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the remote port of the given peer.
    public final func getPeerPort(id: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_peer_port, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_supported_protocols: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_supported_protocols")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_supported_protocols() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_supported_protocols, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_supported_protocols: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_supported_protocols")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4015028928)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_supported_protocols(_ protocols: PackedStringArray) {
        withUnsafePointer(to: protocols.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_supported_protocols, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_handshake_headers: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_handshake_headers")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_handshake_headers() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_handshake_headers, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_handshake_headers: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_handshake_headers")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4015028928)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_handshake_headers(_ protocols: PackedStringArray) {
        withUnsafePointer(to: protocols.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_handshake_headers, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_inbound_buffer_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_inbound_buffer_size")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_inbound_buffer_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_inbound_buffer_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_inbound_buffer_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_inbound_buffer_size")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_inbound_buffer_size(_ bufferSize: Int32) {
        withUnsafePointer(to: bufferSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_inbound_buffer_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_outbound_buffer_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_outbound_buffer_size")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_outbound_buffer_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_outbound_buffer_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_outbound_buffer_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_outbound_buffer_size")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_outbound_buffer_size(_ bufferSize: Int32) {
        withUnsafePointer(to: bufferSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_outbound_buffer_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_handshake_timeout: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_handshake_timeout")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_handshake_timeout() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_handshake_timeout, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_handshake_timeout: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_handshake_timeout")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_handshake_timeout(_ timeout: Double) {
        withUnsafePointer(to: timeout) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_handshake_timeout, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_max_queued_packets: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_max_queued_packets")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_queued_packets(_ maxQueuedPackets: Int32) {
        withUnsafePointer(to: maxQueuedPackets) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_set_max_queued_packets, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_max_queued_packets: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_max_queued_packets")
        return withUnsafePointer(to: &WebSocketMultiplayerPeer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_queued_packets() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(WebSocketMultiplayerPeer.method_get_max_queued_packets, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

