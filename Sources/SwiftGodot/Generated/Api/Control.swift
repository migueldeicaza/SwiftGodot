// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for all GUI controls. Adapts its position and size based on its parent control.
/// 
/// Base class for all UI-related nodes. ``Control`` features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change.
/// 
/// For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from ``Control`` and ``Container`` nodes.
/// 
/// **User Interface nodes and input**
/// 
/// Godot propagates input events via viewports. Each ``Viewport`` is responsible for propagating ``InputEvent``s to their child nodes. As the ``SceneTree/root`` is a ``Window``, this already happens automatically for all UI elements in your game.
/// 
/// Input events are propagated through the ``SceneTree`` from the root node to all child nodes by calling ``Node/_input(event:)``. For UI elements specifically, it makes more sense to override the virtual method ``_guiInput(event:)``, which filters out unrelated input events, such as by checking z-order, ``mouseFilter``, focus, or if the event was inside of the control's bounding box.
/// 
/// Call ``acceptEvent()`` so no other node receives the event. Once you accept an input, it becomes handled so ``Node/_unhandledInput(event:)`` will not process it.
/// 
/// Only one ``Control`` node can be in focus. Only the node in focus will receive events. To get the focus, call ``grabFocus()``. ``Control`` nodes lose focus when another node grabs it, or if you hide the node in focus.
/// 
/// Sets ``mouseFilter`` to ``MouseFilter/ignore`` to tell a ``Control`` node to ignore mouse or touch events. You'll need it if you place an icon on top of a button.
/// 
/// ``Theme`` resources change the Control's appearance. If you change the ``Theme`` on a ``Control`` node, it affects all of its children. To override some of the theme's parameters, call one of the `add_theme_*_override` methods, like ``addThemeFontOverride(name:font:)``. You can override the theme with the Inspector.
/// 
/// > Note: Theme items are _not_ ``Object`` properties. This means you can't access their values using ``Object/get(property:)`` and ``Object/set(property:value:)``. Instead, use the `get_theme_*` and `add_theme_*_override` methods provided by this class.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``resized``
/// - ``guiInput``
/// - ``mouseEntered``
/// - ``mouseExited``
/// - ``focusEntered``
/// - ``focusExited``
/// - ``sizeFlagsChanged``
/// - ``minimumSizeChanged``
/// - ``themeChanged``
open class Control: CanvasItem {
    override open class var godotClassName: StringName { "Control" }
    public enum FocusMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The node cannot grab focus. Use with ``focusMode``.
        case none = 0 // FOCUS_NONE
        /// The node can only grab focus on mouse clicks. Use with ``focusMode``.
        case click = 1 // FOCUS_CLICK
        /// The node can grab focus on mouse click, using the arrows and the Tab keys on the keyboard, or using the D-pad buttons on a gamepad. Use with ``focusMode``.
        case all = 2 // FOCUS_ALL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .click: return ".click"
                case .all: return ".all"
            }
            
        }
        
    }
    
    public enum CursorShape: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Show the system's arrow mouse cursor when the user hovers the node. Use with ``mouseDefaultCursorShape``.
        case arrow = 0 // CURSOR_ARROW
        /// Show the system's I-beam mouse cursor when the user hovers the node. The I-beam pointer has a shape similar to "I". It tells the user they can highlight or insert text.
        case ibeam = 1 // CURSOR_IBEAM
        /// Show the system's pointing hand mouse cursor when the user hovers the node.
        case pointingHand = 2 // CURSOR_POINTING_HAND
        /// Show the system's cross mouse cursor when the user hovers the node.
        case cross = 3 // CURSOR_CROSS
        /// Show the system's wait mouse cursor when the user hovers the node. Often an hourglass.
        case wait = 4 // CURSOR_WAIT
        /// Show the system's busy mouse cursor when the user hovers the node. Often an arrow with a small hourglass.
        case busy = 5 // CURSOR_BUSY
        /// Show the system's drag mouse cursor, often a closed fist or a cross symbol, when the user hovers the node. It tells the user they're currently dragging an item, like a node in the Scene dock.
        case drag = 6 // CURSOR_DRAG
        /// Show the system's drop mouse cursor when the user hovers the node. It can be an open hand. It tells the user they can drop an item they're currently grabbing, like a node in the Scene dock.
        case canDrop = 7 // CURSOR_CAN_DROP
        /// Show the system's forbidden mouse cursor when the user hovers the node. Often a crossed circle.
        case forbidden = 8 // CURSOR_FORBIDDEN
        /// Show the system's vertical resize mouse cursor when the user hovers the node. A double-headed vertical arrow. It tells the user they can resize the window or the panel vertically.
        case vsize = 9 // CURSOR_VSIZE
        /// Show the system's horizontal resize mouse cursor when the user hovers the node. A double-headed horizontal arrow. It tells the user they can resize the window or the panel horizontally.
        case hsize = 10 // CURSOR_HSIZE
        /// Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the bottom left to the top right. It tells the user they can resize the window or the panel both horizontally and vertically.
        case bdiagsize = 11 // CURSOR_BDIAGSIZE
        /// Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the top left to the bottom right, the opposite of ``CursorShape/bdiagsize``. It tells the user they can resize the window or the panel both horizontally and vertically.
        case fdiagsize = 12 // CURSOR_FDIAGSIZE
        /// Show the system's move mouse cursor when the user hovers the node. It shows 2 double-headed arrows at a 90 degree angle. It tells the user they can move a UI element freely.
        case move = 13 // CURSOR_MOVE
        /// Show the system's vertical split mouse cursor when the user hovers the node. On Windows, it's the same as ``CursorShape/vsize``.
        case vsplit = 14 // CURSOR_VSPLIT
        /// Show the system's horizontal split mouse cursor when the user hovers the node. On Windows, it's the same as ``CursorShape/hsize``.
        case hsplit = 15 // CURSOR_HSPLIT
        /// Show the system's help mouse cursor when the user hovers the node, a question mark.
        case help = 16 // CURSOR_HELP
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .arrow: return ".arrow"
                case .ibeam: return ".ibeam"
                case .pointingHand: return ".pointingHand"
                case .cross: return ".cross"
                case .wait: return ".wait"
                case .busy: return ".busy"
                case .drag: return ".drag"
                case .canDrop: return ".canDrop"
                case .forbidden: return ".forbidden"
                case .vsize: return ".vsize"
                case .hsize: return ".hsize"
                case .bdiagsize: return ".bdiagsize"
                case .fdiagsize: return ".fdiagsize"
                case .move: return ".move"
                case .vsplit: return ".vsplit"
                case .hsplit: return ".hsplit"
                case .help: return ".help"
            }
            
        }
        
    }
    
    public enum LayoutPreset: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Snap all 4 anchors to the top-left of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case topLeft = 0 // PRESET_TOP_LEFT
        /// Snap all 4 anchors to the top-right of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case topRight = 1 // PRESET_TOP_RIGHT
        /// Snap all 4 anchors to the bottom-left of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case bottomLeft = 2 // PRESET_BOTTOM_LEFT
        /// Snap all 4 anchors to the bottom-right of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case bottomRight = 3 // PRESET_BOTTOM_RIGHT
        /// Snap all 4 anchors to the center of the left edge of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case centerLeft = 4 // PRESET_CENTER_LEFT
        /// Snap all 4 anchors to the center of the top edge of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case centerTop = 5 // PRESET_CENTER_TOP
        /// Snap all 4 anchors to the center of the right edge of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case centerRight = 6 // PRESET_CENTER_RIGHT
        /// Snap all 4 anchors to the center of the bottom edge of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case centerBottom = 7 // PRESET_CENTER_BOTTOM
        /// Snap all 4 anchors to the center of the parent control's bounds. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case center = 8 // PRESET_CENTER
        /// Snap all 4 anchors to the left edge of the parent control. The left offset becomes relative to the left edge and the top offset relative to the top left corner of the node's parent. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case leftWide = 9 // PRESET_LEFT_WIDE
        /// Snap all 4 anchors to the top edge of the parent control. The left offset becomes relative to the top left corner, the top offset relative to the top edge, and the right offset relative to the top right corner of the node's parent. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case topWide = 10 // PRESET_TOP_WIDE
        /// Snap all 4 anchors to the right edge of the parent control. The right offset becomes relative to the right edge and the top offset relative to the top right corner of the node's parent. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case rightWide = 11 // PRESET_RIGHT_WIDE
        /// Snap all 4 anchors to the bottom edge of the parent control. The left offset becomes relative to the bottom left corner, the bottom offset relative to the bottom edge, and the right offset relative to the bottom right corner of the node's parent. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case bottomWide = 12 // PRESET_BOTTOM_WIDE
        /// Snap all 4 anchors to a vertical line that cuts the parent control in half. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case vcenterWide = 13 // PRESET_VCENTER_WIDE
        /// Snap all 4 anchors to a horizontal line that cuts the parent control in half. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case hcenterWide = 14 // PRESET_HCENTER_WIDE
        /// Snap all 4 anchors to the respective corners of the parent control. Set all 4 offsets to 0 after you applied this preset and the ``Control`` will fit its parent control. Use with ``setAnchorsPreset(_:keepOffsets:)``.
        case fullRect = 15 // PRESET_FULL_RECT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .topLeft: return ".topLeft"
                case .topRight: return ".topRight"
                case .bottomLeft: return ".bottomLeft"
                case .bottomRight: return ".bottomRight"
                case .centerLeft: return ".centerLeft"
                case .centerTop: return ".centerTop"
                case .centerRight: return ".centerRight"
                case .centerBottom: return ".centerBottom"
                case .center: return ".center"
                case .leftWide: return ".leftWide"
                case .topWide: return ".topWide"
                case .rightWide: return ".rightWide"
                case .bottomWide: return ".bottomWide"
                case .vcenterWide: return ".vcenterWide"
                case .hcenterWide: return ".hcenterWide"
                case .fullRect: return ".fullRect"
            }
            
        }
        
    }
    
    public enum LayoutPresetMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The control will be resized to its minimum size.
        case minsize = 0 // PRESET_MODE_MINSIZE
        /// The control's width will not change.
        case keepWidth = 1 // PRESET_MODE_KEEP_WIDTH
        /// The control's height will not change.
        case keepHeight = 2 // PRESET_MODE_KEEP_HEIGHT
        /// The control's size will not change.
        case keepSize = 3 // PRESET_MODE_KEEP_SIZE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .minsize: return ".minsize"
                case .keepWidth: return ".keepWidth"
                case .keepHeight: return ".keepHeight"
                case .keepSize: return ".keepSize"
            }
            
        }
        
    }
    
    public struct SizeFlags: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Tells the parent ``Container`` to expand the bounds of this node to fill all the available space without pushing any other node. It is mutually exclusive with shrink size flags. Use with ``sizeFlagsHorizontal`` and ``sizeFlagsVertical``.
        public static let fill = SizeFlags (rawValue: 1)
        /// Tells the parent ``Container`` to let this node take all the available space on the axis you flag. If multiple neighboring nodes are set to expand, they'll share the space based on their stretch ratio. See ``sizeFlagsStretchRatio``. Use with ``sizeFlagsHorizontal`` and ``sizeFlagsVertical``.
        public static let expand = SizeFlags (rawValue: 2)
        /// Sets the node's size flags to both fill and expand. See ``SizeFlags/fill`` and ``SizeFlags/expand`` for more information.
        public static let expandFill = SizeFlags (rawValue: 3)
        /// Tells the parent ``Container`` to center the node in the available space. It is mutually exclusive with ``SizeFlags/fill`` and other shrink size flags, but can be used with ``SizeFlags/expand`` in some containers. Use with ``sizeFlagsHorizontal`` and ``sizeFlagsVertical``.
        public static let shrinkCenter = SizeFlags (rawValue: 4)
        /// Tells the parent ``Container`` to align the node with its end, either the bottom or the right edge. It is mutually exclusive with ``SizeFlags/fill`` and other shrink size flags, but can be used with ``SizeFlags/expand`` in some containers. Use with ``sizeFlagsHorizontal`` and ``sizeFlagsVertical``.
        public static let shrinkEnd = SizeFlags (rawValue: 8)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.fill) { result += "fill, " }
            if self.contains (.expand) { result += "expand, " }
            if self.contains (.expandFill) { result += "expandFill, " }
            if self.contains (.shrinkCenter) { result += "shrinkCenter, " }
            if self.contains (.shrinkEnd) { result += "shrinkEnd, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum MouseFilter: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The control will receive mouse movement input events and mouse button input events if clicked on through ``_guiInput(event:)``. And the control will receive the [signal mouse_entered] and [signal mouse_exited] signals. These events are automatically marked as handled, and they will not propagate further to other controls. This also results in blocking signals in other controls.
        case stop = 0 // MOUSE_FILTER_STOP
        /// The control will receive mouse movement input events and mouse button input events if clicked on through ``_guiInput(event:)``. And the control will receive the [signal mouse_entered] and [signal mouse_exited] signals. If this control does not handle the event, the parent control (if any) will be considered, and so on until there is no more parent control to potentially handle it. This also allows signals to fire in other controls. If no control handled it, the event will be passed to ``Node/_shortcutInput(event:)`` for further processing.
        case pass = 1 // MOUSE_FILTER_PASS
        /// The control will not receive mouse movement input events and mouse button input events if clicked on through ``_guiInput(event:)``. The control will also not receive the [signal mouse_entered] nor [signal mouse_exited] signals. This will not block other controls from receiving these events or firing the signals. Ignored events will not be handled automatically.
        /// 
        /// > Note: If the control has received [signal mouse_entered] but not [signal mouse_exited], changing the ``mouseFilter`` to ``MouseFilter/ignore`` will cause [signal mouse_exited] to be emitted.
        /// 
        case ignore = 2 // MOUSE_FILTER_IGNORE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .stop: return ".stop"
                case .pass: return ".pass"
                case .ignore: return ".ignore"
            }
            
        }
        
    }
    
    public enum GrowDirection: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The control will grow to the left or top to make up if its minimum size is changed to be greater than its current size on the respective axis.
        case begin = 0 // GROW_DIRECTION_BEGIN
        /// The control will grow to the right or bottom to make up if its minimum size is changed to be greater than its current size on the respective axis.
        case end = 1 // GROW_DIRECTION_END
        /// The control will grow in both directions equally to make up if its minimum size is changed to be greater than its current size.
        case both = 2 // GROW_DIRECTION_BOTH
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .begin: return ".begin"
                case .end: return ".end"
                case .both: return ".both"
            }
            
        }
        
    }
    
    public enum Anchor: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Snaps one of the 4 anchor's sides to the origin of the node's `Rect`, in the top left. Use it with one of the `anchor_*` member variables, like ``anchorLeft``. To change all 4 anchors at once, use ``setAnchorsPreset(_:keepOffsets:)``.
        case begin = 0 // ANCHOR_BEGIN
        /// Snaps one of the 4 anchor's sides to the end of the node's `Rect`, in the bottom right. Use it with one of the `anchor_*` member variables, like ``anchorLeft``. To change all 4 anchors at once, use ``setAnchorsPreset(_:keepOffsets:)``.
        case end = 1 // ANCHOR_END
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .begin: return ".begin"
                case .end: return ".end"
            }
            
        }
        
    }
    
    public enum LayoutDirection: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Automatic layout direction, determined from the parent control layout direction.
        case inherited = 0 // LAYOUT_DIRECTION_INHERITED
        /// Automatic layout direction, determined from the current locale.
        case locale = 1 // LAYOUT_DIRECTION_LOCALE
        /// Left-to-right layout direction.
        case ltr = 2 // LAYOUT_DIRECTION_LTR
        /// Right-to-left layout direction.
        case rtl = 3 // LAYOUT_DIRECTION_RTL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .inherited: return ".inherited"
                case .locale: return ".locale"
                case .ltr: return ".ltr"
                case .rtl: return ".rtl"
            }
            
        }
        
    }
    
    public enum TextDirection: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Text writing direction is the same as layout direction.
        case inherited = 3 // TEXT_DIRECTION_INHERITED
        /// Automatic text writing direction, determined from the current locale and text content.
        case auto = 0 // TEXT_DIRECTION_AUTO
        /// Left-to-right text writing direction.
        case ltr = 1 // TEXT_DIRECTION_LTR
        /// Right-to-left text writing direction.
        case rtl = 2 // TEXT_DIRECTION_RTL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .inherited: return ".inherited"
                case .auto: return ".auto"
                case .ltr: return ".ltr"
                case .rtl: return ".rtl"
            }
            
        }
        
    }
    
    /* Constants */
    /// Sent when the node changes size. Use ``size`` to get the new size.
    public static let notificationResized = 40
    /// Sent when the mouse cursor enters the control's (or any child control's) visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect which Control receives the notification.
    /// 
    /// See also ``notificationMouseEnterSelf``.
    /// 
    public static let notificationMouseEnter = 41
    /// Sent when the mouse cursor leaves the control's (and all child control's) visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect which Control receives the notification.
    /// 
    /// See also ``notificationMouseExitSelf``.
    /// 
    public static let notificationMouseExit = 42
    /// Sent when the mouse cursor enters the control's visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect which Control receives the notification.
    /// 
    /// See also ``notificationMouseEnter``.
    /// 
    public static let notificationMouseEnterSelf = 60
    /// Sent when the mouse cursor leaves the control's visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect which Control receives the notification.
    /// 
    /// See also ``notificationMouseExit``.
    /// 
    public static let notificationMouseExitSelf = 61
    /// Sent when the node grabs focus.
    public static let notificationFocusEnter = 43
    /// Sent when the node loses focus.
    public static let notificationFocusExit = 44
    /// Sent when the node needs to refresh its theme items. This happens in one of the following cases:
    /// 
    /// - The ``theme`` property is changed on this node or any of its ancestors.
    /// 
    /// - The ``themeTypeVariation`` property is changed on this node.
    /// 
    /// - One of the node's theme property overrides is changed.
    /// 
    /// - The node enters the scene tree.
    /// 
    /// > Note: As an optimization, this notification won't be sent from changes that occur while this node is outside of the scene tree. Instead, all of the theme item updates can be applied at once when the node enters the scene tree.
    /// 
    /// > Note: This notification is received alongside ``Node/notificationEnterTree``, so if you are instantiating a scene, the child nodes will not be initialized yet. You can use it to setup theming for this node, child nodes created from script, or if you want to access child nodes added in the editor, make sure the node is ready using ``Node/isNodeReady()``.
    /// 
    public static let notificationThemeChanged = 45
    /// Sent when this node is inside a ``ScrollContainer`` which has begun being scrolled when dragging the scrollable area _with a touch event_. This notification is _not_ sent when scrolling by dragging the scrollbar, scrolling with the mouse wheel or scrolling with keyboard/gamepad events.
    /// 
    /// > Note: This signal is only emitted on Android or iOS, or on desktop/web platforms when ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse`` is enabled.
    /// 
    public static let notificationScrollBegin = 47
    /// Sent when this node is inside a ``ScrollContainer`` which has stopped being scrolled when dragging the scrollable area _with a touch event_. This notification is _not_ sent when scrolling by dragging the scrollbar, scrolling with the mouse wheel or scrolling with keyboard/gamepad events.
    /// 
    /// > Note: This signal is only emitted on Android or iOS, or on desktop/web platforms when ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse`` is enabled.
    /// 
    public static let notificationScrollEnd = 48
    /// Sent when control layout direction is changed.
    public static let notificationLayoutDirectionChanged = 49
    
    /* Properties */
    
    /// Enables whether rendering of ``CanvasItem`` based children should be clipped to this control's rectangle. If `true`, parts of a child which would be visibly outside of this control's rectangle will not be rendered and won't receive input.
    final public var clipContents: Bool {
        get {
            return is_clipping_contents ()
        }
        
        set {
            set_clip_contents (newValue)
        }
        
    }
    
    /// The minimum size of the node's bounding rectangle. If you set it to a value greater than `(0, 0)`, the node's bounding rectangle will always have at least this size. Note that ``Control`` nodes have their internal minimum size returned by ``getMinimumSize()``. It depends on the control's contents, like text, textures, or style boxes. The actual minimum size is the maximum value of this property and the internal minimum size (see ``getCombinedMinimumSize()``).
    final public var customMinimumSize: Vector2 {
        get {
            return get_custom_minimum_size ()
        }
        
        set {
            set_custom_minimum_size (newValue)
        }
        
    }
    
    /// Controls layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
    final public var layoutDirection: Control.LayoutDirection {
        get {
            return get_layout_direction ()
        }
        
        set {
            set_layout_direction (newValue)
        }
        
    }
    
    /// Distance between the node's left edge and its parent control, based on ``anchorLeft``.
    /// 
    /// Offsets are often controlled by one or multiple parent ``Container`` nodes, so you should not modify them manually if your node is a direct child of a ``Container``. Offsets update automatically when you move or resize the node.
    /// 
    final public var offsetLeft: Double {
        get {
            return get_offset (Side (rawValue: 0)!)
        }
        
        set {
            set_offset (Side (rawValue: 0)!, newValue)
        }
        
    }
    
    /// Distance between the node's top edge and its parent control, based on ``anchorTop``.
    /// 
    /// Offsets are often controlled by one or multiple parent ``Container`` nodes, so you should not modify them manually if your node is a direct child of a ``Container``. Offsets update automatically when you move or resize the node.
    /// 
    final public var offsetTop: Double {
        get {
            return get_offset (Side (rawValue: 1)!)
        }
        
        set {
            set_offset (Side (rawValue: 1)!, newValue)
        }
        
    }
    
    /// Distance between the node's right edge and its parent control, based on ``anchorRight``.
    /// 
    /// Offsets are often controlled by one or multiple parent ``Container`` nodes, so you should not modify them manually if your node is a direct child of a ``Container``. Offsets update automatically when you move or resize the node.
    /// 
    final public var offsetRight: Double {
        get {
            return get_offset (Side (rawValue: 2)!)
        }
        
        set {
            set_offset (Side (rawValue: 2)!, newValue)
        }
        
    }
    
    /// Distance between the node's bottom edge and its parent control, based on ``anchorBottom``.
    /// 
    /// Offsets are often controlled by one or multiple parent ``Container`` nodes, so you should not modify them manually if your node is a direct child of a ``Container``. Offsets update automatically when you move or resize the node.
    /// 
    final public var offsetBottom: Double {
        get {
            return get_offset (Side (rawValue: 3)!)
        }
        
        set {
            set_offset (Side (rawValue: 3)!, newValue)
        }
        
    }
    
    /// Controls the direction on the horizontal axis in which the control should grow if its horizontal minimum size is changed to be greater than its current size, as the control always has to be at least the minimum size.
    final public var growHorizontal: Control.GrowDirection {
        get {
            return get_h_grow_direction ()
        }
        
        set {
            set_h_grow_direction (newValue)
        }
        
    }
    
    /// Controls the direction on the vertical axis in which the control should grow if its vertical minimum size is changed to be greater than its current size, as the control always has to be at least the minimum size.
    final public var growVertical: Control.GrowDirection {
        get {
            return get_v_grow_direction ()
        }
        
        set {
            set_v_grow_direction (newValue)
        }
        
    }
    
    /// The node's rotation around its pivot, in radians. See ``pivotOffset`` to change the pivot's position.
    /// 
    /// > Note: This property is edited in the inspector in degrees. If you want to use degrees in a script, use ``rotationDegrees``.
    /// 
    final public var rotation: Double {
        get {
            return get_rotation ()
        }
        
        set {
            set_rotation (newValue)
        }
        
    }
    
    /// Helper property to access ``rotation`` in degrees instead of radians.
    final public var rotationDegrees: Double {
        get {
            return get_rotation_degrees ()
        }
        
        set {
            set_rotation_degrees (newValue)
        }
        
    }
    
    /// The node's scale, relative to its ``size``. Change this property to scale the node around its ``pivotOffset``. The Control's ``tooltipText`` will also scale according to this value.
    /// 
    /// > Note: This property is mainly intended to be used for animation purposes. To support multiple resolutions in your project, use an appropriate viewport stretch mode as described in the <a href="https://docs.godotengine.org/en//tutorials/rendering/multiple_resolutions.html">documentation</a> instead of scaling Controls individually.
    /// 
    /// > Note: ``FontFile/oversampling`` does _not_ take ``Control`` ``scale`` into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling ``ProjectSettings/gui/theme/defaultFontMultichannelSignedDistanceField`` (applies to the default project font only), or enabling **Multichannel Signed Distance Field** in the import options of a DynamicFont for custom fonts. On system fonts, ``SystemFont/multichannelSignedDistanceField`` can be enabled in the inspector.
    /// 
    /// > Note: If the Control node is a child of a ``Container`` node, the scale will be reset to `Vector2(1, 1)` when the scene is instantiated. To set the Control's scale when it's instantiated, wait for one frame using `await get_tree().process_frame` then set its ``scale`` property.
    /// 
    final public var scale: Vector2 {
        get {
            return get_scale ()
        }
        
        set {
            set_scale (newValue)
        }
        
    }
    
    /// By default, the node's pivot is its top-left corner. When you change its ``rotation`` or ``scale``, it will rotate or scale around this pivot. Set this property to ``size`` / 2 to pivot around the Control's center.
    final public var pivotOffset: Vector2 {
        get {
            return get_pivot_offset ()
        }
        
        set {
            set_pivot_offset (newValue)
        }
        
    }
    
    /// Tells the parent ``Container`` nodes how they should resize and place the node on the X axis. Use a combination of the ``Control/SizeFlags`` constants to change the flags. See the constants to learn what each does.
    final public var sizeFlagsHorizontal: Control.SizeFlags {
        get {
            return get_h_size_flags ()
        }
        
        set {
            set_h_size_flags (newValue)
        }
        
    }
    
    /// Tells the parent ``Container`` nodes how they should resize and place the node on the Y axis. Use a combination of the ``Control/SizeFlags`` constants to change the flags. See the constants to learn what each does.
    final public var sizeFlagsVertical: Control.SizeFlags {
        get {
            return get_v_size_flags ()
        }
        
        set {
            set_v_size_flags (newValue)
        }
        
    }
    
    /// If the node and at least one of its neighbors uses the ``SizeFlags/expand`` size flag, the parent ``Container`` will let it take more or less space depending on this property. If this node has a stretch ratio of 2 and its neighbor a ratio of 1, this node will take two thirds of the available space.
    final public var sizeFlagsStretchRatio: Double {
        get {
            return get_stretch_ratio ()
        }
        
        set {
            set_stretch_ratio (newValue)
        }
        
    }
    
    /// If `true`, automatically converts code line numbers, list indices, ``SpinBox`` and ``ProgressBar`` values from the Western Arabic (0..9) to the numeral systems used in current locale.
    /// 
    /// > Note: Numbers within the text are not automatically converted, it can be done manually, using ``TextServer/formatNumber(_:language:)``.
    /// 
    final public var localizeNumeralSystem: Bool {
        get {
            return is_localizing_numeral_system ()
        }
        
        set {
            set_localize_numeral_system (newValue)
        }
        
    }
    
    /// Toggles if any text should automatically change to its translated version depending on the current locale.
    final public var autoTranslate: Bool {
        get {
            return is_auto_translating ()
        }
        
        set {
            set_auto_translate (newValue)
        }
        
    }
    
    /// The default tooltip text. The tooltip appears when the user's mouse cursor stays idle over this control for a few moments, provided that the ``mouseFilter`` property is not ``MouseFilter/ignore``. The time required for the tooltip to appear can be changed with the ``ProjectSettings/gui/timers/tooltipDelaySec`` option. See also ``getTooltip(atPosition:)``.
    /// 
    /// The tooltip popup will use either a default implementation, or a custom one that you can provide by overriding ``_makeCustomTooltip(forText:)``. The default tooltip includes a ``PopupPanel`` and ``Label`` whose theme properties can be customized using ``Theme`` methods with the `"TooltipPanel"` and `"TooltipLabel"` respectively. For example:
    /// 
    final public var tooltipText: String {
        get {
            return get_tooltip_text ()
        }
        
        set {
            set_tooltip_text (newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses the left arrow on the keyboard or left on a gamepad by default. You can change the key by editing the ``ProjectSettings/input/uiLeft`` input action. The node must be a ``Control``. If this property is not set, Godot will give focus to the closest ``Control`` to the left of this one.
    final public var focusNeighborLeft: NodePath {
        get {
            return get_focus_neighbor (Side (rawValue: 0)!)
        }
        
        set {
            set_focus_neighbor (Side (rawValue: 0)!, newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses the top arrow on the keyboard or top on a gamepad by default. You can change the key by editing the ``ProjectSettings/input/uiUp`` input action. The node must be a ``Control``. If this property is not set, Godot will give focus to the closest ``Control`` to the top of this one.
    final public var focusNeighborTop: NodePath {
        get {
            return get_focus_neighbor (Side (rawValue: 1)!)
        }
        
        set {
            set_focus_neighbor (Side (rawValue: 1)!, newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses the right arrow on the keyboard or right on a gamepad by default. You can change the key by editing the ``ProjectSettings/input/uiRight`` input action. The node must be a ``Control``. If this property is not set, Godot will give focus to the closest ``Control`` to the right of this one.
    final public var focusNeighborRight: NodePath {
        get {
            return get_focus_neighbor (Side (rawValue: 2)!)
        }
        
        set {
            set_focus_neighbor (Side (rawValue: 2)!, newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses the down arrow on the keyboard or down on a gamepad by default. You can change the key by editing the ``ProjectSettings/input/uiDown`` input action. The node must be a ``Control``. If this property is not set, Godot will give focus to the closest ``Control`` to the bottom of this one.
    final public var focusNeighborBottom: NodePath {
        get {
            return get_focus_neighbor (Side (rawValue: 3)!)
        }
        
        set {
            set_focus_neighbor (Side (rawValue: 3)!, newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses [kbd]Tab[/kbd] on a keyboard by default. You can change the key by editing the ``ProjectSettings/input/uiFocusNext`` input action.
    /// 
    /// If this property is not set, Godot will select a "best guess" based on surrounding nodes in the scene tree.
    /// 
    final public var focusNext: NodePath {
        get {
            return get_focus_next ()
        }
        
        set {
            set_focus_next (newValue)
        }
        
    }
    
    /// Tells Godot which node it should give focus to if the user presses [kbd]Shift + Tab[/kbd] on a keyboard by default. You can change the key by editing the ``ProjectSettings/input/uiFocusPrev`` input action.
    /// 
    /// If this property is not set, Godot will select a "best guess" based on surrounding nodes in the scene tree.
    /// 
    final public var focusPrevious: NodePath {
        get {
            return get_focus_previous ()
        }
        
        set {
            set_focus_previous (newValue)
        }
        
    }
    
    /// The focus access mode for the control (None, Click or All). Only one Control can be focused at the same time, and it will receive keyboard, gamepad, and mouse signals.
    final public var focusMode: Control.FocusMode {
        get {
            return get_focus_mode ()
        }
        
        set {
            set_focus_mode (newValue)
        }
        
    }
    
    /// Controls whether the control will be able to receive mouse button input events through ``_guiInput(event:)`` and how these events should be handled. Also controls whether the control can receive the [signal mouse_entered], and [signal mouse_exited] signals. See the constants to learn what each does.
    final public var mouseFilter: Control.MouseFilter {
        get {
            return get_mouse_filter ()
        }
        
        set {
            set_mouse_filter (newValue)
        }
        
    }
    
    /// When enabled, scroll wheel events processed by ``_guiInput(event:)`` will be passed to the parent control even if ``mouseFilter`` is set to ``MouseFilter/stop``. As it defaults to true, this allows nested scrollable containers to work out of the box.
    /// 
    /// You should disable it on the root of your UI if you do not want scroll events to go to the ``Node/_unhandledInput(event:)`` processing.
    /// 
    final public var mouseForcePassScrollEvents: Bool {
        get {
            return is_force_pass_scroll_events ()
        }
        
        set {
            set_force_pass_scroll_events (newValue)
        }
        
    }
    
    /// The default cursor shape for this control. Useful for Godot plugins and applications or games that use the system's mouse cursors.
    /// 
    /// > Note: On Linux, shapes may vary depending on the cursor theme of the system.
    /// 
    final public var mouseDefaultCursorShape: Control.CursorShape {
        get {
            return get_default_cursor_shape ()
        }
        
        set {
            set_default_cursor_shape (newValue)
        }
        
    }
    
    /// The ``Node`` which must be a parent of the focused ``Control`` for the shortcut to be activated. If `null`, the shortcut can be activated when any control is focused (a global shortcut). This allows shortcuts to be accepted only when the user has a certain area of the GUI focused.
    final public var shortcutContext: Node? {
        get {
            return get_shortcut_context ()
        }
        
        set {
            set_shortcut_context (newValue)
        }
        
    }
    
    /// The ``Theme`` resource this node and all its ``Control`` and ``Window`` children use. If a child node has its own ``Theme`` resource set, theme items are merged with child's definitions having higher priority.
    /// 
    /// > Note: ``Window`` styles will have no effect unless the window is embedded.
    /// 
    final public var theme: Theme? {
        get {
            return get_theme ()
        }
        
        set {
            set_theme (newValue)
        }
        
    }
    
    /// The name of a theme type variation used by this ``Control`` to look up its own theme items. When empty, the class name of the node is used (e.g. [code skip-lint]Button` for the ``Button`` control), as well as the class names of all parent classes (in order of inheritance).
    /// 
    /// When set, this property gives the highest priority to the type of the specified name. This type can in turn extend another type, forming a dependency chain. See ``Theme/setTypeVariation(themeType:baseType:)``. If the theme item cannot be found using this type or its base types, lookup falls back on the class names.
    /// 
    /// > Note: To look up ``Control``'s own items use various `get_theme_*` methods without specifying `theme_type`.
    /// 
    /// > Note: Theme items are looked for in the tree order, from branch to root, where each ``Control`` node is checked for its ``theme`` property. The earliest match against any type/class name is returned. The project-level Theme and the default Theme are checked last.
    /// 
    final public var themeTypeVariation: StringName {
        get {
            return get_theme_type_variation ()
        }
        
        set {
            set_theme_type_variation (newValue)
        }
        
    }
    
    /* Methods */
    /// Virtual method to be implemented by the user. Returns whether the given `point` is inside this control.
    /// 
    /// If not overridden, default behavior is checking if the point is within control's Rect.
    /// 
    /// > Note: If you want to check if a point is inside the control, you can use `Rect2(Vector2.ZERO, size).has_point(point)`.
    /// 
    @_documentation(visibility: public)
    open func _hasPoint(_ point: Vector2) -> Bool {
        return false
    }
    
    /// User defined BiDi algorithm override function.
    /// 
    /// Returns an ``GArray`` of ``Vector3i`` text ranges and text base directions, in the left-to-right order. Ranges should cover full source `text` without overlaps. BiDi algorithm will be used on each range separately.
    /// 
    @_documentation(visibility: public)
    open func _structuredTextParser(args: GArray, text: String) -> VariantCollection<Vector3i> {
        return VariantCollection<Vector3i>()
    }
    
    /// Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to ``customMinimumSize`` for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
    /// 
    /// If not overridden, defaults to ``Vector2/zero``.
    /// 
    /// > Note: This method will not be called when the script is attached to a ``Control`` node that already overrides its minimum size (e.g. ``Label``, ``Button``, ``PanelContainer`` etc.). It can only be used with most basic GUI nodes, like ``Control``, ``Container``, ``Panel`` etc.
    /// 
    @_documentation(visibility: public)
    open func _getMinimumSize() -> Vector2 {
        return Vector2 ()
    }
    
    /// Virtual method to be implemented by the user. Returns the tooltip text for the position `atPosition` in control's local coordinates, which will typically appear when the cursor is resting over this control. See ``getTooltip(atPosition:)``.
    /// 
    /// > Note: If this method returns an empty ``String``, no tooltip is displayed.
    /// 
    @_documentation(visibility: public)
    open func _getTooltip(atPosition: Vector2) -> String {
        return String ()
    }
    
    /// Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns `null` if there is no data to drag. Controls that want to receive drop data should implement ``_canDropData(atPosition:data:)`` and ``_dropData(atPosition:data:)``. `atPosition` is local to this control. Drag may be forced with ``forceDrag(data:preview:)``.
    /// 
    /// A preview that will follow the mouse that should represent the data can be set with ``setDragPreview(control:)``. A good time to set the preview is in this method.
    /// 
    @_documentation(visibility: public)
    open func _getDragData(atPosition: Vector2) -> Variant? {
        return nil
    }
    
    /// Godot calls this method to test if `data` from a control's ``_getDragData(atPosition:)`` can be dropped at `atPosition`. `atPosition` is local to this control.
    /// 
    /// This method should only be used to test the data. Process the data in ``_dropData(atPosition:data:)``.
    /// 
    @_documentation(visibility: public)
    open func _canDropData(atPosition: Vector2, data: Variant?) -> Bool {
        return false
    }
    
    /// Godot calls this method to pass you the `data` from a control's ``_getDragData(atPosition:)`` result. Godot first calls ``_canDropData(atPosition:data:)`` to test if `data` is allowed to drop at `atPosition` where `atPosition` is local to this control.
    /// 
    @_documentation(visibility: public)
    open func _dropData(atPosition: Vector2, data: Variant?) {
    }
    
    /// Virtual method to be implemented by the user. Returns a ``Control`` node that should be used as a tooltip instead of the default one. The `forText` includes the contents of the ``tooltipText`` property.
    /// 
    /// The returned node must be of type ``Control`` or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When `null` or a non-Control node is returned, the default tooltip will be used instead.
    /// 
    /// The returned node will be added as child to a ``PopupPanel``, so you should only provide the contents of that panel. That ``PopupPanel`` can be themed using ``Theme/setStylebox(name:themeType:texture:)`` for the type `"TooltipPanel"` (see ``tooltipText`` for an example).
    /// 
    /// > Note: The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its ``customMinimumSize`` to some non-zero value.
    /// 
    /// > Note: The node (and any relevant children) should be ``CanvasItem/visible`` when returned, otherwise, the viewport that instantiates it will not be able to calculate its minimum size reliably.
    /// 
    /// **Example of usage with a custom-constructed node:**
    /// 
    /// **Example of usage with a custom scene instance:**
    /// 
    @_documentation(visibility: public)
    open func _makeCustomTooltip(forText: String) -> Object? {
        return Object ()
    }
    
    /// Virtual method to be implemented by the user. Use this method to process and accept inputs on UI elements. See ``acceptEvent()``.
    /// 
    /// **Example usage for clicking a control:**
    /// 
    /// The event won't trigger if:
    /// 
    /// * clicking outside the control (see ``_hasPoint(_:)``);
    /// 
    /// * control has ``mouseFilter`` set to ``MouseFilter/ignore``;
    /// 
    /// * control is obstructed by another ``Control`` on top of it, which doesn't have ``mouseFilter`` set to ``MouseFilter/ignore``;
    /// 
    /// * control's parent has ``mouseFilter`` set to ``MouseFilter/stop`` or has accepted the event;
    /// 
    /// * it happens outside the parent's rectangle and the parent has either ``clipContents`` enabled.
    /// 
    /// > Note: Event position is relative to the control origin.
    /// 
    @_documentation(visibility: public)
    open func _guiInput(event: InputEvent?) {
    }
    
    fileprivate static var method_accept_event: GDExtensionMethodBindPtr = {
        let methodName = StringName("accept_event")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to ``Node/_unhandledInput(event:)`` or ``Node/_unhandledKeyInput(event:)``.
    /// 
    /// > Note: This does not affect the methods in ``Input``, only the way events are propagated.
    /// 
    public final func acceptEvent() {
        gi.object_method_bind_ptrcall(Control.method_accept_event, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_minimum_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the minimum size for this control. See ``customMinimumSize``.
    public final func getMinimumSize() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_minimum_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_combined_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_combined_minimum_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns combined minimum size from ``customMinimumSize`` and ``getMinimumSize()``.
    public final func getCombinedMinimumSize() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_combined_minimum_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_anchors_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_anchors_preset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 509135270)!
            }
            
        }
        
    }()
    
    /// Sets the anchors to a `preset` from ``Control.LayoutPreset`` enum. This is the code equivalent to using the Layout menu in the 2D editor.
    /// 
    /// If `keepOffsets` is `true`, control's position will also be updated.
    /// 
    public final func setAnchorsPreset(_ preset: Control.LayoutPreset, keepOffsets: Bool = false) {
        withUnsafePointer(to: preset.rawValue) { pArg0 in
            withUnsafePointer(to: keepOffsets) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_anchors_preset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_offsets_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_offsets_preset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3724524307)!
            }
            
        }
        
    }()
    
    /// Sets the offsets to a `preset` from ``Control.LayoutPreset`` enum. This is the code equivalent to using the Layout menu in the 2D editor.
    /// 
    /// Use parameter `resizeMode` with constants from ``Control.LayoutPresetMode`` to better determine the resulting size of the ``Control``. Constant size will be ignored if used with presets that change size, e.g. ``LayoutPreset/leftWide``.
    /// 
    /// Use parameter `margin` to determine the gap between the ``Control`` and the edges.
    /// 
    public final func setOffsetsPreset(_ preset: Control.LayoutPreset, resizeMode: Control.LayoutPresetMode = .minsize, margin: Int32 = 0) {
        withUnsafePointer(to: preset.rawValue) { pArg0 in
            withUnsafePointer(to: resizeMode.rawValue) { pArg1 in
                withUnsafePointer(to: margin) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Control.method_set_offsets_preset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_anchors_and_offsets_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_anchors_and_offsets_preset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3724524307)!
            }
            
        }
        
    }()
    
    /// Sets both anchor preset and offset preset. See ``setAnchorsPreset(_:keepOffsets:)`` and ``setOffsetsPreset(_:resizeMode:margin:)``.
    public final func setAnchorsAndOffsetsPreset(_ preset: Control.LayoutPreset, resizeMode: Control.LayoutPresetMode = .minsize, margin: Int32 = 0) {
        withUnsafePointer(to: preset.rawValue) { pArg0 in
            withUnsafePointer(to: resizeMode.rawValue) { pArg1 in
                withUnsafePointer(to: margin) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Control.method_set_anchors_and_offsets_preset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_anchor: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_anchor")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2302782885)!
            }
            
        }
        
    }()
    
    /// Sets the anchor for the specified ``Side`` to `anchor`. A setter method for ``anchorBottom``, ``anchorLeft``, ``anchorRight`` and ``anchorTop``.
    /// 
    /// If `keepOffset` is `true`, offsets aren't updated after this operation.
    /// 
    /// If `pushOppositeAnchor` is `true` and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If `pushOppositeAnchor` was `false`, the left anchor would get value 0.5.
    /// 
    public final func setAnchor(side: Side, anchor: Double, keepOffset: Bool = false, pushOppositeAnchor: Bool = true) {
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: anchor) { pArg1 in
                withUnsafePointer(to: keepOffset) { pArg2 in
                    withUnsafePointer(to: pushOppositeAnchor) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Control.method_set_anchor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_anchor: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_anchor")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2869120046)!
            }
            
        }
        
    }()
    
    /// Returns the anchor for the specified ``Side``. A getter method for ``anchorBottom``, ``anchorLeft``, ``anchorRight`` and ``anchorTop``.
    public final func getAnchor(side: Side) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_get_anchor, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_offset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4290182280)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets the offset for the specified ``Side`` to `offset`. A setter method for ``offsetBottom``, ``offsetLeft``, ``offsetRight`` and ``offsetTop``.
    fileprivate final func set_offset(_ side: Side, _ offset: Double) {
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: offset) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_offset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2869120046)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns the offset for the specified ``Side``. A getter method for ``offsetBottom``, ``offsetLeft``, ``offsetRight`` and ``offsetTop``.
    fileprivate final func get_offset(_ offset: Side) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: offset.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_get_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_anchor_and_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_anchor_and_offset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4031722181)!
            }
            
        }
        
    }()
    
    /// Works the same as ``setAnchor(side:anchor:keepOffset:pushOppositeAnchor:)``, but instead of `keep_offset` argument and automatic update of offset, it allows to set the offset yourself (see ``setOffset(side:offset:)``).
    public final func setAnchorAndOffset(side: Side, anchor: Double, offset: Double, pushOppositeAnchor: Bool = false) {
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: anchor) { pArg1 in
                withUnsafePointer(to: offset) { pArg2 in
                    withUnsafePointer(to: pushOppositeAnchor) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Control.method_set_anchor_and_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_begin")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Sets ``offsetLeft`` and ``offsetTop`` at the same time. Equivalent of changing ``position``.
    public final func setBegin(position: Vector2) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_begin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_end")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Sets ``offsetRight`` and ``offsetBottom`` at the same time.
    public final func setEnd(position: Vector2) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_end, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_position")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2436320129)!
            }
            
        }
        
    }()
    
    /// Sets the ``position`` to given `position`.
    /// 
    /// If `keepOffsets` is `true`, control's anchors will be updated instead of offsets.
    /// 
    public final func setPosition(_ position: Vector2, keepOffsets: Bool = false) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: keepOffsets) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2436320129)!
            }
            
        }
        
    }()
    
    /// Sets the size (see ``size``).
    /// 
    /// If `keepOffsets` is `true`, control's anchors will be updated instead of offsets.
    /// 
    public final func setSize(_ size: Vector2, keepOffsets: Bool = false) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: keepOffsets) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_reset_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("reset_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Resets the size to ``getCombinedMinimumSize()``. This is equivalent to calling `set_size(Vector2())` (or any size below the minimum).
    public final func resetSize() {
        gi.object_method_bind_ptrcall(Control.method_reset_size, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_custom_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_custom_minimum_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_custom_minimum_size(_ size: Vector2) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_custom_minimum_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_global_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_global_position")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2436320129)!
            }
            
        }
        
    }()
    
    /// Sets the ``globalPosition`` to given `position`.
    /// 
    /// If `keepOffsets` is `true`, control's anchors will be updated instead of offsets.
    /// 
    public final func setGlobalPosition(_ position: Vector2, keepOffsets: Bool = false) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: keepOffsets) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_global_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_rotation")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_rotation(_ radians: Double) {
        withUnsafePointer(to: radians) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_rotation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_rotation_degrees: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_rotation_degrees")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_rotation_degrees(_ degrees: Double) {
        withUnsafePointer(to: degrees) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_rotation_degrees, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scale")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scale(_ scale: Vector2) {
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_pivot_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pivot_offset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pivot_offset(_ pivotOffset: Vector2) {
        withUnsafePointer(to: pivotOffset) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_pivot_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_begin")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns ``offsetLeft`` and ``offsetTop``. See also ``position``.
    public final func getBegin() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_begin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_end")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns ``offsetRight`` and ``offsetBottom``.
    public final func getEnd() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_end, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_position")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    public final func getPosition() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    public final func getSize() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rotation")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_rotation() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Control.method_get_rotation, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_rotation_degrees: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rotation_degrees")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_rotation_degrees() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Control.method_get_rotation_degrees, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scale")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scale() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_pivot_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pivot_offset")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_pivot_offset() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_pivot_offset, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_custom_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_custom_minimum_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_custom_minimum_size() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_custom_minimum_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_parent_area_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_parent_area_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the width/height occupied in the parent control.
    public final func getParentAreaSize() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_parent_area_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_global_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_global_position")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    public final func getGlobalPosition() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_global_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_screen_position")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the position of this ``Control`` in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
    /// 
    /// Equals to ``globalPosition`` if the window is embedded (see ``Viewport/guiEmbedSubwindows``).
    /// 
    /// **Example usage for showing a popup:**
    /// 
    public final func getScreenPosition() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Control.method_get_screen_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rect")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the position and size of the control in the coordinate system of the containing node. See ``position``, ``scale`` and ``size``.
    /// 
    /// > Note: If ``rotation`` is not the default rotation, the resulting size is not meaningful.
    /// 
    /// > Note: Setting ``Viewport/guiSnapControlsToPixels`` to `true` can lead to rounding inaccuracies between the displayed control and the returned ``Rect2``.
    /// 
    public final func getRect() -> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall(Control.method_get_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_global_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_global_rect")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the position and size of the control relative to the containing canvas. See ``globalPosition`` and ``size``.
    /// 
    /// > Note: If the node itself or any parent ``CanvasItem`` between the node and the canvas have a non default rotation or skew, the resulting size is likely not meaningful.
    /// 
    /// > Note: Setting ``Viewport/guiSnapControlsToPixels`` to `true` can lead to rounding inaccuracies between the displayed control and the returned ``Rect2``.
    /// 
    public final func getGlobalRect() -> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall(Control.method_get_global_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_focus_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_focus_mode")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3232914922)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_focus_mode(_ mode: Control.FocusMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_focus_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_focus_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_focus_mode")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2132829277)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_focus_mode() -> Control.FocusMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_focus_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.FocusMode (rawValue: _result)!
    }
    
    fileprivate static var method_has_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this is the current focused control. See ``focusMode``.
    public final func hasFocus() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_has_focus, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_grab_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("grab_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Steal the focus from another control and become the focused control (see ``focusMode``).
    /// 
    /// > Note: Using this method together with ``Callable/callDeferred()`` makes it more reliable, especially when called inside ``Node/_ready()``.
    /// 
    public final func grabFocus() {
        gi.object_method_bind_ptrcall(Control.method_grab_focus, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_release_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("release_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Give up the focus. No other control will be able to receive input.
    public final func releaseFocus() {
        gi.object_method_bind_ptrcall(Control.method_release_focus, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_find_prev_valid_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_prev_valid_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Finds the previous (above in the tree) ``Control`` that can receive the focus.
    public final func findPrevValidFocus() -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_find_prev_valid_focus, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_next_valid_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_next_valid_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Finds the next (below in the tree) ``Control`` that can receive the focus.
    public final func findNextValidFocus() -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_find_next_valid_focus, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_valid_focus_neighbor: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_valid_focus_neighbor")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1543910170)!
            }
            
        }
        
    }()
    
    /// Finds the next ``Control`` that can receive the focus on the specified ``Side``.
    /// 
    /// > Note: This is different from ``getFocusNeighbor(side:)``, which returns the path of a specified focus neighbor.
    /// 
    public final func findValidFocusNeighbor(side: Side) -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_find_valid_focus_neighbor, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_h_size_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_h_size_flags")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 394851643)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_h_size_flags(_ flags: Control.SizeFlags) {
        withUnsafePointer(to: flags.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_h_size_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_h_size_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_h_size_flags")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3781367401)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_h_size_flags() -> Control.SizeFlags {
        var _result: Control.SizeFlags = Control.SizeFlags ()
        gi.object_method_bind_ptrcall(Control.method_get_h_size_flags, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_stretch_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_stretch_ratio")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_stretch_ratio(_ ratio: Double) {
        withUnsafePointer(to: ratio) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_stretch_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_stretch_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_stretch_ratio")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_stretch_ratio() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Control.method_get_stretch_ratio, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_v_size_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_v_size_flags")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 394851643)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_size_flags(_ flags: Control.SizeFlags) {
        withUnsafePointer(to: flags.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_v_size_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_v_size_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_v_size_flags")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3781367401)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_v_size_flags() -> Control.SizeFlags {
        var _result: Control.SizeFlags = Control.SizeFlags ()
        gi.object_method_bind_ptrcall(Control.method_get_v_size_flags, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_theme")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2326690814)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme(_ theme: Theme?) {
        withUnsafePointer(to: theme?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_theme, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3846893731)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme() -> Theme? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_get_theme, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_theme_type_variation")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme_type_variation(_ themeType: StringName) {
        withUnsafePointer(to: themeType.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_theme_type_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_type_variation")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme_type_variation() -> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall(Control.method_get_theme_type_variation, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_begin_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("begin_bulk_theme_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Prevents `*_theme_*_override` methods from emitting ``notificationThemeChanged`` until ``endBulkThemeOverride()`` is called.
    public final func beginBulkThemeOverride() {
        gi.object_method_bind_ptrcall(Control.method_begin_bulk_theme_override, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_end_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("end_bulk_theme_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends a bulk theme override update. See ``beginBulkThemeOverride()``.
    public final func endBulkThemeOverride() {
        gi.object_method_bind_ptrcall(Control.method_end_bulk_theme_override, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_add_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_icon_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1373065600)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme icon with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeIconOverride(name:)``.
    /// 
    /// See also ``getThemeIcon(name:themeType:)``.
    /// 
    public final func addThemeIconOverride(name: StringName, texture: Texture2D?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: texture?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_stylebox_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4188838905)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``StyleBox`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeStyleboxOverride(name:)``.
    /// 
    /// See also ``getThemeStylebox(name:themeType:)``.
    /// 
    /// **Example of modifying a property in a StyleBox by duplicating it:**
    /// 
    public final func addThemeStyleboxOverride(name: StringName, stylebox: StyleBox?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: stylebox?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_font_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3518018674)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Font`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontOverride(name:)``.
    /// 
    /// See also ``getThemeFont(name:themeType:)``.
    /// 
    public final func addThemeFontOverride(name: StringName, font: Font?) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: font?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_font_size_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme font size with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontSizeOverride(name:)``.
    /// 
    /// See also ``getThemeFontSize(name:themeType:)``.
    /// 
    public final func addThemeFontSizeOverride(name: StringName, fontSize: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: fontSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_color_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4260178595)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Color`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeColorOverride(name:)``.
    /// 
    /// See also ``getThemeColor(name:themeType:)``.
    /// 
    /// **Example of overriding a label's color and resetting it later:**
    /// 
    public final func addThemeColorOverride(name: StringName, color: Color) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_theme_constant_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme constant with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeConstantOverride(name:)``.
    /// 
    /// See also ``getThemeConstant(name:themeType:)``.
    /// 
    public final func addThemeConstantOverride(name: StringName, constant: Int32) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: constant) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_add_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_icon_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme icon with the specified `name` previously added by ``addThemeIconOverride(name:texture:)`` or via the Inspector dock.
    public final func removeThemeIconOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_stylebox_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``StyleBox`` with the specified `name` previously added by ``addThemeStyleboxOverride(name:stylebox:)`` or via the Inspector dock.
    public final func removeThemeStyleboxOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_font_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Font`` with the specified `name` previously added by ``addThemeFontOverride(name:font:)`` or via the Inspector dock.
    public final func removeThemeFontOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_font_size_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme font size with the specified `name` previously added by ``addThemeFontSizeOverride(name:fontSize:)`` or via the Inspector dock.
    public final func removeThemeFontSizeOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_color_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Color`` with the specified `name` previously added by ``addThemeColorOverride(name:color:)`` or via the Inspector dock.
    public final func removeThemeColorOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_theme_constant_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme constant with the specified `name` previously added by ``addThemeConstantOverride(name:constant:)`` or via the Inspector dock.
    public final func removeThemeConstantOverride(name: StringName) {
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_remove_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_icon")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2336455395)!
            }
            
        }
        
    }()
    
    /// Returns an icon from the first matching ``Theme`` in the tree if that ``Theme`` has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeIcon(name: StringName, themeType: StringName = StringName ("")) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_stylebox")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2759935355)!
            }
            
        }
        
    }()
    
    /// Returns a ``StyleBox`` from the first matching ``Theme`` in the tree if that ``Theme`` has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeStylebox(name: StringName, themeType: StringName = StringName ("")) -> StyleBox? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_font")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 387378635)!
            }
            
        }
        
    }()
    
    /// Returns a ``Font`` from the first matching ``Theme`` in the tree if that ``Theme`` has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFont(name: StringName, themeType: StringName = StringName ("")) -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_font_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229578101)!
            }
            
        }
        
    }()
    
    /// Returns a font size from the first matching ``Theme`` in the tree if that ``Theme`` has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFontSize(name: StringName, themeType: StringName = StringName ("")) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_color")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2377051548)!
            }
            
        }
        
    }()
    
    /// Returns a ``Color`` from the first matching ``Theme`` in the tree if that ``Theme`` has a color item with the specified `name` and `themeType`. If `themeType` is omitted the class name of the current control is used as the type, or ``themeTypeVariation`` if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance. If the type is a variation its base types are checked, in order of dependency, then the control's class name and its parent classes are checked.
    /// 
    /// For the current control its local overrides are considered first (see ``addThemeColorOverride(name:color:)``), then its assigned ``theme``. After the current control, each parent control and its assigned ``theme`` are considered; controls without a ``theme`` assigned are skipped. If no matching ``Theme`` is found in the tree, the custom project ``Theme`` (see ``ProjectSettings/gui/theme/custom``) and the default ``Theme`` are used (see ``ThemeDB``).
    /// 
    public final func getThemeColor(name: StringName, themeType: StringName = StringName ("")) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_constant")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229578101)!
            }
            
        }
        
    }()
    
    /// Returns a constant from the first matching ``Theme`` in the tree if that ``Theme`` has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeConstant(name: StringName, themeType: StringName = StringName ("")) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_get_theme_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_icon_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme icon with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeIconOverride(name:texture:)``.
    /// 
    public final func hasThemeIconOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_icon_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_stylebox_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``StyleBox`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeStyleboxOverride(name:stylebox:)``.
    /// 
    public final func hasThemeStyleboxOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_stylebox_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Font`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontOverride(name:font:)``.
    /// 
    public final func hasThemeFontOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_font_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_size_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme font size with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontSizeOverride(name:fontSize:)``.
    /// 
    public final func hasThemeFontSizeOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_font_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_color_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Color`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeColorOverride(name:color:)``.
    /// 
    public final func hasThemeColorOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_color_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_constant_override")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme constant with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeConstantOverride(name:constant:)``.
    /// 
    public final func hasThemeConstantOverride(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_has_theme_constant_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_icon")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeIcon(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_stylebox")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeStylebox(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_stylebox, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFont(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_font, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_font_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFontSize(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_color")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a color item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeColor(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_color, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_theme_constant")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1187511791)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeConstant(name: StringName, themeType: StringName = StringName ("")) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: themeType.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_has_theme_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_theme_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_base_scale")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the default base scale value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultBaseScale`` value.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultBaseScale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Control.method_get_theme_default_base_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_theme_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_font")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3229501585)!
            }
            
        }
        
    }()
    
    /// Returns the default font from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFont`` value.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFont() -> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_get_theme_default_font, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_theme_default_font_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the default font size value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFontSize`` value.
    /// 
    /// See ``getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFontSize() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Control.method_get_theme_default_font_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_parent_control: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_parent_control")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Returns the parent control node.
    public final func getParentControl() -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_get_parent_control, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_h_grow_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_h_grow_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2022385301)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_h_grow_direction(_ direction: Control.GrowDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_h_grow_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_h_grow_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_h_grow_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635610155)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_h_grow_direction() -> Control.GrowDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_h_grow_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.GrowDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_v_grow_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_v_grow_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2022385301)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_grow_direction(_ direction: Control.GrowDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_v_grow_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_v_grow_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_v_grow_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635610155)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_v_grow_direction() -> Control.GrowDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_v_grow_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.GrowDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_tooltip_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tooltip_text")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tooltip_text(_ hint: String) {
        let hint = GString(hint)
        withUnsafePointer(to: hint.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_tooltip_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tooltip_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tooltip_text")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tooltip_text() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Control.method_get_tooltip_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tooltip")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2895288280)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip text for the position `atPosition` in control's local coordinates, which will typically appear when the cursor is resting over this control. By default, it returns ``tooltipText``.
    /// 
    /// This method can be overridden to customize its behavior. See ``_getTooltip(atPosition:)``.
    /// 
    /// > Note: If this method returns an empty ``String``, no tooltip is displayed.
    /// 
    public final func getTooltip(atPosition: Vector2 = Vector2 (x: 0, y: 0)) -> String {
        let _result = GString ()
        withUnsafePointer(to: atPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_get_tooltip, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_default_cursor_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_cursor_shape")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 217062046)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_cursor_shape(_ shape: Control.CursorShape) {
        withUnsafePointer(to: shape.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_default_cursor_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_cursor_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_cursor_shape")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2359535750)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_cursor_shape() -> Control.CursorShape {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_default_cursor_shape, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.CursorShape (rawValue: _result)!
    }
    
    fileprivate static var method_get_cursor_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cursor_shape")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1395773853)!
            }
            
        }
        
    }()
    
    /// Returns the mouse cursor shape the control displays on mouse hover. See ``Control/CursorShape``.
    public final func getCursorShape(position: Vector2 = Vector2 (x: 0, y: 0)) -> Control.CursorShape {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_get_cursor_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Control.CursorShape (rawValue: _result)!
    }
    
    fileprivate static var method_set_focus_neighbor: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_focus_neighbor")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2024461774)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets the focus neighbor for the specified ``Side`` to the ``Control`` at `neighbor` node path. A setter method for ``focusNeighborBottom``, ``focusNeighborLeft``, ``focusNeighborRight`` and ``focusNeighborTop``.
    fileprivate final func set_focus_neighbor(_ side: Side, _ neighbor: NodePath) {
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: neighbor.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_set_focus_neighbor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_focus_neighbor: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_focus_neighbor")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2757935761)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns the focus neighbor for the specified ``Side``. A getter method for ``focusNeighborBottom``, ``focusNeighborLeft``, ``focusNeighborRight`` and ``focusNeighborTop``.
    /// 
    /// > Note: To find the next ``Control`` on the specific ``Side``, even if a neighbor is not assigned, use ``findValidFocusNeighbor(side:)``.
    /// 
    fileprivate final func get_focus_neighbor(_ side: Side) -> NodePath {
        let _result: NodePath = NodePath ()
        withUnsafePointer(to: side.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_get_focus_neighbor, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_focus_next: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_focus_next")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_focus_next(_ next: NodePath) {
        withUnsafePointer(to: next.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_focus_next, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_focus_next: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_focus_next")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_focus_next() -> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall(Control.method_get_focus_next, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_focus_previous: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_focus_previous")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_focus_previous(_ previous: NodePath) {
        withUnsafePointer(to: previous.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_focus_previous, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_focus_previous: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_focus_previous")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_focus_previous() -> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall(Control.method_get_focus_previous, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_force_drag: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_drag")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3191844692)!
            }
            
        }
        
    }()
    
    /// Forces drag and bypasses ``_getDragData(atPosition:)`` and ``setDragPreview(control:)`` by passing `data` and `preview`. Drag will start even if the mouse is neither over nor pressed on this control.
    /// 
    /// The methods ``_canDropData(atPosition:data:)`` and ``_dropData(atPosition:data:)`` must be implemented on controls that want to receive drop data.
    /// 
    public final func forceDrag(data: Variant?, preview: Control?) {
        withUnsafePointer(to: data.content) { pArg0 in
            withUnsafePointer(to: preview?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Control.method_force_drag, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_mouse_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_mouse_filter")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3891156122)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mouse_filter(_ filter: Control.MouseFilter) {
        withUnsafePointer(to: filter.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_mouse_filter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mouse_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mouse_filter")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1572545674)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mouse_filter() -> Control.MouseFilter {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_mouse_filter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.MouseFilter (rawValue: _result)!
    }
    
    fileprivate static var method_set_force_pass_scroll_events: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_force_pass_scroll_events")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_force_pass_scroll_events(_ forcePassScrollEvents: Bool) {
        withUnsafePointer(to: forcePassScrollEvents) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_force_pass_scroll_events, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_force_pass_scroll_events: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_force_pass_scroll_events")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_force_pass_scroll_events() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_force_pass_scroll_events, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_clip_contents: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_contents")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_contents(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_clip_contents, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_clipping_contents: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_clipping_contents")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_clipping_contents() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_clipping_contents, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_grab_click_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("grab_click_focus")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Creates an ``InputEventMouseButton`` that attempts to click the control. If the event is received, the control acquires focus.
    /// 
    public final func grabClickFocus() {
        gi.object_method_bind_ptrcall(Control.method_grab_click_focus, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_drag_forwarding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_drag_forwarding")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1076571380)!
            }
            
        }
        
    }()
    
    /// Forwards the handling of this control's ``_getDragData(atPosition:)``,  ``_canDropData(atPosition:data:)`` and ``_dropData(atPosition:data:)`` virtual functions to delegate callables.
    /// 
    /// For each argument, if not empty, the delegate callable is used, otherwise the local (virtual) function is used.
    /// 
    /// The function format for each callable should be exactly the same as the virtual functions described above.
    /// 
    public final func setDragForwarding(dragFunc: Callable, canDropFunc: Callable, dropFunc: Callable) {
        withUnsafePointer(to: dragFunc.content) { pArg0 in
            withUnsafePointer(to: canDropFunc.content) { pArg1 in
                withUnsafePointer(to: dropFunc.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Control.method_set_drag_forwarding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_drag_preview: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_drag_preview")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1496901182)!
            }
            
        }
        
    }()
    
    /// Shows the given control at the mouse pointer. A good time to call this method is in ``_getDragData(atPosition:)``. The control must not be in the scene tree. You should not free the control, and you should not keep a reference to the control beyond the duration of the drag. It will be deleted automatically after the drag has ended.
    /// 
    public final func setDragPreview(control: Control?) {
        withUnsafePointer(to: control?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_drag_preview, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drag_successful: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drag_successful")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a drag operation is successful. Alternative to ``Viewport/guiIsDragSuccessful()``.
    /// 
    /// Best used with ``Node/notificationDragEnd``.
    /// 
    public final func isDragSuccessful() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_drag_successful, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_warp_mouse: GDExtensionMethodBindPtr = {
        let methodName = StringName("warp_mouse")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Moves the mouse cursor to `position`, relative to ``position`` of this ``Control``.
    /// 
    /// > Note: ``warpMouse(position:)`` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
    /// 
    public final func warpMouse(position: Vector2) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_warp_mouse, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_shortcut_context: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_shortcut_context")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_context(_ node: Node?) {
        withUnsafePointer(to: node?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_shortcut_context, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_shortcut_context: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_shortcut_context")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_shortcut_context() -> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Control.method_get_shortcut_context, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_update_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_minimum_size")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Invalidates the size cache in this node and in parent nodes up to top level. Intended to be used with ``getMinimumSize()`` when the return value is changed. Setting ``customMinimumSize`` directly calls this method automatically.
    public final func updateMinimumSize() {
        gi.object_method_bind_ptrcall(Control.method_update_minimum_size, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_layout_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3310692370)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_layout_direction(_ direction: Control.LayoutDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_layout_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_layout_direction")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1546772008)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_layout_direction() -> Control.LayoutDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Control.method_get_layout_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.LayoutDirection (rawValue: _result)!
    }
    
    fileprivate static var method_is_layout_rtl: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_layout_rtl")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if layout is right-to-left.
    public final func isLayoutRtl() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_layout_rtl, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_translate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_translate")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_translate(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_auto_translate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_auto_translating: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_auto_translating")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_translating() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_auto_translating, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_localize_numeral_system: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_localize_numeral_system")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_localize_numeral_system(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Control.method_set_localize_numeral_system, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_localizing_numeral_system: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_localizing_numeral_system")
        return withUnsafePointer(to: &Control.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_localizing_numeral_system() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Control.method_is_localizing_numeral_system, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_can_drop_data":
                return _Control_proxy_can_drop_data
            case "_drop_data":
                return _Control_proxy_drop_data
            case "_get_drag_data":
                return _Control_proxy_get_drag_data
            case "_get_minimum_size":
                return _Control_proxy_get_minimum_size
            case "_get_tooltip":
                return _Control_proxy_get_tooltip
            case "_gui_input":
                return _Control_proxy_gui_input
            case "_has_point":
                return _Control_proxy_has_point
            case "_make_custom_tooltip":
                return _Control_proxy_make_custom_tooltip
            case "_structured_text_parser":
                return _Control_proxy_structured_text_parser
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when the control changes size.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.resized.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var resized: SimpleSignal { SimpleSignal (target: self, signalName: "resized") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ event: InputEvent) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? InputEvent ?? lookupObject (nativeHandle: ptr_0!) ?? InputEvent (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the node receives an ``InputEvent``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.guiInput.connect { event in
    ///    print ("caught signal")
    /// }
    /// ```
    public var guiInput: Signal1 { Signal1 (target: self, signalName: "gui_input") }
    
    /// Emitted when the mouse cursor enters the control's (or any child control's) visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect, which Control receives the signal.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseEntered: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_entered") }
    
    /// Emitted when the mouse cursor leaves the control's (and all child control's) visible area, that is not occluded behind other Controls or Windows, provided its ``mouseFilter`` lets the event reach it and regardless if it's currently focused or not.
    /// 
    /// > Note: ``CanvasItem/zIndex`` doesn't affect, which Control receives the signal.
    /// 
    /// > Note: If you want to check whether the mouse truly left the area, ignoring any top nodes, you can use code like this:
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseExited: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_exited") }
    
    /// Emitted when the node gains focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusEntered: SimpleSignal { SimpleSignal (target: self, signalName: "focus_entered") }
    
    /// Emitted when the node loses focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusExited: SimpleSignal { SimpleSignal (target: self, signalName: "focus_exited") }
    
    /// Emitted when one of the size flags changes. See ``sizeFlagsHorizontal`` and ``sizeFlagsVertical``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sizeFlagsChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sizeFlagsChanged: SimpleSignal { SimpleSignal (target: self, signalName: "size_flags_changed") }
    
    /// Emitted when the node's minimum size changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.minimumSizeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var minimumSizeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "minimum_size_changed") }
    
    /// Emitted when the ``notificationThemeChanged`` notification is sent.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.themeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var themeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "theme_changed") }
    
}

// Support methods for proxies
func _Control_proxy_can_drop_data (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._canDropData (atPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee, data: args [1]!.assumingMemoryBound (to: Variant.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _Control_proxy_drop_data (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._dropData (atPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee, data: args [1]!.assumingMemoryBound (to: Variant.self).pointee)
}

func _Control_proxy_get_drag_data (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getDragData (atPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes(of: ret.content, as: Variant.ContentType.self)
    ret?.content = Variant.zero
}

func _Control_proxy_get_minimum_size (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getMinimumSize ()
    retPtr!.storeBytes (of: ret, as: Vector2.self)
}

func _Control_proxy_get_tooltip (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = GString (swiftObject._getTooltip (atPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee))
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _Control_proxy_gui_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._guiInput (event: lookupLiveObject (handleAddress: resolved_0) as? InputEvent ?? lookupObject (nativeHandle: resolved_0)!)
}

func _Control_proxy_has_point (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._hasPoint (args [0]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _Control_proxy_make_custom_tooltip (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._makeCustomTooltip (forText: GString.stringFromGStringPtr (ptr: args [0]!) ?? "")
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Object
}

func _Control_proxy_structured_text_parser (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Control>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._structuredTextParser (args: GArray (content: args [0]!.assumingMemoryBound (to: Int64.self).pointee), text: GString.stringFromGStringPtr (ptr: args [1]!) ?? "")
    retPtr!.storeBytes (of: ret.array.content, as: type (of: ret.array.content)) // typedarray::Vector3i
}

