// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control for displaying text that can contain different font styles, images, and basic formatting.
/// 
/// A control for displaying text that can contain custom fonts, images, and basic formatting. ``RichTextLabel`` manages these as an internal tag stack. It also adapts itself to given width/heights.
/// 
/// > Note: Assignments to ``text`` clear the tag stack and reconstruct it from the property's contents. Any edits made to ``text`` will erase previous edits made from other manual sources such as ``appendText(bbcode:)`` and the `push_*` / ``pop()`` methods.
/// 
/// > Note: RichTextLabel doesn't support entangled BBCode tags. For example, instead of using [code skip-lint]**bold_bold italic**italic_`, use [code skip-lint]**bold_bold italic_**_italic_`.
/// 
/// > Note: `push_*/pop_*` functions won't affect BBCode.
/// 
/// > Note: Unlike ``Label``, ``RichTextLabel`` doesn't have a _property_ to horizontally align text to the center. Instead, enable ``bbcodeEnabled`` and surround the text in a [code skip-lint][center]` tag as follows: [code skip-lint][center]Example[/center]`. There is currently no built-in way to vertically align text either, but this can be emulated by relying on anchors/containers and the ``fitContent`` property.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``metaClicked``
/// - ``metaHoverStarted``
/// - ``metaHoverEnded``
/// - ``finished``
open class RichTextLabel: Control {
    override open class var godotClassName: StringName { "RichTextLabel" }
    public enum ListType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Each list item has a number marker.
        case numbers = 0 // LIST_NUMBERS
        /// Each list item has a letter marker.
        case letters = 1 // LIST_LETTERS
        /// Each list item has a roman number marker.
        case roman = 2 // LIST_ROMAN
        /// Each list item has a filled circle marker.
        case dots = 3 // LIST_DOTS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .numbers: return ".numbers"
                case .letters: return ".letters"
                case .roman: return ".roman"
                case .dots: return ".dots"
            }
            
        }
        
    }
    
    public enum MenuItems: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Copies the selected text.
        case copy = 0 // MENU_COPY
        /// Selects the whole ``RichTextLabel`` text.
        case selectAll = 1 // MENU_SELECT_ALL
        /// Represents the size of the ``RichTextLabel/MenuItems`` enum.
        case max = 2 // MENU_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .copy: return ".copy"
                case .selectAll: return ".selectAll"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum MetaUnderline: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Meta tag does not display an underline, even if ``metaUnderlined`` is `true`.
        case never = 0 // META_UNDERLINE_NEVER
        /// If ``metaUnderlined`` is `true`, meta tag always display an underline.
        case always = 1 // META_UNDERLINE_ALWAYS
        /// If ``metaUnderlined`` is `true`, meta tag display an underline when the mouse cursor is over it.
        case onHover = 2 // META_UNDERLINE_ON_HOVER
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .never: return ".never"
                case .always: return ".always"
                case .onHover: return ".onHover"
            }
            
        }
        
    }
    
    public struct ImageUpdateMask: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image texture.
        public static let texture = ImageUpdateMask (rawValue: 1)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image size.
        public static let size = ImageUpdateMask (rawValue: 2)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image color.
        public static let color = ImageUpdateMask (rawValue: 4)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image inline alignment.
        public static let alignment = ImageUpdateMask (rawValue: 8)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image texture region.
        public static let region = ImageUpdateMask (rawValue: 16)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image padding.
        public static let pad = ImageUpdateMask (rawValue: 32)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image tooltip.
        public static let tooltip = ImageUpdateMask (rawValue: 64)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image width from/to percents.
        public static let widthInPercent = ImageUpdateMask (rawValue: 128)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.texture) { result += "texture, " }
            if self.contains (.size) { result += "size, " }
            if self.contains (.color) { result += "color, " }
            if self.contains (.alignment) { result += "alignment, " }
            if self.contains (.region) { result += "region, " }
            if self.contains (.pad) { result += "pad, " }
            if self.contains (.tooltip) { result += "tooltip, " }
            if self.contains (.widthInPercent) { result += "widthInPercent, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    
    /* Properties */
    
    /// If `true`, the label uses BBCode formatting.
    /// 
    /// > Note: This only affects the contents of ``text``, not the tag stack.
    /// 
    final public var bbcodeEnabled: Bool {
        get {
            return is_using_bbcode ()
        }
        
        set {
            set_use_bbcode (newValue)
        }
        
    }
    
    /// The label's text in BBCode format. Is not representative of manual modifications to the internal tag stack. Erases changes made by other methods when edited.
    /// 
    /// > Note: If ``bbcodeEnabled`` is `true`, it is unadvised to use the `+=` operator with ``text`` (e.g. `text += "some string"`) as it replaces the whole text and can cause slowdowns. It will also erase all BBCode that was added to stack using `push_*` methods. Use ``appendText(bbcode:)`` for adding text instead, unless you absolutely need to close a tag that was opened in an earlier method call.
    /// 
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// If `true`, the label's minimum size will be automatically updated to fit its content, matching the behavior of ``Label``.
    final public var fitContent: Bool {
        get {
            return is_fit_content_enabled ()
        }
        
        set {
            set_fit_content (newValue)
        }
        
    }
    
    /// If `true`, the scrollbar is visible. Setting this to `false` does not block scrolling completely. See ``scrollToLine(_:)``.
    final public var scrollActive: Bool {
        get {
            return is_scroll_active ()
        }
        
        set {
            set_scroll_active (newValue)
        }
        
    }
    
    /// If `true`, the window scrolls down to display new content automatically.
    final public var scrollFollowing: Bool {
        get {
            return is_scroll_following ()
        }
        
        set {
            set_scroll_follow (newValue)
        }
        
    }
    
    /// If set to something other than ``TextServer/AutowrapMode/off``, the text gets wrapped inside the node's bounding rectangle. To see how each mode behaves, see ``TextServer.AutowrapMode``.
    final public var autowrapMode: TextServer.AutowrapMode {
        get {
            return get_autowrap_mode ()
        }
        
        set {
            set_autowrap_mode (newValue)
        }
        
    }
    
    /// The number of spaces associated with a single tab length. Does not affect `\t` in text tags, only indent tags.
    final public var tabSize: Int32 {
        get {
            return get_tab_size ()
        }
        
        set {
            set_tab_size (newValue)
        }
        
    }
    
    /// If `true`, a right-click displays the context menu.
    final public var contextMenuEnabled: Bool {
        get {
            return is_context_menu_enabled ()
        }
        
        set {
            set_context_menu_enabled (newValue)
        }
        
    }
    
    /// If `true`, shortcut keys for context menu items are enabled, even if the context menu is disabled.
    final public var shortcutKeysEnabled: Bool {
        get {
            return is_shortcut_keys_enabled ()
        }
        
        set {
            set_shortcut_keys_enabled (newValue)
        }
        
    }
    
    /// The currently installed custom effects. This is an array of ``RichTextEffect``s.
    /// 
    /// To add a custom effect, it's more convenient to use ``installEffect(_:)``.
    /// 
    final public var customEffects: GArray {
        get {
            return get_effects ()
        }
        
        set {
            set_effects (newValue)
        }
        
    }
    
    /// If `true`, the label underlines meta tags such as [code skip-lint][url]{text}</a>`. These tags can call a function when clicked if [signal meta_clicked] is connected to a function.
    final public var metaUnderlined: Bool {
        get {
            return is_meta_underlined ()
        }
        
        set {
            set_meta_underline (newValue)
        }
        
    }
    
    /// If `true`, the label underlines hint tags such as [code skip-lint][hint=description]{text}[/hint]`.
    final public var hintUnderlined: Bool {
        get {
            return is_hint_underlined ()
        }
        
        set {
            set_hint_underline (newValue)
        }
        
    }
    
    /// If `true`, text processing is done in a background thread.
    final public var threaded: Bool {
        get {
            return is_threaded ()
        }
        
        set {
            set_threaded (newValue)
        }
        
    }
    
    /// The delay after which the loading progress bar is displayed, in milliseconds. Set to `-1` to disable progress bar entirely.
    /// 
    /// > Note: Progress bar is displayed only if ``threaded`` is enabled.
    /// 
    final public var progressBarDelay: Int32 {
        get {
            return get_progress_bar_delay ()
        }
        
        set {
            set_progress_bar_delay (newValue)
        }
        
    }
    
    /// If `true`, the label allows text selection.
    final public var selectionEnabled: Bool {
        get {
            return is_selection_enabled ()
        }
        
        set {
            set_selection_enabled (newValue)
        }
        
    }
    
    /// If `true`, the selected text will be deselected when focus is lost.
    final public var deselectOnFocusLossEnabled: Bool {
        get {
            return is_deselect_on_focus_loss_enabled ()
        }
        
        set {
            set_deselect_on_focus_loss_enabled (newValue)
        }
        
    }
    
    /// If `true`, allow drag and drop of selected text.
    final public var dragAndDropSelectionEnabled: Bool {
        get {
            return is_drag_and_drop_selection_enabled ()
        }
        
        set {
            set_drag_and_drop_selection_enabled (newValue)
        }
        
    }
    
    /// The number of characters to display. If set to `-1`, all characters are displayed. This can be useful when animating the text appearing in a dialog box.
    /// 
    /// > Note: Setting this property updates ``visibleRatio`` accordingly.
    /// 
    final public var visibleCharacters: Int32 {
        get {
            return get_visible_characters ()
        }
        
        set {
            set_visible_characters (newValue)
        }
        
    }
    
    /// Sets the clipping behavior when ``visibleCharacters`` or ``visibleRatio`` is set. See ``TextServer.VisibleCharactersBehavior`` for more info.
    final public var visibleCharactersBehavior: TextServer.VisibleCharactersBehavior {
        get {
            return get_visible_characters_behavior ()
        }
        
        set {
            set_visible_characters_behavior (newValue)
        }
        
    }
    
    /// The fraction of characters to display, relative to the total number of characters (see ``getTotalCharacterCount()``). If set to `1.0`, all characters are displayed. If set to `0.5`, only half of the characters will be displayed. This can be useful when animating the text appearing in a dialog box.
    /// 
    /// > Note: Setting this property updates ``visibleCharacters`` accordingly.
    /// 
    final public var visibleRatio: Double {
        get {
            return get_visible_ratio ()
        }
        
        set {
            set_visible_ratio (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /// Set BiDi algorithm override for the structured text.
    final public var structuredTextBidiOverride: TextServer.StructuredTextParser {
        get {
            return get_structured_text_bidi_override ()
        }
        
        set {
            set_structured_text_bidi_override (newValue)
        }
        
    }
    
    /// Set additional options for BiDi override.
    final public var structuredTextBidiOverrideOptions: GArray {
        get {
            return get_structured_text_bidi_override_options ()
        }
        
        set {
            set_structured_text_bidi_override_options (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_parsed_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_parsed_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the text without BBCode mark-up.
    public final func getParsedText() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_parsed_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_add_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds raw non-BBCode-parsed text to the tag stack.
    public final func addText(_ text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_add_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text(_ text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_image: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_image")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3017663154)!
            }
            
        }
        
    }()
    
    /// Adds an image's opening and closing tags to the tag stack, optionally providing a `width` and `height` to resize the image, a `color` to tint the image and a `region` to only use parts of the image.
    /// 
    /// If `width` or `height` is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
    /// 
    /// If `width` and `height` are not set, but `region` is, the region's rect will be used.
    /// 
    /// `key` is an optional identifier, that can be used to modify the image via ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)``.
    /// 
    /// If `pad` is set, and the image is smaller than the size specified by `width` and `height`, the image padding is added to match the size instead of upscaling.
    /// 
    /// If `sizeInPercent` is set, `width` and `height` values are percentages of the control width instead of pixels.
    /// 
    public final func addImage(_ image: Texture2D?, width: Int32 = 0, height: Int32 = 0, color: Color = Color (r: 1, g: 1, b: 1, a: 1), inlineAlign: InlineAlignment = .center, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), key: Variant?, pad: Bool = false, tooltip: String = "", sizeInPercent: Bool = false) {
        withUnsafePointer(to: image?.handle) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: height) { pArg2 in
                    withUnsafePointer(to: color) { pArg3 in
                        withUnsafePointer(to: inlineAlign.rawValue) { pArg4 in
                            withUnsafePointer(to: region) { pArg5 in
                                withUnsafePointer(to: key.content) { pArg6 in
                                    withUnsafePointer(to: pad) { pArg7 in
                                        let tooltip = GString(tooltip)
                                        withUnsafePointer(to: tooltip.content) { pArg8 in
                                            withUnsafePointer(to: sizeInPercent) { pArg9 in
                                                withUnsafePointer(to: UnsafeRawPointersN10(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8, pArg9)) { pArgs in
                                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 10) { pArgs in
                                                        gi.object_method_bind_ptrcall(RichTextLabel.method_add_image, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                                    }
                                                    
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_update_image: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_image")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 815048486)!
            }
            
        }
        
    }()
    
    /// Updates the existing images with the key `key`. Only properties specified by `mask` bits are updated. See ``addImage(_:width:height:color:inlineAlign:region:key:pad:tooltip:sizeInPercent:)``.
    public final func updateImage(key: Variant?, mask: RichTextLabel.ImageUpdateMask, image: Texture2D?, width: Int32 = 0, height: Int32 = 0, color: Color = Color (r: 1, g: 1, b: 1, a: 1), inlineAlign: InlineAlignment = .center, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), pad: Bool = false, tooltip: String = "", sizeInPercent: Bool = false) {
        withUnsafePointer(to: key.content) { pArg0 in
            withUnsafePointer(to: mask.rawValue) { pArg1 in
                withUnsafePointer(to: image?.handle) { pArg2 in
                    withUnsafePointer(to: width) { pArg3 in
                        withUnsafePointer(to: height) { pArg4 in
                            withUnsafePointer(to: color) { pArg5 in
                                withUnsafePointer(to: inlineAlign.rawValue) { pArg6 in
                                    withUnsafePointer(to: region) { pArg7 in
                                        withUnsafePointer(to: pad) { pArg8 in
                                            let tooltip = GString(tooltip)
                                            withUnsafePointer(to: tooltip.content) { pArg9 in
                                                withUnsafePointer(to: sizeInPercent) { pArg10 in
                                                    withUnsafePointer(to: UnsafeRawPointersN11(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8, pArg9, pArg10)) { pArgs in
                                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 11) { pArgs in
                                                            gi.object_method_bind_ptrcall(RichTextLabel.method_update_image, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                                        }
                                                        
                                                    }
                                                    
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_newline: GDExtensionMethodBindPtr = {
        let methodName = StringName("newline")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a newline tag to the tag stack.
    public final func newline() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_newline, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_remove_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_paragraph")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3262369265)!
            }
            
        }
        
    }()
    
    /// Removes a paragraph of content from the label. Returns `true` if the paragraph exists.
    /// 
    /// The `paragraph` argument is the index of the paragraph to remove, it can take values in the interval `[0, get_paragraph_count() - 1]`.
    /// 
    /// If `noInvalidate` is set to `true`, cache for the subsequent paragraphs is not invalidated. Use it for faster updates if deleted paragraph is fully self-contained (have no unclosed tags), or this call is part of the complex edit operation and ``invalidateParagraph(_:)`` will be called at the end of operation.
    /// 
    public final func removeParagraph(_ paragraph: Int32, noInvalidate: Bool = false) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: paragraph) { pArg0 in
            withUnsafePointer(to: noInvalidate) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_remove_paragraph, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_invalidate_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName("invalidate_paragraph")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3067735520)!
            }
            
        }
        
    }()
    
    /// Invalidates `paragraph` and all subsequent paragraphs cache.
    public final func invalidateParagraph(_ paragraph: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: paragraph) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_invalidate_paragraph, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_push_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_font")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2347424842)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag to the tag stack. Overrides default fonts for its duration.
    /// 
    /// Passing `0` to `fontSize` will use the existing default font size.
    /// 
    public final func pushFont(_ font: Font?, fontSize: Int32 = 0) {
        withUnsafePointer(to: font?.handle) { pArg0 in
            withUnsafePointer(to: fontSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_push_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_font_size")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font_size]` tag to the tag stack. Overrides default font size for its duration.
    public final func pushFontSize(_ fontSize: Int32) {
        withUnsafePointer(to: fontSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_font_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_normal: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_normal")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a normal font to the tag stack.
    public final func pushNormal() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_normal, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_bold: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_bold")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a bold font to the tag stack. This is the same as adding a [code skip-lint]**` tag if not currently in a [code skip-lint]_` tag.
    public final func pushBold() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_bold, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_bold_italics: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_bold_italics")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a bold italics font to the tag stack.
    public final func pushBoldItalics() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_bold_italics, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_italics: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_italics")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with an italics font to the tag stack. This is the same as adding an [code skip-lint]_` tag if not currently in a [code skip-lint]**` tag.
    public final func pushItalics() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_italics, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_mono: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_mono")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a monospace font to the tag stack.
    public final func pushMono() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_mono, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_color")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][color]` tag to the tag stack.
    public final func pushColor(_ color: Color) {
        withUnsafePointer(to: color) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_outline_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_outline_size")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][outline_size]` tag to the tag stack. Overrides default text outline size for its duration.
    public final func pushOutlineSize(_ outlineSize: Int32) {
        withUnsafePointer(to: outlineSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_outline_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_outline_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_outline_color")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][outline_color]` tag to the tag stack. Adds text outline for its duration.
    public final func pushOutlineColor(_ color: Color) {
        withUnsafePointer(to: color) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_outline_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_paragraph")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3089306873)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][p]` tag to the tag stack.
    public final func pushParagraph(alignment: HorizontalAlignment, baseDirection: Control.TextDirection = .auto, language: String = "", stParser: TextServer.StructuredTextParser = .`default`, justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound, .skipLastLine, .doNotSkipSingleLine], tabStops: PackedFloat32Array = PackedFloat32Array()) {
        withUnsafePointer(to: alignment.rawValue) { pArg0 in
            withUnsafePointer(to: baseDirection.rawValue) { pArg1 in
                let language = GString(language)
                withUnsafePointer(to: language.content) { pArg2 in
                    withUnsafePointer(to: stParser.rawValue) { pArg3 in
                        withUnsafePointer(to: justificationFlags.rawValue) { pArg4 in
                            withUnsafePointer(to: tabStops.content) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(RichTextLabel.method_push_paragraph, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_indent")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds an [code skip-lint][indent]` tag to the tag stack. Multiplies `level` by current ``tabSize`` to determine new margin length.
    public final func pushIndent(level: Int32) {
        withUnsafePointer(to: level) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_indent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_list")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3017143144)!
            }
            
        }
        
    }()
    
    /// Adds [code skip-lint][ol]` or [code skip-lint][ul]` tag to the tag stack. Multiplies `level` by current ``tabSize`` to determine new margin length.
    public final func pushList(level: Int32, type: RichTextLabel.ListType, capitalize: Bool, bullet: String = "â€¢") {
        withUnsafePointer(to: level) { pArg0 in
            withUnsafePointer(to: type.rawValue) { pArg1 in
                withUnsafePointer(to: capitalize) { pArg2 in
                    let bullet = GString(bullet)
                    withUnsafePointer(to: bullet.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RichTextLabel.method_push_list, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_meta: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_meta")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2206155733)!
            }
            
        }
        
    }()
    
    /// Adds a meta tag to the tag stack. Similar to the BBCode [code skip-lint]<a href="something">{text}</a>`, but supports non-``String`` metadata types.
    /// 
    /// If ``metaUnderlined`` is `true`, meta tags display an underline. This behavior can be customized with `underlineMode`.
    /// 
    /// > Note: Meta tags do nothing by default when clicked. To assign behavior when clicked, connect [signal meta_clicked] to a function that is called when the meta tag is clicked.
    /// 
    public final func pushMeta(data: Variant?, underlineMode: RichTextLabel.MetaUnderline = .always) {
        withUnsafePointer(to: data.content) { pArg0 in
            withUnsafePointer(to: underlineMode.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_push_meta, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_hint")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][hint]` tag to the tag stack. Same as BBCode [code skip-lint][hint=something]{text}[/hint]`.
    public final func pushHint(description: String) {
        let description = GString(description)
        withUnsafePointer(to: description.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_hint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_language")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds language code used for text shaping algorithm and Open-Type font features.
    public final func pushLanguage(_ language: String) {
        let language = GString(language)
        withUnsafePointer(to: language.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_underline")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][u]` tag to the tag stack.
    public final func pushUnderline() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_underline, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_strikethrough: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_strikethrough")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][s]` tag to the tag stack.
    public final func pushStrikethrough() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_strikethrough, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_table: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_table")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2623499273)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][table=columns,inline_align]` tag to the tag stack. Use ``setTableColumnExpand(column:expand:ratio:)`` to set column expansion ratio. Use ``pushCell()`` to add cells.
    public final func pushTable(columns: Int32, inlineAlign: InlineAlignment = .top, alignToRow: Int32 = -1) {
        withUnsafePointer(to: columns) { pArg0 in
            withUnsafePointer(to: inlineAlign.rawValue) { pArg1 in
                withUnsafePointer(to: alignToRow) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RichTextLabel.method_push_table, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_dropcap: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_dropcap")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4061635501)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][dropcap]` tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
    public final func pushDropcap(string: String, font: Font?, size: Int32, dropcapMargins: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), color: Color = Color (r: 1, g: 1, b: 1, a: 1), outlineSize: Int32 = 0, outlineColor: Color = Color (r: 0, g: 0, b: 0, a: 0)) {
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: font?.handle) { pArg1 in
                withUnsafePointer(to: size) { pArg2 in
                    withUnsafePointer(to: dropcapMargins) { pArg3 in
                        withUnsafePointer(to: color) { pArg4 in
                            withUnsafePointer(to: outlineSize) { pArg5 in
                                withUnsafePointer(to: outlineColor) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(RichTextLabel.method_push_dropcap, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_table_column_expand: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_table_column_expand")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2185176273)!
            }
            
        }
        
    }()
    
    /// Edits the selected column's expansion options. If `expand` is `true`, the column expands in proportion to its expansion ratio versus the other columns' ratios.
    /// 
    /// For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
    /// 
    /// If `expand` is `false`, the column will not contribute to the total ratio.
    /// 
    public final func setTableColumnExpand(column: Int32, expand: Bool, ratio: Int32 = 1) {
        withUnsafePointer(to: column) { pArg0 in
            withUnsafePointer(to: expand) { pArg1 in
                withUnsafePointer(to: ratio) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RichTextLabel.method_set_table_column_expand, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cell_row_background_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_row_background_color")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3465483165)!
            }
            
        }
        
    }()
    
    /// Sets color of a table cell. Separate colors for alternating rows can be specified.
    public final func setCellRowBackgroundColor(oddRowBg: Color, evenRowBg: Color) {
        withUnsafePointer(to: oddRowBg) { pArg0 in
            withUnsafePointer(to: evenRowBg) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_set_cell_row_background_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cell_border_color: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_border_color")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Sets color of a table cell border.
    public final func setCellBorderColor(_ color: Color) {
        withUnsafePointer(to: color) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_cell_border_color, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cell_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_size_override")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3108078480)!
            }
            
        }
        
    }()
    
    /// Sets minimum and maximum size overrides for a table cell.
    public final func setCellSizeOverride(minSize: Vector2, maxSize: Vector2) {
        withUnsafePointer(to: minSize) { pArg0 in
            withUnsafePointer(to: maxSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_set_cell_size_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cell_padding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell_padding")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2046264180)!
            }
            
        }
        
    }()
    
    /// Sets inner padding of a table cell.
    public final func setCellPadding(_ padding: Rect2) {
        withUnsafePointer(to: padding) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_cell_padding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_cell")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][cell]` tag to the tag stack. Must be inside a [code skip-lint][table]` tag. See ``pushTable(columns:inlineAlign:alignToRow:)`` for details. Use ``setTableColumnExpand(column:expand:ratio:)`` to set column expansion ratio, ``setCellBorderColor(_:)`` to set cell border, ``setCellRowBackgroundColor(oddRowBg:evenRowBg:)`` to set cell background, ``setCellSizeOverride(minSize:maxSize:)`` to override cell size, and ``setCellPadding(_:)`` to set padding.
    public final func pushCell() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_cell, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_push_fgcolor: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_fgcolor")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][fgcolor]` tag to the tag stack.
    public final func pushFgcolor(_ fgcolor: Color) {
        withUnsafePointer(to: fgcolor) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_fgcolor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_bgcolor: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_bgcolor")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][bgcolor]` tag to the tag stack.
    public final func pushBgcolor(_ bgcolor: Color) {
        withUnsafePointer(to: bgcolor) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_push_bgcolor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_customfx: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_customfx")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2337942958)!
            }
            
        }
        
    }()
    
    /// Adds a custom effect tag to the tag stack. The effect does not need to be in ``customEffects``. The environment is directly passed to the effect.
    public final func pushCustomfx(effect: RichTextEffect?, env: GDictionary) {
        withUnsafePointer(to: effect?.handle) { pArg0 in
            withUnsafePointer(to: env.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RichTextLabel.method_push_customfx, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_context: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_context")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a context marker to the tag stack. See ``popContext()``.
    public final func pushContext() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_push_context, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_pop_context: GDExtensionMethodBindPtr = {
        let methodName = StringName("pop_context")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates tags opened after the last ``pushContext()`` call (including context marker), or all tags if there's no context marker on the stack.
    public final func popContext() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_pop_context, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_pop: GDExtensionMethodBindPtr = {
        let methodName = StringName("pop")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates the current tag. Use after `push_*` methods to close BBCodes manually. Does not need to follow `add_*` methods.
    public final func pop() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_pop, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_pop_all: GDExtensionMethodBindPtr = {
        let methodName = StringName("pop_all")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates all tags opened by `push_*` methods.
    public final func popAll() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_pop_all, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the tag stack, causing the label to display nothing.
    /// 
    /// > Note: This method does not affect ``text``, and its contents will show again if the label is redrawn. However, setting ``text`` to an empty ``String`` also clears the stack.
    /// 
    public final func clear() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_structured_text_bidi_override")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 55961453)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override(_ parser: TextServer.StructuredTextParser) {
        withUnsafePointer(to: parser.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_structured_text_bidi_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_structured_text_bidi_override")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3385126229)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override() -> TextServer.StructuredTextParser {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_structured_text_bidi_override, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.StructuredTextParser (rawValue: _result)!
    }
    
    fileprivate static var method_set_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_structured_text_bidi_override_options")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override_options(_ args: GArray) {
        withUnsafePointer(to: args.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_structured_text_bidi_override_options")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override_options() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_structured_text_bidi_override_options, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text_direction")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction(_ direction: Control.TextDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_text_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_direction")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction() -> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_text_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_language")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language(_ language: String) {
        let language = GString(language)
        withUnsafePointer(to: language.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_language")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_language, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_autowrap_mode")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3289138044)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autowrap_mode(_ autowrapMode: TextServer.AutowrapMode) {
        withUnsafePointer(to: autowrapMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_autowrap_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_autowrap_mode")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1549071663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_autowrap_mode() -> TextServer.AutowrapMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_autowrap_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.AutowrapMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_meta_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_meta_underline")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_meta_underline(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_meta_underline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_meta_underlined: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_meta_underlined")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_meta_underlined() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_meta_underlined, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hint_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hint_underline")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hint_underline(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_hint_underline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_hint_underlined: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hint_underlined")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hint_underlined() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_hint_underlined, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_active: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scroll_active")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_active(_ active: Bool) {
        withUnsafePointer(to: active) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_scroll_active, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_scroll_active: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_scroll_active")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_scroll_active() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_scroll_active, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_follow: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scroll_follow")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_follow(_ follow: Bool) {
        withUnsafePointer(to: follow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_scroll_follow, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_scroll_following: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_scroll_following")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_scroll_following() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_scroll_following, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_v_scroll_bar: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_v_scroll_bar")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2630340773)!
            }
            
        }
        
    }()
    
    /// Returns the vertical scrollbar.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getVScrollBar() -> VScrollBar? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_v_scroll_bar, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_scroll_to_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("scroll_to_line")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Scrolls the window's top line to match `line`.
    public final func scrollToLine(_ line: Int32) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_scroll_to_line, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_scroll_to_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName("scroll_to_paragraph")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Scrolls the window's top line to match first line of the `paragraph`.
    public final func scrollToParagraph(_ paragraph: Int32) {
        withUnsafePointer(to: paragraph) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_scroll_to_paragraph, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_scroll_to_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("scroll_to_selection")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Scrolls to the beginning of the current selection.
    public final func scrollToSelection() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_scroll_to_selection, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tab_size")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_size(_ spaces: Int32) {
        withUnsafePointer(to: spaces) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_tab_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tab_size")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_tab_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_fit_content: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_fit_content")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fit_content(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_fit_content, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_fit_content_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_fit_content_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_fit_content_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_fit_content_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_selection_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_selection_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_selection_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_selection_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_selection_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_selection_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_context_menu_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_context_menu_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_context_menu_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_context_menu_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_context_menu_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_context_menu_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_shortcut_keys_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_keys_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_shortcut_keys_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_shortcut_keys_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_shortcut_keys_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_deselect_on_focus_loss_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deselect_on_focus_loss_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_deselect_on_focus_loss_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deselect_on_focus_loss_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_drag_and_drop_selection_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_and_drop_selection_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drag_and_drop_selection_enabled")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drag_and_drop_selection_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_drag_and_drop_selection_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_from: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selection_from")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current selection first character index if a selection is active, `-1` otherwise. Does not include BBCodes.
    public final func getSelectionFrom() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_selection_from, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_to: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selection_to")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current selection last character index if a selection is active, `-1` otherwise. Does not include BBCodes.
    public final func getSelectionTo() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_selection_to, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_all: GDExtensionMethodBindPtr = {
        let methodName = StringName("select_all")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Select all the text.
    /// 
    /// If ``selectionEnabled`` is `false`, no selection will occur.
    /// 
    public final func selectAll() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_select_all, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_selected_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_selected_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the current selection text. Does not include BBCodes.
    public final func getSelectedText() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_selected_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_deselect: GDExtensionMethodBindPtr = {
        let methodName = StringName("deselect")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the current selection.
    public final func deselect() {
        gi.object_method_bind_ptrcall(RichTextLabel.method_deselect, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_parse_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName("parse_bbcode")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// The assignment version of ``appendText(bbcode:)``. Clears the tag stack and inserts the new content.
    public final func parseBbcode(_ bbcode: String) {
        let bbcode = GString(bbcode)
        withUnsafePointer(to: bbcode.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_parse_bbcode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_append_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("append_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Parses `bbcode` and adds tags to the tag stack as needed.
    /// 
    /// > Note: Using this method, you can't close a tag that was opened in a previous ``appendText(bbcode:)`` call. This is done to improve performance, especially when updating large RichTextLabels since rebuilding the whole BBCode every time would be slower. If you absolutely need to close a tag in a future method call, append the ``text`` instead of using ``appendText(bbcode:)``.
    /// 
    public final func appendText(bbcode: String) {
        let bbcode = GString(bbcode)
        withUnsafePointer(to: bbcode.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_append_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_is_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_ready")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// If ``threaded`` is enabled, returns `true` if the background thread has finished text processing, otherwise always return `true`.
    public final func isReady() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_ready, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_threaded: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_threaded")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_threaded(_ threaded: Bool) {
        withUnsafePointer(to: threaded) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_threaded, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_threaded: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_threaded")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_threaded() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_threaded, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_progress_bar_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_progress_bar_delay")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_progress_bar_delay(_ delayMs: Int32) {
        withUnsafePointer(to: delayMs) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_progress_bar_delay, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_progress_bar_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_progress_bar_delay")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_progress_bar_delay() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_progress_bar_delay, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visible_characters: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visible_characters")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_characters(_ amount: Int32) {
        withUnsafePointer(to: amount) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_visible_characters, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visible_characters: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_characters")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_characters() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_visible_characters, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_characters_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_characters_behavior")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 258789322)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_characters_behavior() -> TextServer.VisibleCharactersBehavior {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_visible_characters_behavior, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.VisibleCharactersBehavior (rawValue: _result)!
    }
    
    fileprivate static var method_set_visible_characters_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visible_characters_behavior")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3383839701)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_characters_behavior(_ behavior: TextServer.VisibleCharactersBehavior) {
        withUnsafePointer(to: behavior.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_visible_characters_behavior, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_visible_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_visible_ratio")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_ratio(_ ratio: Double) {
        withUnsafePointer(to: ratio) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_visible_ratio, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_visible_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_ratio")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_ratio() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_visible_ratio, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_character_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_character_line")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3744713108)!
            }
            
        }
        
    }()
    
    /// Returns the line number of the character position provided. Line and character numbers are both zero-indexed.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getCharacterLine(character: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: character) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_get_character_line, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_character_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_character_paragraph")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3744713108)!
            }
            
        }
        
    }()
    
    /// Returns the paragraph number of the character position provided. Paragraph and character numbers are both zero-indexed.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getCharacterParagraph(character: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: character) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_get_character_paragraph, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_total_character_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_total_character_count")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of characters from text tags. Does not include BBCodes.
    public final func getTotalCharacterCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_total_character_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_bbcode")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_bbcode(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_use_bbcode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_bbcode")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_bbcode() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_using_bbcode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_line_count")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of lines in the text. Wrapped text is counted as multiple lines.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getLineCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_line_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_line_count")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible lines.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getVisibleLineCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_visible_line_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_paragraph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_paragraph_count")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of paragraphs (newlines or `p` tags in the tag stack's text tags). Considers wrapped text as one paragraph.
    public final func getParagraphCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_paragraph_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_paragraph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_paragraph_count")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible paragraphs. A paragraph is considered visible if at least one of its lines is visible.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getVisibleParagraphCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_visible_paragraph_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_content_height: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_height")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the height of the content.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getContentHeight() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_content_height, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_content_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_content_width")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the width of the content.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getContentWidth() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_content_width, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_line_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_line_offset")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4025615559)!
            }
            
        }
        
    }()
    
    /// Returns the vertical offset of the line found at the provided index.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getLineOffset(line: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_get_line_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_paragraph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_paragraph_offset")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4025615559)!
            }
            
        }
        
    }()
    
    /// Returns the vertical offset of the paragraph found at the provided index.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getParagraphOffset(paragraph: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: paragraph) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_get_paragraph_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_parse_expressions_for_values: GDExtensionMethodBindPtr = {
        let methodName = StringName("parse_expressions_for_values")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1522900837)!
            }
            
        }
        
    }()
    
    /// Parses BBCode parameter `expressions` into a dictionary.
    public final func parseExpressionsForValues(expressions: PackedStringArray) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: expressions.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_parse_expressions_for_values, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_effects: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_effects")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_effects(_ effects: GArray) {
        withUnsafePointer(to: effects.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_set_effects, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_effects: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_effects")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_effects() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_effects, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_install_effect: GDExtensionMethodBindPtr = {
        let methodName = StringName("install_effect")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1114965689)!
            }
            
        }
        
    }()
    
    /// Installs a custom effect. This can also be done in the RichTextLabel inspector using the ``customEffects`` property. `effect` should be a valid ``RichTextEffect``.
    /// 
    /// Example RichTextEffect:
    /// 
    /// Registering the above effect in RichTextLabel from script:
    /// 
    public final func installEffect(_ effect: Variant?) {
        withUnsafePointer(to: effect.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_install_effect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_menu")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` of this ``RichTextLabel``. By default, this menu is displayed when right-clicking on the ``RichTextLabel``.
    /// 
    /// You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see ``RichTextLabel/MenuItems``). For example:
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getMenu() -> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(RichTextLabel.method_get_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_menu_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_menu_visible")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
    public final func isMenuVisible() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(RichTextLabel.method_is_menu_visible, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_menu_option: GDExtensionMethodBindPtr = {
        let methodName = StringName("menu_option")
        return withUnsafePointer(to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Executes a given action as defined in the ``RichTextLabel/MenuItems`` enum.
    public final func menuOption(_ option: Int32) {
        withUnsafePointer(to: option) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RichTextLabel.method_menu_option, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant?) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggered when the user clicks on content between meta (URL) tags. If the meta is defined in BBCode, e.g. [code skip-lint]<a href="{"key": "value"}">Text</a>`, then the parameter for this signal will always be a ``String`` type. If a particular type or an object is desired, the ``pushMeta(data:underlineMode:)`` method must be used to manually insert the data into the tag stack. Alternatively, you can convert the ``String`` input to the desired type based on its contents (such as calling ``JSON/parse(jsonText:keepText:)`` on it).
    /// 
    /// For example, the following method can be connected to [signal meta_clicked] to open clicked URLs using the user's default web browser:
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaClicked.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaClicked: Signal1 { Signal1 (target: self, signalName: "meta_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant?) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggers when the mouse enters a meta tag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaHoverStarted.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaHoverStarted: Signal2 { Signal2 (target: self, signalName: "meta_hover_started") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant?) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggers when the mouse exits a meta tag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaHoverEnded.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaHoverEnded: Signal3 { Signal3 (target: self, signalName: "meta_hover_ended") }
    
    /// Triggered when the document is fully loaded.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.finished.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var finished: SimpleSignal { SimpleSignal (target: self, signalName: "finished") }
    
}

