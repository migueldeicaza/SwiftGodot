// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Helper class to implement a UDP server.
/// 
/// A simple server that opens a UDP socket and returns connected ``PacketPeerUDP`` upon receiving new packets. See also ``PacketPeerUDP/connectToHost(_:port:)``.
/// 
/// After starting the server (``listen(port:bindAddress:)``), you will need to ``poll()`` it at regular intervals (e.g. inside ``Node/_process(delta:)``) for it to process new packets, delivering them to the appropriate ``PacketPeerUDP``, and taking new connections.
/// 
/// Below a small example of how it can be used:
/// 
open class UDPServer: RefCounted {
    override open class var godotClassName: StringName { "UDPServer" }
    
    /* Properties */
    
    /// Define the maximum number of pending connections, during ``poll()``, any new pending connection exceeding that value will be automatically dropped. Setting this value to `0` effectively prevents any new pending connection to be accepted (e.g. when all your players have connected).
    final public var maxPendingConnections: Int32 {
        get {
            return get_max_pending_connections ()
        }
        
        set {
            set_max_pending_connections (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_listen: GDExtensionMethodBindPtr = {
        let methodName = StringName("listen")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3167955072)!
            }
            
        }
        
    }()
    
    /// Starts the server by opening a UDP socket listening on the given `port`. You can optionally specify a `bindAddress` to only listen for packets sent to that address. See also ``PacketPeerUDP/bind(port:bindAddress:recvBufSize:)``.
    public final func listen(port: UInt16, bindAddress: String = "*") -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: port) { pArg0 in
            let bindAddress = GString(bindAddress)
            withUnsafePointer(to: bindAddress.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(UDPServer.method_listen, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_poll: GDExtensionMethodBindPtr = {
        let methodName = StringName("poll")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Call this method at regular intervals (e.g. inside ``Node/_process(delta:)``) to process new packets. And packet from known address/port pair will be delivered to the appropriate ``PacketPeerUDP``, any packet received from an unknown address/port pair will be added as a pending connection (see ``isConnectionAvailable()``, ``takeConnection()``). The maximum number of pending connection is defined via ``maxPendingConnections``.
    public final func poll() -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(UDPServer.method_poll, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_is_connection_available: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_connection_available")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a packet with a new address/port combination was received on the socket.
    public final func isConnectionAvailable() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(UDPServer.method_is_connection_available, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_local_port: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_local_port")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the local port this server is listening to.
    public final func getLocalPort() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(UDPServer.method_get_local_port, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_listening: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_listening")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the socket is open and listening on a port.
    public final func isListening() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(UDPServer.method_is_listening, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_take_connection: GDExtensionMethodBindPtr = {
        let methodName = StringName("take_connection")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 808734560)!
            }
            
        }
        
    }()
    
    /// Returns the first pending connection (connected to the appropriate address/port). Will return `null` if no new connection is available. See also ``isConnectionAvailable()``, ``PacketPeerUDP/connectToHost(_:port:)``.
    public final func takeConnection() -> PacketPeerUDP? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(UDPServer.method_take_connection, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName("stop")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the server, closing the UDP socket if open. Will close all connected ``PacketPeerUDP`` accepted via ``takeConnection()`` (remote peers will not be notified).
    public final func stop() {
        gi.object_method_bind_ptrcall(UDPServer.method_stop, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_max_pending_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_max_pending_connections")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_pending_connections(_ maxPendingConnections: Int32) {
        withUnsafePointer(to: maxPendingConnections) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(UDPServer.method_set_max_pending_connections, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_max_pending_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_max_pending_connections")
        return withUnsafePointer(to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_pending_connections() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(UDPServer.method_get_max_pending_connections, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

