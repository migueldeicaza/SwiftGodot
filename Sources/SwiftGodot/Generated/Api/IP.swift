// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Internet protocol (IP) support functions such as DNS resolution.
/// 
/// IP contains support functions for the Internet Protocol (IP). TCP/IP support is in different classes (see ``StreamPeerTCP`` and ``TCPServer``). IP provides DNS hostname resolution support, both blocking and threaded.
open class IP: Object {
    /// The shared instance of this class
    public static var shared: IP = {
        return withUnsafePointer (to: &IP.godotClassName.content) { ptr in
            IP (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "IP" }
    public enum ResolverStatus: Int64, CaseIterable, CustomDebugStringConvertible {
        /// DNS hostname resolver status: No status.
        case none = 0 // RESOLVER_STATUS_NONE
        /// DNS hostname resolver status: Waiting.
        case waiting = 1 // RESOLVER_STATUS_WAITING
        /// DNS hostname resolver status: Done.
        case done = 2 // RESOLVER_STATUS_DONE
        /// DNS hostname resolver status: Error.
        case error = 3 // RESOLVER_STATUS_ERROR
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .waiting: return ".waiting"
                case .done: return ".done"
                case .error: return ".error"
            }
            
        }
        
    }
    
    public enum GType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Address type: None.
        case none = 0 // TYPE_NONE
        /// Address type: Internet protocol version 4 (IPv4).
        case ipv4 = 1 // TYPE_IPV4
        /// Address type: Internet protocol version 6 (IPv6).
        case ipv6 = 2 // TYPE_IPV6
        /// Address type: Any.
        case any = 3 // TYPE_ANY
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .ipv4: return ".ipv4"
                case .ipv6: return ".ipv6"
                case .any: return ".any"
            }
            
        }
        
    }
    
    /* Constants */
    /// Maximum number of concurrent DNS resolver queries allowed, ``resolverInvalidId`` is returned if exceeded.
    public static let resolverMaxQueries = 256
    /// Invalid ID constant. Returned if ``resolverMaxQueries`` is exceeded.
    public static let resolverInvalidId = -1
    /* Methods */
    fileprivate static var method_resolve_hostname: GDExtensionMethodBindPtr = {
        let methodName = StringName("resolve_hostname")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4283295457)!
            }
            
        }
        
    }()
    
    /// Returns a given hostname's IPv4 or IPv6 address when resolved (blocking-type method). The address type returned depends on the ``IP/Type`` constant given as `ipType`.
    public static func resolveHostname(host: String, ipType: IP.GType = .any) -> String {
        let _result = GString ()
        let host = GString(host)
        withUnsafePointer(to: host.content) { pArg0 in
            withUnsafePointer(to: ipType.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_resolve_hostname, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_resolve_hostname_addresses: GDExtensionMethodBindPtr = {
        let methodName = StringName("resolve_hostname_addresses")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 773767525)!
            }
            
        }
        
    }()
    
    /// Resolves a given hostname in a blocking way. Addresses are returned as an ``GArray`` of IPv4 or IPv6 addresses depending on `ipType`.
    public static func resolveHostnameAddresses(host: String, ipType: IP.GType = .any) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        let host = GString(host)
        withUnsafePointer(to: host.content) { pArg0 in
            withUnsafePointer(to: ipType.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_resolve_hostname_addresses, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_resolve_hostname_queue_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("resolve_hostname_queue_item")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1749894742)!
            }
            
        }
        
    }()
    
    /// Creates a queue item to resolve a hostname to an IPv4 or IPv6 address depending on the ``IP/Type`` constant given as `ipType`. Returns the queue ID if successful, or ``resolverInvalidId`` on error.
    public static func resolveHostnameQueueItem(host: String, ipType: IP.GType = .any) -> Int32 {
        var _result: Int32 = 0
        let host = GString(host)
        withUnsafePointer(to: host.content) { pArg0 in
            withUnsafePointer(to: ipType.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_resolve_hostname_queue_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_resolve_item_status: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_resolve_item_status")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3812250196)!
            }
            
        }
        
    }()
    
    /// Returns a queued hostname's status as a ``IP/ResolverStatus`` constant, given its queue `id`.
    public static func getResolveItemStatus(id: Int32) -> IP.ResolverStatus {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_resolve_item_status, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return IP.ResolverStatus (rawValue: _result)!
    }
    
    fileprivate static var method_get_resolve_item_address: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_resolve_item_address")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns a queued hostname's IP address, given its queue `id`. Returns an empty string on error or if resolution hasn't happened yet (see ``getResolveItemStatus(id:)``).
    public static func getResolveItemAddress(id: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_resolve_item_address, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_resolve_item_addresses: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_resolve_item_addresses")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 663333327)!
            }
            
        }
        
    }()
    
    /// Returns resolved addresses, or an empty array if an error happened or resolution didn't happen yet (see ``getResolveItemStatus(id:)``).
    public static func getResolveItemAddresses(id: Int32) -> GArray {
        let _result: GArray = GArray ()
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_resolve_item_addresses, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_erase_resolve_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("erase_resolve_item")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes a given item `id` from the queue. This should be used to free a queue after it has completed to enable more queries to happen.
    public static func eraseResolveItem(id: Int32) {
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_erase_resolve_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_local_addresses: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_local_addresses")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns all the user's current IPv4 and IPv6 addresses as an array.
    public static func getLocalAddresses() -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall(method_get_local_addresses, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_local_interfaces: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_local_interfaces")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns all network adapters as an array.
    /// 
    /// Each adapter is a dictionary of the form:
    /// 
    public static func getLocalInterfaces() -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(method_get_local_interfaces, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_clear_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_cache")
        return withUnsafePointer(to: &IP.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3005725572)!
            }
            
        }
        
    }()
    
    /// Removes all of a `hostname`'s cached references. If no `hostname` is given, all cached IP addresses are removed.
    public static func clearCache(hostname: String = "") {
        let hostname = GString(hostname)
        withUnsafePointer(to: hostname.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_clear_cache, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
}

