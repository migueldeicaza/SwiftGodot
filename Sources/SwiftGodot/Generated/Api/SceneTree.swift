// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Manages the game loop via a hierarchy of nodes.
/// 
/// As one of the most important classes, the ``SceneTree`` manages the hierarchy of nodes in a scene, as well as scenes themselves. Nodes can be added, fetched and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded.
/// 
/// You can also use the ``SceneTree`` to organize your nodes into **groups**: every node can be added to as many groups as you want to create, e.g. an "enemy" group. You can then iterate these groups or even call methods and set properties on all the nodes belonging to any given group.
/// 
/// ``SceneTree`` is the default ``MainLoop`` implementation used by the engine, and is thus in charge of the game loop.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``treeChanged``
/// - ``treeProcessModeChanged``
/// - ``nodeAdded``
/// - ``nodeRemoved``
/// - ``nodeRenamed``
/// - ``nodeConfigurationWarningChanged``
/// - ``processFrame``
/// - ``physicsFrame``
open class SceneTree: MainLoop {
    override open class var godotClassName: StringName { "SceneTree" }
    public enum GroupCallFlags: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Call nodes within a group with no special behavior (default).
        case `default` = 0 // GROUP_CALL_DEFAULT
        /// Call nodes within a group in reverse tree hierarchy order (all nested children are called before their respective parent nodes).
        case reverse = 1 // GROUP_CALL_REVERSE
        /// Call nodes within a group at the end of the current frame (can be either process or physics frame), similar to ``Object/callDeferred(method:)``.
        case deferred = 2 // GROUP_CALL_DEFERRED
        /// Call nodes within a group only once, even if the call is executed many times in the same frame. Must be combined with ``GroupCallFlags/deferred`` to work.
        /// 
        /// > Note: Different arguments are not taken into account. Therefore, when the same call is executed with different arguments, only the first call will be performed.
        /// 
        case unique = 4 // GROUP_CALL_UNIQUE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .reverse: return ".reverse"
                case .deferred: return ".deferred"
                case .unique: return ".unique"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// If `true`, the application automatically accepts quitting requests.
    /// 
    /// For mobile platforms, see ``quitOnGoBack``.
    /// 
    final public var autoAcceptQuit: Bool {
        get {
            return is_auto_accept_quit ()
        }
        
        set {
            set_auto_accept_quit (newValue)
        }
        
    }
    
    /// If `true`, the application quits automatically when navigating back (e.g. using the system "Back" button on Android).
    /// 
    /// To handle 'Go Back' button when this option is disabled, use ``DisplayServer/WindowEvent/goBackRequest``.
    /// 
    final public var quitOnGoBack: Bool {
        get {
            return is_quit_on_go_back ()
        }
        
        set {
            set_quit_on_go_back (newValue)
        }
        
    }
    
    /// If `true`, collision shapes will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugCollisionsHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugCollisionsHint: Bool {
        get {
            return is_debugging_collisions_hint ()
        }
        
        set {
            set_debug_collisions_hint (newValue)
        }
        
    }
    
    /// If `true`, curves from ``Path2D`` and ``Path3D`` nodes will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugPathsHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugPathsHint: Bool {
        get {
            return is_debugging_paths_hint ()
        }
        
        set {
            set_debug_paths_hint (newValue)
        }
        
    }
    
    /// If `true`, navigation polygons will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugNavigationHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugNavigationHint: Bool {
        get {
            return is_debugging_navigation_hint ()
        }
        
        set {
            set_debug_navigation_hint (newValue)
        }
        
    }
    
    /// If `true`, the scene tree is considered paused. This causes the following behavior:
    /// 
    /// - 2D and 3D physics will be stopped, as well as collision detection and related signals.
    /// 
    /// - Depending on each node's ``Node/processMode``, their ``Node/_process(delta:)``, ``Node/_physicsProcess(delta:)`` and ``Node/_input(event:)`` callback methods may not called anymore.
    /// 
    final public var paused: Bool {
        get {
            return is_paused ()
        }
        
        set {
            set_pause (newValue)
        }
        
    }
    
    /// The root of the scene currently being edited in the editor. This is usually a direct child of ``root``.
    /// 
    /// > Note: This property does nothing in release builds.
    /// 
    final public var editedSceneRoot: Node? {
        get {
            return get_edited_scene_root ()
        }
        
        set {
            set_edited_scene_root (newValue)
        }
        
    }
    
    /// The root node of the currently loaded main scene, usually as a direct child of ``root``. See also ``changeSceneToFile(path:)``, ``changeSceneToPacked(packedScene:)``, and ``reloadCurrentScene()``.
    /// 
    /// > Warning: Setting this property directly may not work as expected, as it does _not_ add or remove any nodes from this tree.
    /// 
    final public var currentScene: Node? {
        get {
            return get_current_scene ()
        }
        
        set {
            set_current_scene (newValue)
        }
        
    }
    
    /// The tree's root ``Window``. This is top-most ``Node`` of the scene tree, and is always present. An absolute ``NodePath`` always starts from this node. Children of the root node may include the loaded ``currentScene``, as well as any <a href="https://docs.godotengine.org/en//tutorials/scripting/singletons_autoload.html">AutoLoad</a> configured in the Project Settings.
    /// 
    /// > Warning: Do not delete this node. This will result in unstable behavior, followed by a crash.
    /// 
    final public var root: Window? {
        get {
            return get_root ()
        }
        
    }
    
    /// If `true` (default value), enables automatic polling of the ``MultiplayerAPI`` for this SceneTree during [signal process_frame].
    /// 
    /// If `false`, you need to manually call ``MultiplayerAPI/poll()`` to process network packets and deliver RPCs. This allows running RPCs in a different loop (e.g. physics, thread, specific time step) and for manual ``Mutex`` protection when accessing the ``MultiplayerAPI`` from threads.
    /// 
    final public var multiplayerPoll: Bool {
        get {
            return is_multiplayer_poll_enabled ()
        }
        
        set {
            set_multiplayer_poll_enabled (newValue)
        }
        
    }
    
    /// If `true`, the renderer will interpolate the transforms of physics objects between the last two transforms, so that smooth motion is seen even when physics ticks do not coincide with rendered frames.
    /// 
    /// The default value of this property is controlled by ``ProjectSettings/physics/common/physicsInterpolation``.
    /// 
    final public var physicsInterpolation: Bool {
        get {
            return is_physics_interpolation_enabled ()
        }
        
        set {
            set_physics_interpolation_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_root: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_root")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1757182445)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_root() -> Window? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(SceneTree.method_get_root, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a node added to the given group `name` exists in the tree.
    public final func hasGroup(name: StringName) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_has_group, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_auto_accept_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_auto_accept_quit")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_accept_quit() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_auto_accept_quit, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_accept_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_accept_quit")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_accept_quit(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_auto_accept_quit, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_quit_on_go_back: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_quit_on_go_back")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_quit_on_go_back() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_quit_on_go_back, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_quit_on_go_back: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_quit_on_go_back")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_quit_on_go_back(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_quit_on_go_back, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_debug_collisions_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_debug_collisions_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_collisions_hint(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_debug_collisions_hint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_debugging_collisions_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_debugging_collisions_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_collisions_hint() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_debugging_collisions_hint, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_paths_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_debug_paths_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_paths_hint(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_debug_paths_hint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_debugging_paths_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_debugging_paths_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_paths_hint() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_debugging_paths_hint, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_navigation_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_debug_navigation_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_navigation_hint(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_debug_navigation_hint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_debugging_navigation_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_debugging_navigation_hint")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_navigation_hint() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_debugging_navigation_hint, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_edited_scene_root: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_edited_scene_root")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_edited_scene_root(_ scene: Node?) {
        withUnsafePointer(to: scene?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_edited_scene_root, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_edited_scene_root: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_edited_scene_root")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_edited_scene_root() -> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(SceneTree.method_get_edited_scene_root, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pause")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pause(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_pause, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_paused: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_paused")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_paused() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_paused, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_create_timer: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_timer")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2709170273)!
            }
            
        }
        
    }()
    
    /// Returns a new ``SceneTreeTimer``. After `timeSec` in seconds have passed, the timer will emit [signal SceneTreeTimer.timeout] and will be automatically freed.
    /// 
    /// If `processAlways` is `false`, the timer will be paused when setting ``SceneTree/paused`` to `true`.
    /// 
    /// If `processInPhysics` is `true`, the timer will update at the end of the physics frame, instead of the process frame.
    /// 
    /// If `ignoreTimeScale` is `true`, the timer will ignore ``Engine/timeScale`` and update with the real, elapsed time.
    /// 
    /// This method is commonly used to create a one-shot delay timer, as in the following example:
    /// 
    /// > Note: The timer is always updated _after_ all of the nodes in the tree. A node's ``Node/_process(delta:)`` method would be called before the timer updates (or ``Node/_physicsProcess(delta:)`` if `processInPhysics` is set to `true`).
    /// 
    public final func createTimer(timeSec: Double, processAlways: Bool = true, processInPhysics: Bool = false, ignoreTimeScale: Bool = false) -> SceneTreeTimer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: timeSec) { pArg0 in
            withUnsafePointer(to: processAlways) { pArg1 in
                withUnsafePointer(to: processInPhysics) { pArg2 in
                    withUnsafePointer(to: ignoreTimeScale) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(SceneTree.method_create_timer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_tween: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_tween")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3426978995)!
            }
            
        }
        
    }()
    
    /// Creates and returns a new ``Tween`` processed in this tree. The Tween will start automatically on the next process frame or physics frame (depending on its ``Tween.TweenProcessMode``).
    /// 
    /// > Note: A ``Tween`` created using this method is not bound to any ``Node``. It may keep working until there is nothing left to animate. If you want the ``Tween`` to be automatically killed when the ``Node`` is freed, use ``Node/createTween()`` or ``Tween/bindNode(_:)``.
    /// 
    public final func createTween() -> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(SceneTree.method_create_tween, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_processed_tweens: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_processed_tweens")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` of currently existing ``Tween``s in the tree, including paused tweens.
    public final func getProcessedTweens() -> ObjectCollection<Tween> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(SceneTree.method_get_processed_tweens, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return ObjectCollection<Tween>(content: _result)
    }
    
    fileprivate static var method_get_node_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_node_count")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of nodes inside this tree.
    public final func getNodeCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(SceneTree.method_get_node_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_frame")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns how many frames have been processed, since the application started. This is _not_ a measurement of elapsed time.
    public final func getFrame() -> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall(SceneTree.method_get_frame, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName("quit")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Quits the application at the end of the current iteration, with the given `exitCode`.
    /// 
    /// By convention, an exit code of `0` indicates success, whereas any other exit code indicates an error. For portability reasons, it should be between `0` and `125` (inclusive).
    /// 
    /// > Note: On iOS this method doesn't work. Instead, as recommended by the <a href="https://developer.apple.com/library/archive/qa/qa1561/_index.html">iOS Human Interface Guidelines</a>, the user is expected to close apps via the Home button.
    /// 
    public final func quit(exitCode: Int32 = 0) {
        withUnsafePointer(to: exitCode) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_quit, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_physics_interpolation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_physics_interpolation_enabled")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_interpolation_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_physics_interpolation_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_physics_interpolation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_physics_interpolation_enabled")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_physics_interpolation_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_physics_interpolation_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_queue_delete: GDExtensionMethodBindPtr = {
        let methodName = StringName("queue_delete")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3975164845)!
            }
            
        }
        
    }()
    
    /// Queues the given `obj` to be deleted, calling its ``Object/free()`` at the end of the current frame. This method is similar to ``Node/queueFree()``.
    public final func queueDelete(obj: Object?) {
        withUnsafePointer(to: obj?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_queue_delete, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_call_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("call_group_flags")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1527739229)!
            }
            
        }
        
    }()
    
    /// Calls the given `method` on each node inside this tree added to the given `group`. Use `flags` to customize this method's behavior (see ``SceneTree/GroupCallFlags``). Additional arguments for `method` can be passed at the end of this method. Nodes that cannot call `method` (either because the method doesn't exist or the arguments do not match) are ignored.
    /// 
    /// > Note: In C#, `method` must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the `MethodName` class to avoid allocating a new ``StringName`` on each call.
    /// 
    public final func callGroupFlags(_ flags: Int64, group: StringName, method: StringName, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        let flags = Variant(flags)
        withUnsafePointer(to: flags.content) { pArg0 in
            let group = Variant(group)
            withUnsafePointer(to: group.content) { pArg1 in
                let method = Variant(method)
                withUnsafePointer(to: method.content) { pArg2 in
                    if arguments.isEmpty {
                        withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                                gi.object_method_bind_call(SceneTree.method_call_group_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, 3, &_result, nil)
                            }
                            
                        }
                        
                    } else {
                        // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 3 + arguments.count) { pArgsBuffer in
                            defer { pArgsBuffer.deinitialize() }
                            guard let pArgs = pArgsBuffer.baseAddress else {
                                fatalError("pArgsBuffer.baseAddress is nil")
                            }
                            pArgsBuffer.initializeElement(at: 0, to: pArg0)
                            pArgsBuffer.initializeElement(at: 1, to: pArg1)
                            pArgsBuffer.initializeElement(at: 2, to: pArg2)
                            // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                            withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                                defer { contentsBuffer.deinitialize() }
                                guard let contentsPtr = contentsBuffer.baseAddress else {
                                    fatalError("contentsBuffer.baseAddress is nil")
                                }
                                
                                for i in 0..<arguments.count {
                                    // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                    contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                    // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                    pArgsBuffer.initializeElement(at: 3 + i, to: contentsPtr + i)
                                }
                            
                                gi.object_method_bind_call(SceneTree.method_call_group_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, Int64(3 + arguments.count), &_result, nil)
                            }                           
                        }
                        
                    }
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_notify_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("notify_group_flags")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1245489420)!
            }
            
        }
        
    }()
    
    /// Calls ``Object/notification(what:reversed:)`` with the given `notification` to all nodes inside this tree added to the `group`. Use `callFlags` to customize this method's behavior (see ``SceneTree/GroupCallFlags``).
    public final func notifyGroupFlags(callFlags: UInt32, group: StringName, notification: Int32) {
        withUnsafePointer(to: callFlags) { pArg0 in
            withUnsafePointer(to: group.content) { pArg1 in
                withUnsafePointer(to: notification) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(SceneTree.method_notify_group_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_group_flags")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3497599527)!
            }
            
        }
        
    }()
    
    /// Sets the given `property` to `value` on all nodes inside this tree added to the given `group`. Nodes that do not have the `property` are ignored. Use `callFlags` to customize this method's behavior (see ``SceneTree/GroupCallFlags``).
    /// 
    /// > Note: In C#, `property` must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the `PropertyName` class to avoid allocating a new ``StringName`` on each call.
    /// 
    public final func setGroupFlags(callFlags: UInt32, group: StringName, property: String, value: Variant?) {
        withUnsafePointer(to: callFlags) { pArg0 in
            withUnsafePointer(to: group.content) { pArg1 in
                let property = GString(property)
                withUnsafePointer(to: property.content) { pArg2 in
                    withUnsafePointer(to: value.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(SceneTree.method_set_group_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_call_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("call_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1257962832)!
            }
            
        }
        
    }()
    
    /// Calls `method` on each node inside this tree added to the given `group`. You can pass arguments to `method` by specifying them at the end of this method call. Nodes that cannot call `method` (either because the method doesn't exist or the arguments do not match) are ignored. See also ``setGroup(_:property:value:)`` and ``notifyGroup(_:notification:)``.
    /// 
    /// > Note: This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
    /// 
    /// > Note: In C#, `method` must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the `MethodName` class to avoid allocating a new ``StringName`` on each call.
    /// 
    public final func callGroup(_ group: StringName, method: StringName, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        let group = Variant(group)
        withUnsafePointer(to: group.content) { pArg0 in
            let method = Variant(method)
            withUnsafePointer(to: method.content) { pArg1 in
                if arguments.isEmpty {
                    withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                            gi.object_method_bind_call(SceneTree.method_call_group, UnsafeMutableRawPointer(mutating: handle), pArgs, 2, &_result, nil)
                        }
                        
                    }
                    
                } else {
                    // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 2 + arguments.count) { pArgsBuffer in
                        defer { pArgsBuffer.deinitialize() }
                        guard let pArgs = pArgsBuffer.baseAddress else {
                            fatalError("pArgsBuffer.baseAddress is nil")
                        }
                        pArgsBuffer.initializeElement(at: 0, to: pArg0)
                        pArgsBuffer.initializeElement(at: 1, to: pArg1)
                        // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                            defer { contentsBuffer.deinitialize() }
                            guard let contentsPtr = contentsBuffer.baseAddress else {
                                fatalError("contentsBuffer.baseAddress is nil")
                            }
                            
                            for i in 0..<arguments.count {
                                // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                pArgsBuffer.initializeElement(at: 2 + i, to: contentsPtr + i)
                            }
                        
                            gi.object_method_bind_call(SceneTree.method_call_group, UnsafeMutableRawPointer(mutating: handle), pArgs, Int64(2 + arguments.count), &_result, nil)
                        }                           
                    }
                    
                }
            }
            
        }
        
        
    }
    
    fileprivate static var method_notify_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("notify_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Calls ``Object/notification(what:reversed:)`` with the given `notification` to all nodes inside this tree added to the `group`. See also ``callGroup(_:method:)`` and ``setGroup(_:property:value:)``.
    /// 
    /// > Note: This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
    /// 
    public final func notifyGroup(_ group: StringName, notification: Int32) {
        withUnsafePointer(to: group.content) { pArg0 in
            withUnsafePointer(to: notification) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(SceneTree.method_notify_group, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1279312029)!
            }
            
        }
        
    }()
    
    /// Sets the given `property` to `value` on all nodes inside this tree added to the given `group`. Nodes that do not have the `property` are ignored. See also ``callGroup(_:method:)`` and ``notifyGroup(_:notification:)``.
    /// 
    /// > Note: This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
    /// 
    /// > Note: In C#, `property` must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the `PropertyName` class to avoid allocating a new ``StringName`` on each call.
    /// 
    public final func setGroup(_ group: StringName, property: String, value: Variant?) {
        withUnsafePointer(to: group.content) { pArg0 in
            let property = GString(property)
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: value.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(SceneTree.method_set_group, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_nodes_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_nodes_in_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 689397652)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` containing all nodes inside this tree, that have been added to the given `group`, in scene hierarchy order.
    public final func getNodesInGroup(_ group: StringName) -> ObjectCollection<Node> {
        var _result: Int64 = 0
        withUnsafePointer(to: group.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_get_nodes_in_group, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return ObjectCollection<Node>(content: _result)
    }
    
    fileprivate static var method_get_first_node_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_first_node_in_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4071044623)!
            }
            
        }
        
    }()
    
    /// Returns the first ``Node`` found inside the tree, that has been added to the given `group`, in scene hierarchy order. Returns `null` if no match is found. See also ``getNodesInGroup(_:)``.
    public final func getFirstNodeInGroup(_ group: StringName) -> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: group.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_get_first_node_in_group, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_node_count_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_node_count_in_group")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2458036349)!
            }
            
        }
        
    }()
    
    /// Returns the number of nodes assigned to the given group.
    public final func getNodeCountInGroup(_ group: StringName) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: group.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_get_node_count_in_group, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_current_scene")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_scene(_ childNode: Node?) {
        withUnsafePointer(to: childNode?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_current_scene, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_current_scene")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_scene() -> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(SceneTree.method_get_current_scene, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_change_scene_to_file: GDExtensionMethodBindPtr = {
        let methodName = StringName("change_scene_to_file")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166001499)!
            }
            
        }
        
    }()
    
    /// Changes the running scene to the one at the given `path`, after loading it into a ``PackedScene`` and creating a new instance.
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errCantOpen`` if the `path` cannot be loaded into a ``PackedScene``, or ``GodotError/errCantCreate`` if that scene cannot be instantiated.
    /// 
    /// > Note: See ``changeSceneToPacked(packedScene:)`` for details on the order of operations.
    /// 
    public final func changeSceneToFile(path: String) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_change_scene_to_file, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_change_scene_to_packed: GDExtensionMethodBindPtr = {
        let methodName = StringName("change_scene_to_packed")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 107349098)!
            }
            
        }
        
    }()
    
    /// Changes the running scene to a new instance of the given ``PackedScene`` (which must be valid).
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errCantCreate`` if the scene cannot be instantiated, or ``GodotError/errInvalidParameter`` if the scene is invalid.
    /// 
    /// > Note: Operations happen in the following order when ``changeSceneToPacked(packedScene:)`` is called:
    /// 
    /// 1. The current scene node is immediately removed from the tree. From that point, ``Node/getTree()`` called on the current (outgoing) scene will return `null`. ``currentScene`` will be `null`, too, because the new scene is not available yet.
    /// 
    /// 2. At the end of the frame, the formerly current scene, already removed from the tree, will be deleted (freed from memory) and then the new scene will be instantiated and added to the tree. ``Node/getTree()`` and ``currentScene`` will be back to working as usual.
    /// 
    /// This ensures that both scenes aren't running at the same time, while still freeing the previous scene in a safe way similar to ``Node/queueFree()``.
    /// 
    public final func changeSceneToPacked(packedScene: PackedScene?) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: packedScene?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_change_scene_to_packed, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_reload_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName("reload_current_scene")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Reloads the currently active scene, replacing ``currentScene`` with a new instance of its original ``PackedScene``.
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errUnconfigured`` if no ``currentScene`` is defined, ``GodotError/errCantOpen`` if ``currentScene`` cannot be loaded into a ``PackedScene``, or ``GodotError/errCantCreate`` if the scene cannot be instantiated.
    /// 
    public final func reloadCurrentScene() -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(SceneTree.method_reload_current_scene, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_unload_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName("unload_current_scene")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// If a current scene is loaded, calling this method will unload it.
    public final func unloadCurrentScene() {
        gi.object_method_bind_ptrcall(SceneTree.method_unload_current_scene, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_multiplayer: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_multiplayer")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2385607013)!
            }
            
        }
        
    }()
    
    /// Sets a custom ``MultiplayerAPI`` with the given `rootPath` (controlling also the relative subpaths), or override the default one if `rootPath` is empty.
    /// 
    /// > Note: No ``MultiplayerAPI`` must be configured for the subpath containing `rootPath`, nested custom multiplayers are not allowed. I.e. if one is configured for `"/root/Foo"` setting one for `"/root/Foo/Bar"` will cause an error.
    /// 
    public final func setMultiplayer(_ multiplayer: MultiplayerAPI?, rootPath: NodePath = NodePath("")) {
        withUnsafePointer(to: multiplayer?.handle) { pArg0 in
            withUnsafePointer(to: rootPath.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(SceneTree.method_set_multiplayer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_multiplayer: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_multiplayer")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3453401404)!
            }
            
        }
        
    }()
    
    /// Searches for the ``MultiplayerAPI`` configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See ``setMultiplayer(_:rootPath:)``.
    public final func getMultiplayer(forPath: NodePath = NodePath("")) -> MultiplayerAPI? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: forPath.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_get_multiplayer, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_multiplayer_poll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_multiplayer_poll_enabled")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_multiplayer_poll_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(SceneTree.method_set_multiplayer_poll_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_multiplayer_poll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_multiplayer_poll_enabled")
        return withUnsafePointer(to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_multiplayer_poll_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(SceneTree.method_is_multiplayer_poll_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Emitted any time the tree's hierarchy changes (nodes being moved, renamed, etc.).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "tree_changed") }
    
    /// Emitted when the ``Node/processMode`` of any node inside the tree is changed. Only emitted in the editor, to update the visibility of disabled nodes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeProcessModeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeProcessModeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "tree_process_mode_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the `node` enters this tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeAdded.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeAdded: Signal1 { Signal1 (target: self, signalName: "node_added") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the `node` exits this tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeRemoved.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeRemoved: Signal2 { Signal2 (target: self, signalName: "node_removed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the `node`'s ``Node/name`` is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeRenamed.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeRenamed: Signal3 { Signal3 (target: self, signalName: "node_renamed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the `node`'s ``Node/updateConfigurationWarnings()`` is called. Only emitted in the editor.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeConfigurationWarningChanged.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeConfigurationWarningChanged: Signal4 { Signal4 (target: self, signalName: "node_configuration_warning_changed") }
    
    /// Emitted immediately before ``Node/_process(delta:)`` is called on every node in this tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.processFrame.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var processFrame: SimpleSignal { SimpleSignal (target: self, signalName: "process_frame") }
    
    /// Emitted immediately before ``Node/_physicsProcess(delta:)`` is called on every node in this tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.physicsFrame.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var physicsFrame: SimpleSignal { SimpleSignal (target: self, signalName: "physics_frame") }
    
}

