// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A native library for GDExtension.
/// 
/// The ``GDExtension`` resource type represents a <a href="https://en.wikipedia.org/wiki/Shared_library">shared library</a> which can expand the functionality of the engine. The ``GDExtensionManager`` singleton is responsible for loading, reloading, and unloading ``GDExtension`` resources.
/// 
/// > Note: GDExtension itself is not a scripting language and has no relation to ``GDScript`` resources.
/// 
open class GDExtension: Resource {
    override open class var godotClassName: StringName { "GDExtension" }
    public enum InitializationLevel: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The library is initialized at the same time as the core features of the engine.
        case core = 0 // INITIALIZATION_LEVEL_CORE
        /// The library is initialized at the same time as the engine's servers (such as ``RenderingServer`` or ``PhysicsServer3D``).
        case servers = 1 // INITIALIZATION_LEVEL_SERVERS
        /// The library is initialized at the same time as the engine's scene-related classes.
        case scene = 2 // INITIALIZATION_LEVEL_SCENE
        /// The library is initialized at the same time as the engine's editor classes. Only happens when loading the GDExtension in the editor.
        case editor = 3 // INITIALIZATION_LEVEL_EDITOR
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .core: return ".core"
                case .servers: return ".servers"
                case .scene: return ".scene"
                case .editor: return ".editor"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_is_library_open: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_library_open")
        return withUnsafePointer(to: &GDExtension.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this extension's library has been opened.
    public final func isLibraryOpen() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GDExtension.method_is_library_open, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_minimum_library_initialization_level: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_minimum_library_initialization_level")
        return withUnsafePointer(to: &GDExtension.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 964858755)!
            }
            
        }
        
    }()
    
    /// Returns the lowest level required for this extension to be properly initialized (see the ``GDExtension/InitializationLevel`` enum).
    public final func getMinimumLibraryInitializationLevel() -> GDExtension.InitializationLevel {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GDExtension.method_get_minimum_library_initialization_level, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GDExtension.InitializationLevel (rawValue: _result)!
    }
    
}

