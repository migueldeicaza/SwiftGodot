// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Server for AR and VR features.
/// 
/// The AR/VR server is the heart of our Advanced and Virtual Reality solution and handles all the processing.
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``referenceFrameChanged``
/// - ``interfaceAdded``
/// - ``interfaceRemoved``
/// - ``trackerAdded``
/// - ``trackerUpdated``
/// - ``trackerRemoved``
open class XRServer: Object {
    /// The shared instance of this class
    public static var shared: XRServer = {
        return withUnsafePointer (to: &XRServer.godotClassName.content) { ptr in
            XRServer (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "XRServer" }
    public enum TrackerType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The tracker tracks the location of the players head. This is usually a location centered between the players eyes. Note that for handheld AR devices this can be the current location of the device.
        case head = 1 // TRACKER_HEAD
        /// The tracker tracks the location of a controller.
        case controller = 2 // TRACKER_CONTROLLER
        /// The tracker tracks the location of a base station.
        case basestation = 4 // TRACKER_BASESTATION
        /// The tracker tracks the location and size of an AR anchor.
        case anchor = 8 // TRACKER_ANCHOR
        /// The tracker tracks the location and joints of a hand.
        case hand = 16 // TRACKER_HAND
        /// The tracker tracks the location and joints of a body.
        case body = 32 // TRACKER_BODY
        /// The tracker tracks the expressions of a face.
        case face = 64 // TRACKER_FACE
        /// Used internally to filter trackers of any known type.
        case anyKnown = 127 // TRACKER_ANY_KNOWN
        /// Used internally if we haven't set the tracker type yet.
        case unknown = 128 // TRACKER_UNKNOWN
        /// Used internally to select all trackers.
        case any = 255 // TRACKER_ANY
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .head: return ".head"
                case .controller: return ".controller"
                case .basestation: return ".basestation"
                case .anchor: return ".anchor"
                case .hand: return ".hand"
                case .body: return ".body"
                case .face: return ".face"
                case .anyKnown: return ".anyKnown"
                case .unknown: return ".unknown"
                case .any: return ".any"
            }
            
        }
        
    }
    
    public enum RotationMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Fully reset the orientation of the HMD. Regardless of what direction the user is looking to in the real world. The user will look dead ahead in the virtual world.
        case resetFullRotation = 0 // RESET_FULL_ROTATION
        /// Resets the orientation but keeps the tilt of the device. So if we're looking down, we keep looking down but heading will be reset.
        case resetButKeepTilt = 1 // RESET_BUT_KEEP_TILT
        /// Does not reset the orientation of the HMD, only the position of the player gets centered.
        case dontResetRotation = 2 // DONT_RESET_ROTATION
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .resetFullRotation: return ".resetFullRotation"
                case .resetButKeepTilt: return ".resetButKeepTilt"
                case .dontResetRotation: return ".dontResetRotation"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The scale of the game world compared to the real world. By default, most AR/VR platforms assume that 1 game unit corresponds to 1 real world meter.
    static public var worldScale: Double {
        get {
            return get_world_scale ()
        }
        
        set {
            set_world_scale (newValue)
        }
        
    }
    
    /// The current origin of our tracking space in the virtual world. This is used by the renderer to properly position the camera with new tracking data.
    /// 
    /// > Note: This property is managed by the current ``XROrigin3D`` node. It is exposed for access from GDExtensions.
    /// 
    static public var worldOrigin: Transform3D {
        get {
            return get_world_origin ()
        }
        
        set {
            set_world_origin (newValue)
        }
        
    }
    
    /// The primary ``XRInterface`` currently bound to the ``XRServer``.
    static public var primaryInterface: XRInterface? {
        get {
            return get_primary_interface ()
        }
        
        set {
            set_primary_interface (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_world_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_world_scale")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_world_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(method_get_world_scale, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_world_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_world_scale")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_world_scale(_ scale: Double) {
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_set_world_scale, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_world_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_world_origin")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3229777777)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_world_origin() -> Transform3D {
        var _result: Transform3D = Transform3D ()
        gi.object_method_bind_ptrcall(method_get_world_origin, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_world_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_world_origin")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2952846383)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_world_origin(_ worldOrigin: Transform3D) {
        withUnsafePointer(to: worldOrigin) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_set_world_origin, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_reference_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_reference_frame")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3229777777)!
            }
            
        }
        
    }()
    
    /// Returns the reference frame transform. Mostly used internally and exposed for GDExtension build interfaces.
    public static func getReferenceFrame() -> Transform3D {
        var _result: Transform3D = Transform3D ()
        gi.object_method_bind_ptrcall(method_get_reference_frame, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear_reference_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_reference_frame")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the reference frame that was set by previous calls to ``centerOnHmd(rotationMode:keepHeight:)``.
    public static func clearReferenceFrame() {
        gi.object_method_bind_ptrcall(method_clear_reference_frame, UnsafeMutableRawPointer(mutating: shared.handle), nil, nil)
        
    }
    
    fileprivate static var method_center_on_hmd: GDExtensionMethodBindPtr = {
        let methodName = StringName("center_on_hmd")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1450904707)!
            }
            
        }
        
    }()
    
    /// This is an important function to understand correctly. AR and VR platforms all handle positioning slightly differently.
    /// 
    /// For platforms that do not offer spatial tracking, our origin point (0, 0, 0) is the location of our HMD, but you have little control over the direction the player is facing in the real world.
    /// 
    /// For platforms that do offer spatial tracking, our origin point depends very much on the system. For OpenVR, our origin point is usually the center of the tracking space, on the ground. For other platforms, it's often the location of the tracking camera.
    /// 
    /// This method allows you to center your tracker on the location of the HMD. It will take the current location of the HMD and use that to adjust all your tracking data; in essence, realigning the real world to your player's current position in the game world.
    /// 
    /// For this method to produce usable results, tracking information must be available. This often takes a few frames after starting your game.
    /// 
    /// You should call this method after a few seconds have passed. For example, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, or when implementing a teleport mechanism.
    /// 
    public static func centerOnHmd(rotationMode: XRServer.RotationMode, keepHeight: Bool) {
        withUnsafePointer(to: rotationMode.rawValue) { pArg0 in
            withUnsafePointer(to: keepHeight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_center_on_hmd, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_hmd_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hmd_transform")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4183770049)!
            }
            
        }
        
    }()
    
    /// Returns the primary interface's transformation.
    public static func getHmdTransform() -> Transform3D {
        var _result: Transform3D = Transform3D ()
        gi.object_method_bind_ptrcall(method_get_hmd_transform, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1898711491)!
            }
            
        }
        
    }()
    
    /// Registers an ``XRInterface`` object.
    public static func addInterface(_ interface: XRInterface?) {
        withUnsafePointer(to: interface?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_add_interface, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_interface_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_interface_count")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of interfaces currently registered with the AR/VR server. If your project supports multiple AR/VR platforms, you can look through the available interface, and either present the user with a selection or simply try to initialize each interface and use the first one that returns `true`.
    public static func getInterfaceCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(method_get_interface_count, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_remove_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1898711491)!
            }
            
        }
        
    }()
    
    /// Removes this `interface`.
    public static func removeInterface(_ interface: XRInterface?) {
        withUnsafePointer(to: interface?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_remove_interface, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4237347919)!
            }
            
        }
        
    }()
    
    /// Returns the interface registered at the given `idx` index in the list of interfaces.
    public static func getInterface(idx: Int32) -> XRInterface? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_interface, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_interfaces: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_interfaces")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a list of available interfaces the ID and name of each interface.
    public static func getInterfaces() -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(method_get_interfaces, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_find_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1395192955)!
            }
            
        }
        
    }()
    
    /// Finds an interface by its `name`. For example, if your project uses capabilities of an AR/VR platform, you can find the interface for that platform by name and initialize it.
    public static func findInterface(name: String) -> XRInterface? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_find_interface, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_add_tracker: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_tracker")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 684804553)!
            }
            
        }
        
    }()
    
    /// Registers a new ``XRTracker`` that tracks a physical object.
    public static func addTracker(_ tracker: XRTracker?) {
        withUnsafePointer(to: tracker?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_add_tracker, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_tracker: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_tracker")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 684804553)!
            }
            
        }
        
    }()
    
    /// Removes this `tracker`.
    public static func removeTracker(_ tracker: XRTracker?) {
        withUnsafePointer(to: tracker?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_remove_tracker, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_trackers: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_trackers")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3554694381)!
            }
            
        }
        
    }()
    
    /// Returns a dictionary of trackers for `trackerTypes`.
    public static func getTrackers(trackerTypes: Int32) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: trackerTypes) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_trackers, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_tracker: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tracker")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 147382240)!
            }
            
        }
        
    }()
    
    /// Returns the positional tracker with the given `trackerName`.
    public static func getTracker(trackerName: StringName) -> XRTracker? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: trackerName.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_tracker, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_primary_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_primary_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2143545064)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_primary_interface() -> XRInterface? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(method_get_primary_interface, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_primary_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_primary_interface")
        return withUnsafePointer(to: &XRServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1898711491)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_primary_interface(_ interface: XRInterface?) {
        withUnsafePointer(to: interface?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_set_primary_interface, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Emitted when the reference frame transform changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.referenceFrameChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var referenceFrameChanged: SimpleSignal { SimpleSignal (target: self, signalName: "reference_frame_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ interfaceName: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a new interface has been added.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.interfaceAdded.connect { interfaceName in
    ///    print ("caught signal")
    /// }
    /// ```
    public var interfaceAdded: Signal1 { Signal1 (target: self, signalName: "interface_added") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ interfaceName: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0]!)!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an interface is removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.interfaceRemoved.connect { interfaceName in
    ///    print ("caught signal")
    /// }
    /// ```
    public var interfaceRemoved: Signal2 { Signal2 (target: self, signalName: "interface_removed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ trackerName: StringName, _ type: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a new tracker has been added. If you don't use a fixed number of controllers or if you're using ``XRAnchor3D``s for an AR solution, it is important to react to this signal to add the appropriate ``XRController3D`` or ``XRAnchor3D`` nodes related to this new tracker.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.trackerAdded.connect { trackerName, type in
    ///    print ("caught signal")
    /// }
    /// ```
    public var trackerAdded: Signal3 { Signal3 (target: self, signalName: "tracker_added") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ trackerName: StringName, _ type: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an existing tracker has been updated. This can happen if the user switches controllers.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.trackerUpdated.connect { trackerName, type in
    ///    print ("caught signal")
    /// }
    /// ```
    public var trackerUpdated: Signal4 { Signal4 (target: self, signalName: "tracker_updated") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ trackerName: StringName, _ type: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0]!)!
                let arg_1 = Int64 (args [1]!)!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tracker is removed. You should remove any ``XRController3D`` or ``XRAnchor3D`` points if applicable. This is not mandatory, the nodes simply become inactive and will be made active again when a new tracker becomes available (i.e. a new controller is switched on that takes the place of the previous one).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.trackerRemoved.connect { trackerName, type in
    ///    print ("caught signal")
    /// }
    /// ```
    public var trackerRemoved: Signal5 { Signal5 (target: self, signalName: "tracker_removed") }
    
}

