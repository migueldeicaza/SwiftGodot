// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A server interface for font management and text rendering.
/// 
/// ``TextServer`` is the API backend for managing fonts and rendering text.
/// 
/// > Note: This is a low-level API, consider using ``TextLine``, ``TextParagraph``, and ``Font`` classes instead.
/// 
/// This is an abstract class, so to get the currently active ``TextServer`` instance, use the following code:
/// 
open class TextServer: RefCounted {
    override open class var godotClassName: StringName { "TextServer" }
    public enum FontAntialiasing: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Font glyphs are rasterized as 1-bit bitmaps.
        case none = 0 // FONT_ANTIALIASING_NONE
        /// Font glyphs are rasterized as 8-bit grayscale anti-aliased bitmaps.
        case gray = 1 // FONT_ANTIALIASING_GRAY
        /// Font glyphs are rasterized for LCD screens.
        /// 
        /// LCD subpixel layout is determined by the value of `gui/theme/lcd_subpixel_layout` project settings.
        /// 
        /// LCD subpixel anti-aliasing mode is suitable only for rendering horizontal, unscaled text in 2D.
        /// 
        case lcd = 2 // FONT_ANTIALIASING_LCD
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .gray: return ".gray"
                case .lcd: return ".lcd"
            }
            
        }
        
    }
    
    public enum FontLCDSubpixelLayout: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Unknown or unsupported subpixel layout, LCD subpixel antialiasing is disabled.
        case none = 0 // FONT_LCD_SUBPIXEL_LAYOUT_NONE
        /// Horizontal RGB subpixel layout.
        case hrgb = 1 // FONT_LCD_SUBPIXEL_LAYOUT_HRGB
        /// Horizontal BGR subpixel layout.
        case hbgr = 2 // FONT_LCD_SUBPIXEL_LAYOUT_HBGR
        /// Vertical RGB subpixel layout.
        case vrgb = 3 // FONT_LCD_SUBPIXEL_LAYOUT_VRGB
        /// Vertical BGR subpixel layout.
        case vbgr = 4 // FONT_LCD_SUBPIXEL_LAYOUT_VBGR
        /// Represents the size of the ``TextServer/FontLCDSubpixelLayout`` enum.
        case max = 5 // FONT_LCD_SUBPIXEL_LAYOUT_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .hrgb: return ".hrgb"
                case .hbgr: return ".hbgr"
                case .vrgb: return ".vrgb"
                case .vbgr: return ".vbgr"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum Direction: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Text direction is determined based on contents and current locale.
        case auto = 0 // DIRECTION_AUTO
        /// Text is written from left to right.
        case ltr = 1 // DIRECTION_LTR
        /// Text is written from right to left.
        case rtl = 2 // DIRECTION_RTL
        /// Text writing direction is the same as base string writing direction. Used for BiDi override only.
        case inherited = 3 // DIRECTION_INHERITED
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .auto: return ".auto"
                case .ltr: return ".ltr"
                case .rtl: return ".rtl"
                case .inherited: return ".inherited"
            }
            
        }
        
    }
    
    public enum Orientation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Text is written horizontally.
        case horizontal = 0 // ORIENTATION_HORIZONTAL
        /// Left to right text is written vertically from top to bottom.
        /// 
        /// Right to left text is written vertically from bottom to top.
        /// 
        case vertical = 1 // ORIENTATION_VERTICAL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .horizontal: return ".horizontal"
                case .vertical: return ".vertical"
            }
            
        }
        
    }
    
    public struct JustificationFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Justify text by adding and removing kashidas.
        public static let kashida = JustificationFlag (rawValue: 1)
        /// Justify text by changing width of the spaces between the words.
        public static let wordBound = JustificationFlag (rawValue: 2)
        /// Remove trailing and leading spaces from the justified text.
        public static let trimEdgeSpaces = JustificationFlag (rawValue: 4)
        /// Only apply justification to the part of the text after the last tab.
        public static let afterLastTab = JustificationFlag (rawValue: 8)
        /// Apply justification to the trimmed line with ellipsis.
        public static let constrainEllipsis = JustificationFlag (rawValue: 16)
        /// Do not apply justification to the last line of the paragraph.
        public static let skipLastLine = JustificationFlag (rawValue: 32)
        /// Do not apply justification to the last line of the paragraph with visible characters (takes precedence over ``JustificationFlag/skipLastLine``).
        public static let skipLastLineWithVisibleChars = JustificationFlag (rawValue: 64)
        /// Always apply justification to the paragraphs with a single line (``JustificationFlag/skipLastLine`` and ``JustificationFlag/skipLastLineWithVisibleChars`` are ignored).
        public static let doNotSkipSingleLine = JustificationFlag (rawValue: 128)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.kashida) { result += "kashida, " }
            if self.contains (.wordBound) { result += "wordBound, " }
            if self.contains (.trimEdgeSpaces) { result += "trimEdgeSpaces, " }
            if self.contains (.afterLastTab) { result += "afterLastTab, " }
            if self.contains (.constrainEllipsis) { result += "constrainEllipsis, " }
            if self.contains (.skipLastLine) { result += "skipLastLine, " }
            if self.contains (.skipLastLineWithVisibleChars) { result += "skipLastLineWithVisibleChars, " }
            if self.contains (.doNotSkipSingleLine) { result += "doNotSkipSingleLine, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum AutowrapMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Autowrap is disabled.
        case off = 0 // AUTOWRAP_OFF
        /// Wraps the text inside the node's bounding rectangle by allowing to break lines at arbitrary positions, which is useful when very limited space is available.
        case arbitrary = 1 // AUTOWRAP_ARBITRARY
        /// Wraps the text inside the node's bounding rectangle by soft-breaking between words.
        case word = 2 // AUTOWRAP_WORD
        /// Behaves similarly to ``AutowrapMode/word``, but force-breaks a word if that single word does not fit in one line.
        case wordSmart = 3 // AUTOWRAP_WORD_SMART
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .off: return ".off"
                case .arbitrary: return ".arbitrary"
                case .word: return ".word"
                case .wordSmart: return ".wordSmart"
            }
            
        }
        
    }
    
    public struct LineBreakFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Break the line at the line mandatory break characters (e.g. `"\n"`).
        public static let mandatory = LineBreakFlag (rawValue: 1)
        /// Break the line between the words.
        public static let wordBound = LineBreakFlag (rawValue: 2)
        /// Break the line between any unconnected graphemes.
        public static let graphemeBound = LineBreakFlag (rawValue: 4)
        /// Should be used only in conjunction with ``LineBreakFlag/wordBound``, break the line between any unconnected graphemes, if it's impossible to break it between the words.
        public static let adaptive = LineBreakFlag (rawValue: 8)
        /// Remove edge spaces from the broken line segments.
        public static let trimEdgeSpaces = LineBreakFlag (rawValue: 16)
        /// Subtract first line indentation width from all lines after the first one.
        public static let trimIndent = LineBreakFlag (rawValue: 32)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.mandatory) { result += "mandatory, " }
            if self.contains (.wordBound) { result += "wordBound, " }
            if self.contains (.graphemeBound) { result += "graphemeBound, " }
            if self.contains (.adaptive) { result += "adaptive, " }
            if self.contains (.trimEdgeSpaces) { result += "trimEdgeSpaces, " }
            if self.contains (.trimIndent) { result += "trimIndent, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum VisibleCharactersBehavior: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Trims text before the shaping. e.g, increasing ``Label/visibleCharacters`` or ``RichTextLabel/visibleCharacters`` value is visually identical to typing the text.
        case charsBeforeShaping = 0 // VC_CHARS_BEFORE_SHAPING
        /// Displays glyphs that are mapped to the first ``Label/visibleCharacters`` or ``RichTextLabel/visibleCharacters`` characters from the beginning of the text.
        case charsAfterShaping = 1 // VC_CHARS_AFTER_SHAPING
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the left or from the right, depending on ``Control/layoutDirection`` value.
        case glyphsAuto = 2 // VC_GLYPHS_AUTO
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the left.
        case glyphsLtr = 3 // VC_GLYPHS_LTR
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the right.
        case glyphsRtl = 4 // VC_GLYPHS_RTL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .charsBeforeShaping: return ".charsBeforeShaping"
                case .charsAfterShaping: return ".charsAfterShaping"
                case .glyphsAuto: return ".glyphsAuto"
                case .glyphsLtr: return ".glyphsLtr"
                case .glyphsRtl: return ".glyphsRtl"
            }
            
        }
        
    }
    
    public enum OverrunBehavior: Int64, CaseIterable, CustomDebugStringConvertible {
        /// No text trimming is performed.
        case noTrimming = 0 // OVERRUN_NO_TRIMMING
        /// Trims the text per character.
        case trimChar = 1 // OVERRUN_TRIM_CHAR
        /// Trims the text per word.
        case trimWord = 2 // OVERRUN_TRIM_WORD
        /// Trims the text per character and adds an ellipsis to indicate that parts are hidden.
        case trimEllipsis = 3 // OVERRUN_TRIM_ELLIPSIS
        /// Trims the text per word and adds an ellipsis to indicate that parts are hidden.
        case trimWordEllipsis = 4 // OVERRUN_TRIM_WORD_ELLIPSIS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .noTrimming: return ".noTrimming"
                case .trimChar: return ".trimChar"
                case .trimWord: return ".trimWord"
                case .trimEllipsis: return ".trimEllipsis"
                case .trimWordEllipsis: return ".trimWordEllipsis"
            }
            
        }
        
    }
    
    public struct TextOverrunFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Trims the text when it exceeds the given width.
        public static let trim = TextOverrunFlag (rawValue: 1)
        /// Trims the text per word instead of per grapheme.
        public static let trimWordOnly = TextOverrunFlag (rawValue: 2)
        /// Determines whether an ellipsis should be added at the end of the text.
        public static let addEllipsis = TextOverrunFlag (rawValue: 4)
        /// Determines whether the ellipsis at the end of the text is enforced and may not be hidden.
        public static let enforceEllipsis = TextOverrunFlag (rawValue: 8)
        /// Accounts for the text being justified before attempting to trim it (see ``TextServer/JustificationFlag``).
        public static let justificationAware = TextOverrunFlag (rawValue: 16)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.trim) { result += "trim, " }
            if self.contains (.trimWordOnly) { result += "trimWordOnly, " }
            if self.contains (.addEllipsis) { result += "addEllipsis, " }
            if self.contains (.enforceEllipsis) { result += "enforceEllipsis, " }
            if self.contains (.justificationAware) { result += "justificationAware, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public struct GraphemeFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Grapheme is supported by the font, and can be drawn.
        public static let valid = GraphemeFlag (rawValue: 1)
        /// Grapheme is part of right-to-left or bottom-to-top run.
        public static let rtl = GraphemeFlag (rawValue: 2)
        /// Grapheme is not part of source text, it was added by justification process.
        public static let virtual = GraphemeFlag (rawValue: 4)
        /// Grapheme is whitespace.
        public static let space = GraphemeFlag (rawValue: 8)
        /// Grapheme is mandatory break point (e.g. `"\n"`).
        public static let breakHard = GraphemeFlag (rawValue: 16)
        /// Grapheme is optional break point (e.g. space).
        public static let breakSoft = GraphemeFlag (rawValue: 32)
        /// Grapheme is the tabulation character.
        public static let tab = GraphemeFlag (rawValue: 64)
        /// Grapheme is kashida.
        public static let elongation = GraphemeFlag (rawValue: 128)
        /// Grapheme is punctuation character.
        public static let punctuation = GraphemeFlag (rawValue: 256)
        /// Grapheme is underscore character.
        public static let underscore = GraphemeFlag (rawValue: 512)
        /// Grapheme is connected to the previous grapheme. Breaking line before this grapheme is not safe.
        public static let connected = GraphemeFlag (rawValue: 1024)
        /// It is safe to insert a U+0640 before this grapheme for elongation.
        public static let safeToInsertTatweel = GraphemeFlag (rawValue: 2048)
        /// Grapheme is an object replacement character for the embedded object.
        public static let embeddedObject = GraphemeFlag (rawValue: 4096)
        /// Grapheme is a soft hyphen.
        public static let softHyphen = GraphemeFlag (rawValue: 8192)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.valid) { result += "valid, " }
            if self.contains (.rtl) { result += "rtl, " }
            if self.contains (.virtual) { result += "virtual, " }
            if self.contains (.space) { result += "space, " }
            if self.contains (.breakHard) { result += "breakHard, " }
            if self.contains (.breakSoft) { result += "breakSoft, " }
            if self.contains (.tab) { result += "tab, " }
            if self.contains (.elongation) { result += "elongation, " }
            if self.contains (.punctuation) { result += "punctuation, " }
            if self.contains (.underscore) { result += "underscore, " }
            if self.contains (.connected) { result += "connected, " }
            if self.contains (.safeToInsertTatweel) { result += "safeToInsertTatweel, " }
            if self.contains (.embeddedObject) { result += "embeddedObject, " }
            if self.contains (.softHyphen) { result += "softHyphen, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum Hinting: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Disables font hinting (smoother but less crisp).
        case none = 0 // HINTING_NONE
        /// Use the light font hinting mode.
        case light = 1 // HINTING_LIGHT
        /// Use the default font hinting mode (crisper but less smooth).
        /// 
        /// > Note: This hinting mode changes both horizontal and vertical glyph metrics. If applied to monospace font, some glyphs might have different width.
        /// 
        case normal = 2 // HINTING_NORMAL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .light: return ".light"
                case .normal: return ".normal"
            }
            
        }
        
    }
    
    public enum SubpixelPositioning: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Glyph horizontal position is rounded to the whole pixel size, each glyph is rasterized once.
        case disabled = 0 // SUBPIXEL_POSITIONING_DISABLED
        /// Glyph horizontal position is rounded based on font size.
        /// 
        /// - To one quarter of the pixel size if font size is smaller or equal to ``SubpixelPositioning/oneQuarterMaxSize``.
        /// 
        /// - To one half of the pixel size if font size is smaller or equal to ``SubpixelPositioning/oneHalfMaxSize``.
        /// 
        /// - To the whole pixel size for larger fonts.
        /// 
        case auto = 1 // SUBPIXEL_POSITIONING_AUTO
        /// Glyph horizontal position is rounded to one half of the pixel size, each glyph is rasterized up to two times.
        case oneHalf = 2 // SUBPIXEL_POSITIONING_ONE_HALF
        /// Glyph horizontal position is rounded to one quarter of the pixel size, each glyph is rasterized up to four times.
        case oneQuarter = 3 // SUBPIXEL_POSITIONING_ONE_QUARTER
        /// Maximum font size which will use one half of the pixel subpixel positioning in ``SubpixelPositioning/auto`` mode.
        case oneHalfMaxSize = 20 // SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE
        /// Maximum font size which will use one quarter of the pixel subpixel positioning in ``SubpixelPositioning/auto`` mode.
        case oneQuarterMaxSize = 16 // SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .auto: return ".auto"
                case .oneHalf: return ".oneHalf"
                case .oneQuarter: return ".oneQuarter"
                case .oneHalfMaxSize: return ".oneHalfMaxSize"
                case .oneQuarterMaxSize: return ".oneQuarterMaxSize"
            }
            
        }
        
    }
    
    public enum Feature: Int64, CaseIterable, CustomDebugStringConvertible {
        /// TextServer supports simple text layouts.
        case simpleLayout = 1 // FEATURE_SIMPLE_LAYOUT
        /// TextServer supports bidirectional text layouts.
        case bidiLayout = 2 // FEATURE_BIDI_LAYOUT
        /// TextServer supports vertical layouts.
        case verticalLayout = 4 // FEATURE_VERTICAL_LAYOUT
        /// TextServer supports complex text shaping.
        case shaping = 8 // FEATURE_SHAPING
        /// TextServer supports justification using kashidas.
        case kashidaJustification = 16 // FEATURE_KASHIDA_JUSTIFICATION
        /// TextServer supports complex line/word breaking rules (e.g. dictionary based).
        case breakIterators = 32 // FEATURE_BREAK_ITERATORS
        /// TextServer supports loading bitmap fonts.
        case fontBitmap = 64 // FEATURE_FONT_BITMAP
        /// TextServer supports loading dynamic (TrueType, OpeType, etc.) fonts.
        case fontDynamic = 128 // FEATURE_FONT_DYNAMIC
        /// TextServer supports multichannel signed distance field dynamic font rendering.
        case fontMsdf = 256 // FEATURE_FONT_MSDF
        /// TextServer supports loading system fonts.
        case fontSystem = 512 // FEATURE_FONT_SYSTEM
        /// TextServer supports variable fonts.
        case fontVariable = 1024 // FEATURE_FONT_VARIABLE
        /// TextServer supports locale dependent and context sensitive case conversion.
        case contextSensitiveCaseConversion = 2048 // FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION
        /// TextServer require external data file for some features, see ``loadSupportData(filename:)``.
        case useSupportData = 4096 // FEATURE_USE_SUPPORT_DATA
        /// TextServer supports UAX #31 identifier validation, see ``isValidIdentifier(string:)``.
        case unicodeIdentifiers = 8192 // FEATURE_UNICODE_IDENTIFIERS
        /// TextServer supports <a href="https://unicode.org/reports/tr36/">Unicode Technical Report #36</a> and <a href="https://unicode.org/reports/tr39/">Unicode Technical Standard #39</a> based spoof detection features.
        case unicodeSecurity = 16384 // FEATURE_UNICODE_SECURITY
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .simpleLayout: return ".simpleLayout"
                case .bidiLayout: return ".bidiLayout"
                case .verticalLayout: return ".verticalLayout"
                case .shaping: return ".shaping"
                case .kashidaJustification: return ".kashidaJustification"
                case .breakIterators: return ".breakIterators"
                case .fontBitmap: return ".fontBitmap"
                case .fontDynamic: return ".fontDynamic"
                case .fontMsdf: return ".fontMsdf"
                case .fontSystem: return ".fontSystem"
                case .fontVariable: return ".fontVariable"
                case .contextSensitiveCaseConversion: return ".contextSensitiveCaseConversion"
                case .useSupportData: return ".useSupportData"
                case .unicodeIdentifiers: return ".unicodeIdentifiers"
                case .unicodeSecurity: return ".unicodeSecurity"
            }
            
        }
        
    }
    
    public enum ContourPointTag: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Contour point is on the curve.
        case on = 1 // CONTOUR_CURVE_TAG_ON
        /// Contour point isn't on the curve, but serves as a control point for a conic (quadratic) Bézier arc.
        case offConic = 0 // CONTOUR_CURVE_TAG_OFF_CONIC
        /// Contour point isn't on the curve, but serves as a control point for a cubic Bézier arc.
        case offCubic = 2 // CONTOUR_CURVE_TAG_OFF_CUBIC
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .on: return ".on"
                case .offConic: return ".offConic"
                case .offCubic: return ".offCubic"
            }
            
        }
        
    }
    
    public enum SpacingType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Spacing for each glyph.
        case glyph = 0 // SPACING_GLYPH
        /// Spacing for the space character.
        case space = 1 // SPACING_SPACE
        /// Spacing at the top of the line.
        case top = 2 // SPACING_TOP
        /// Spacing at the bottom of the line.
        case bottom = 3 // SPACING_BOTTOM
        /// Represents the size of the ``TextServer/SpacingType`` enum.
        case max = 4 // SPACING_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .glyph: return ".glyph"
                case .space: return ".space"
                case .top: return ".top"
                case .bottom: return ".bottom"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public struct FontStyle: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Font is bold.
        public static let bold = FontStyle (rawValue: 1)
        /// Font is italic or oblique.
        public static let italic = FontStyle (rawValue: 2)
        /// Font have fixed-width characters.
        public static let fixedWidth = FontStyle (rawValue: 4)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.bold) { result += "bold, " }
            if self.contains (.italic) { result += "italic, " }
            if self.contains (.fixedWidth) { result += "fixedWidth, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum StructuredTextParser: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Use default Unicode BiDi algorithm.
        case `default` = 0 // STRUCTURED_TEXT_DEFAULT
        /// BiDi override for URI.
        case uri = 1 // STRUCTURED_TEXT_URI
        /// BiDi override for file path.
        case file = 2 // STRUCTURED_TEXT_FILE
        /// BiDi override for email.
        case email = 3 // STRUCTURED_TEXT_EMAIL
        /// BiDi override for lists. Structured text options: list separator ``String``.
        case list = 4 // STRUCTURED_TEXT_LIST
        /// BiDi override for GDScript.
        case gdscript = 5 // STRUCTURED_TEXT_GDSCRIPT
        /// User defined structured text BiDi override function.
        case custom = 6 // STRUCTURED_TEXT_CUSTOM
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .uri: return ".uri"
                case .file: return ".file"
                case .email: return ".email"
                case .list: return ".list"
                case .gdscript: return ".gdscript"
                case .custom: return ".custom"
            }
            
        }
        
    }
    
    public enum FixedSizeScaleMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Bitmap font is not scaled.
        case disable = 0 // FIXED_SIZE_SCALE_DISABLE
        /// Bitmap font is scaled to the closest integer multiple of the font's fixed size. This is the recommended option for pixel art fonts.
        case integerOnly = 1 // FIXED_SIZE_SCALE_INTEGER_ONLY
        /// Bitmap font is scaled to an arbitrary (fractional) size. This is the recommended option for non-pixel art fonts.
        case enabled = 2 // FIXED_SIZE_SCALE_ENABLED
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disable: return ".disable"
                case .integerOnly: return ".integerOnly"
                case .enabled: return ".enabled"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_has_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_feature")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3967367083)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the server supports a feature.
    public final func hasFeature(_ feature: TextServer.Feature) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: feature.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_has_feature, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the server interface.
    public final func getName() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(TextServer.method_get_name, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_features: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_features")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns text server features, see ``TextServer/Feature``.
    public final func getFeatures() -> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall(TextServer.method_get_features, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_load_support_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("load_support_data")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2323990056)!
            }
            
        }
        
    }()
    
    /// Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
    /// 
    /// > Note: This function should be called before any other TextServer functions used, otherwise it won't have any effect.
    /// 
    public final func loadSupportData(filename: String) -> Bool {
        var _result: Bool = false
        let filename = GString(filename)
        withUnsafePointer(to: filename.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_load_support_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_support_data_filename: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_support_data_filename")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
    public final func getSupportDataFilename() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(TextServer.method_get_support_data_filename, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_support_data_info: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_support_data_info")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
    public final func getSupportDataInfo() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(TextServer.method_get_support_data_info, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_save_support_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("save_support_data")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
    /// 
    /// > Note: This function is used by during project export, to include TextServer database.
    /// 
    public final func saveSupportData(filename: String) -> Bool {
        var _result: Bool = false
        let filename = GString(filename)
        withUnsafePointer(to: filename.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_save_support_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_locale_right_to_left: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_locale_right_to_left")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if locale is right-to-left.
    public final func isLocaleRightToLeft(locale: String) -> Bool {
        var _result: Bool = false
        let locale = GString(locale)
        withUnsafePointer(to: locale.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_is_locale_right_to_left, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_name_to_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("name_to_tag")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1321353865)!
            }
            
        }
        
    }()
    
    /// Converts readable feature, variation, script, or language name to OpenType tag.
    public final func nameToTag(name: String) -> Int {
        var _result: Int = 0
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_name_to_tag, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_tag_to_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("tag_to_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Converts OpenType tag to readable feature, variation, script, or language name.
    public final func tagToName(tag: Int) -> String {
        let _result = GString ()
        withUnsafePointer(to: tag) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_tag_to_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_has: GDExtensionMethodBindPtr = {
        let methodName = StringName("has")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `rid` is valid resource owned by this text server.
    public final func has(rid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_has, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_free_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("free_rid")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Frees an object created by this ``TextServer``.
    public final func freeRid(_ rid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_free_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_create_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_font")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new, empty font cache entry resource. To free the resulting resource, use the ``freeRid(_:)`` method.
    public final func createFont() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(TextServer.method_create_font, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_create_font_linked_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_font_linked_variation")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 41030802)!
            }
            
        }
        
    }()
    
    /// Creates a new variation existing font which is reusing the same glyph cache and font data. To free the resulting resource, use the ``freeRid(_:)`` method.
    public final func createFontLinkedVariation(fontRid: RID) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_create_font_linked_variation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_data")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1355495400)!
            }
            
        }
        
    }()
    
    /// Sets font source data, e.g contents of the dynamic font source file.
    public final func fontSetData(fontRid: RID, data: PackedByteArray) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: data.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_data, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_set_face_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_face_index")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets an active face index in the TrueType / OpenType collection.
    public final func fontSetFaceIndex(fontRid: RID, faceIndex: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: faceIndex) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_face_index, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_face_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_face_index")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns an active face index in the TrueType / OpenType collection.
    public final func fontGetFaceIndex(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_face_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_face_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_face_count")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of faces in the TrueType / OpenType collection.
    public final func fontGetFaceCount(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_face_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_style: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_style")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 898466325)!
            }
            
        }
        
    }()
    
    /// Sets the font style flags, see ``TextServer/FontStyle``.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, ``fontSetEmbolden(fontRid:strength:)``, or ``fontSetTransform(fontRid:transform:)`` instead.
    /// 
    public final func fontSetStyle(fontRid: RID, style: TextServer.FontStyle) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: style.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_style, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_style: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_style")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3082502592)!
            }
            
        }
        
    }()
    
    /// Returns font style flags, see ``TextServer/FontStyle``.
    public final func fontGetStyle(fontRid: RID) -> TextServer.FontStyle {
        var _result: TextServer.FontStyle = TextServer.FontStyle ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_style, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the font family name.
    public final func fontSetName(fontRid: RID, name: String) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns font family name.
    public final func fontGetName(fontRid: RID) -> String {
        let _result = GString ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_font_get_ot_name_strings: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_ot_name_strings")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns ``GDictionary`` with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
    public final func fontGetOtNameStrings(fontRid: RID) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_ot_name_strings, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_style_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_style_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the font style name.
    public final func fontSetStyleName(fontRid: RID, name: String) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_style_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_style_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_style_name")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns font style name.
    public final func fontGetStyleName(fontRid: RID) -> String {
        let _result = GString ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_style_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_font_set_weight: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_weight")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, or ``fontSetEmbolden(fontRid:strength:)`` instead.
    /// 
    public final func fontSetWeight(fontRid: RID, weight: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: weight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_weight, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_weight: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_weight")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
    public final func fontGetWeight(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_weight, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_stretch")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, or ``fontSetTransform(fontRid:transform:)`` instead.
    /// 
    public final func fontSetStretch(fontRid: RID, weight: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: weight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_stretch, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_stretch")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
    public final func fontGetStretch(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_stretch, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_antialiasing: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_antialiasing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 958337235)!
            }
            
        }
        
    }()
    
    /// Sets font anti-aliasing mode.
    public final func fontSetAntialiasing(fontRid: RID, antialiasing: TextServer.FontAntialiasing) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: antialiasing.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_antialiasing, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_antialiasing: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_antialiasing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3389420495)!
            }
            
        }
        
    }()
    
    /// Returns font anti-aliasing mode.
    public final func fontGetAntialiasing(fontRid: RID) -> TextServer.FontAntialiasing {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_antialiasing, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.FontAntialiasing (rawValue: _result)!
    }
    
    fileprivate static var method_font_set_disable_embedded_bitmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_disable_embedded_bitmaps")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true`, embedded font bitmap loading is disabled (bitmap-only and color fonts ignore this property).
    public final func fontSetDisableEmbeddedBitmaps(fontRid: RID, disableEmbeddedBitmaps: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: disableEmbeddedBitmaps) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_disable_embedded_bitmaps, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_disable_embedded_bitmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_disable_embedded_bitmaps")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns whether the font's embedded bitmap loading is disabled.
    public final func fontGetDisableEmbeddedBitmaps(fontRid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_disable_embedded_bitmaps, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_generate_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_generate_mipmaps")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` font texture mipmap generation is enabled.
    public final func fontSetGenerateMipmaps(fontRid: RID, generateMipmaps: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: generateMipmaps) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_generate_mipmaps, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_generate_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_generate_mipmaps")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if font texture mipmap generation is enabled.
    public final func fontGetGenerateMipmaps(fontRid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_generate_mipmaps, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_multichannel_signed_distance_field: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_multichannel_signed_distance_field")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true`, glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
    /// 
    /// > Note: MSDF font rendering does not render glyphs with overlapping shapes correctly. Overlapping shapes are not valid per the OpenType standard, but are still commonly found in many font files, especially those converted by Google Fonts. To avoid issues with overlapping glyphs, consider downloading the font file directly from the type foundry instead of relying on Google Fonts.
    /// 
    public final func fontSetMultichannelSignedDistanceField(fontRid: RID, msdf: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: msdf) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_multichannel_signed_distance_field, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_is_multichannel_signed_distance_field: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_is_multichannel_signed_distance_field")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
    public final func fontIsMultichannelSignedDistanceField(fontRid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_is_multichannel_signed_distance_field, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_msdf_pixel_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_msdf_pixel_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the width of the range around the shape between the minimum and maximum representable signed distance.
    public final func fontSetMsdfPixelRange(fontRid: RID, msdfPixelRange: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: msdfPixelRange) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_msdf_pixel_range, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_msdf_pixel_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_msdf_pixel_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the width of the range around the shape between the minimum and maximum representable signed distance.
    public final func fontGetMsdfPixelRange(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_msdf_pixel_range, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_msdf_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_msdf_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets source font size used to generate MSDF textures.
    public final func fontSetMsdfSize(fontRid: RID, msdfSize: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: msdfSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_msdf_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_msdf_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_msdf_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns source font size used to generate MSDF textures.
    public final func fontGetMsdfSize(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_msdf_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_fixed_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_fixed_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
    public final func fontSetFixedSize(fontRid: RID, fixedSize: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: fixedSize) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_fixed_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_fixed_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_fixed_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns bitmap font fixed size.
    public final func fontGetFixedSize(fontRid: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_fixed_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_fixed_size_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_fixed_size_scale_mode")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1029390307)!
            }
            
        }
        
    }()
    
    /// Sets bitmap font scaling mode. This property is used only if `fixed_size` is greater than zero.
    public final func fontSetFixedSizeScaleMode(fontRid: RID, fixedSizeScaleMode: TextServer.FixedSizeScaleMode) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: fixedSizeScaleMode.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_fixed_size_scale_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_fixed_size_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_fixed_size_scale_mode")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4113120379)!
            }
            
        }
        
    }()
    
    /// Returns bitmap font scaling mode.
    public final func fontGetFixedSizeScaleMode(fontRid: RID) -> TextServer.FixedSizeScaleMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_fixed_size_scale_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.FixedSizeScaleMode (rawValue: _result)!
    }
    
    fileprivate static var method_font_set_allow_system_fallback: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_allow_system_fallback")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true`, system fonts can be automatically used as fallbacks.
    public final func fontSetAllowSystemFallback(fontRid: RID, allowSystemFallback: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: allowSystemFallback) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_allow_system_fallback, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_is_allow_system_fallback: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_is_allow_system_fallback")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if system fonts can be automatically used as fallbacks.
    public final func fontIsAllowSystemFallback(fontRid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_is_allow_system_fallback, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_force_autohinter: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_force_autohinter")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` auto-hinting is preferred over font built-in hinting.
    public final func fontSetForceAutohinter(fontRid: RID, forceAutohinter: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: forceAutohinter) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_force_autohinter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_is_force_autohinter: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_is_force_autohinter")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if auto-hinting is supported and preferred over font built-in hinting. Used by dynamic fonts only.
    public final func fontIsForceAutohinter(fontRid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_is_force_autohinter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_hinting: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_hinting")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1520010864)!
            }
            
        }
        
    }()
    
    /// Sets font hinting mode. Used by dynamic fonts only.
    public final func fontSetHinting(fontRid: RID, hinting: TextServer.Hinting) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: hinting.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_hinting, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_hinting: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_hinting")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3971592737)!
            }
            
        }
        
    }()
    
    /// Returns the font hinting mode. Used by dynamic fonts only.
    public final func fontGetHinting(fontRid: RID) -> TextServer.Hinting {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_hinting, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.Hinting (rawValue: _result)!
    }
    
    fileprivate static var method_font_set_subpixel_positioning: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_subpixel_positioning")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3830459669)!
            }
            
        }
        
    }()
    
    /// Sets font subpixel glyph positioning mode.
    public final func fontSetSubpixelPositioning(fontRid: RID, subpixelPositioning: TextServer.SubpixelPositioning) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: subpixelPositioning.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_subpixel_positioning, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_subpixel_positioning: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_subpixel_positioning")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2752233671)!
            }
            
        }
        
    }()
    
    /// Returns font subpixel glyph positioning mode.
    public final func fontGetSubpixelPositioning(fontRid: RID) -> TextServer.SubpixelPositioning {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_subpixel_positioning, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.SubpixelPositioning (rawValue: _result)!
    }
    
    fileprivate static var method_font_set_embolden: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_embolden")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets font embolden strength. If `strength` is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
    public final func fontSetEmbolden(fontRid: RID, strength: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: strength) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_embolden, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_embolden: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_embolden")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns font embolden strength.
    public final func fontGetEmbolden(fontRid: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_embolden, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_spacing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1307259930)!
            }
            
        }
        
    }()
    
    /// Sets the spacing for `spacing` (see ``TextServer.SpacingType``) to `value` in pixels (not relative to the font size).
    public final func fontSetSpacing(fontRid: RID, spacing: TextServer.SpacingType, value: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: spacing.rawValue) { pArg1 in
                withUnsafePointer(to: value) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_spacing, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_spacing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1213653558)!
            }
            
        }
        
    }()
    
    /// Returns the spacing for `spacing` (see ``TextServer.SpacingType``) in pixels (not relative to the font size).
    public final func fontGetSpacing(fontRid: RID, spacing: TextServer.SpacingType) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: spacing.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_spacing, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_baseline_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_baseline_offset")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets extra baseline offset (as a fraction of font height).
    public final func fontSetBaselineOffset(fontRid: RID, baselineOffset: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: baselineOffset) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_baseline_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_baseline_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_baseline_offset")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns extra baseline offset (as a fraction of font height).
    public final func fontGetBaselineOffset(fontRid: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_baseline_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_transform")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
    /// 
    /// For example, to simulate italic typeface by slanting, apply the following transform `Transform2D(1.0, slant, 0.0, 1.0, 0.0, 0.0)`.
    /// 
    public final func fontSetTransform(fontRid: RID, transform: Transform2D) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: transform) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_transform")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 213527486)!
            }
            
        }
        
    }()
    
    /// Returns 2D transform applied to the font outlines.
    public final func fontGetTransform(fontRid: RID) -> Transform2D {
        var _result: Transform2D = Transform2D ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_variation_coordinates: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_variation_coordinates")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1217542888)!
            }
            
        }
        
    }()
    
    /// Sets variation coordinates for the specified font cache entry. See ``fontSupportedVariationList(fontRid:)`` for more info.
    public final func fontSetVariationCoordinates(fontRid: RID, variationCoordinates: GDictionary) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: variationCoordinates.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_variation_coordinates, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_variation_coordinates: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_variation_coordinates")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns variation coordinates for the specified font cache entry. See ``fontSupportedVariationList(fontRid:)`` for more info.
    public final func fontGetVariationCoordinates(fontRid: RID) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_variation_coordinates, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_oversampling")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets font oversampling factor, if set to `0.0` global oversampling factor is used instead. Used by dynamic fonts only.
    public final func fontSetOversampling(fontRid: RID, oversampling: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: oversampling) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_oversampling, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_oversampling")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns font oversampling factor, if set to `0.0` global oversampling factor is used instead. Used by dynamic fonts only.
    public final func fontGetOversampling(fontRid: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_oversampling, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_size_cache_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_size_cache_list")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns list of the font sizes in the cache. Each size is ``Vector2i`` with font size and outline size.
    public final func fontGetSizeCacheList(fontRid: RID) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_size_cache_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_font_clear_size_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_clear_size_cache")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Removes all font sizes from the cache entry.
    public final func fontClearSizeCache(fontRid: RID) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_clear_size_cache, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_remove_size_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_size_cache")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes specified font size from the cache entry.
    public final func fontRemoveSizeCache(fontRid: RID, size: Vector2i) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_remove_size_cache, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_set_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_ascent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets the font ascent (number of pixels above the baseline).
    public final func fontSetAscent(fontRid: RID, size: Int, ascent: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: ascent) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_ascent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_ascent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns the font ascent (number of pixels above the baseline).
    public final func fontGetAscent(fontRid: RID, size: Int) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_ascent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_descent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets the font descent (number of pixels below the baseline).
    public final func fontSetDescent(fontRid: RID, size: Int, descent: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: descent) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_descent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_descent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns the font descent (number of pixels below the baseline).
    public final func fontGetDescent(fontRid: RID, size: Int) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_descent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_underline_position")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets pixel offset of the underline below the baseline.
    public final func fontSetUnderlinePosition(fontRid: RID, size: Int, underlinePosition: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: underlinePosition) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_underline_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_underline_position")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns pixel offset of the underline below the baseline.
    public final func fontGetUnderlinePosition(fontRid: RID, size: Int) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_underline_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_underline_thickness")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets thickness of the underline in pixels.
    public final func fontSetUnderlineThickness(fontRid: RID, size: Int, underlineThickness: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: underlineThickness) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_underline_thickness, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_underline_thickness")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns thickness of the underline in pixels.
    public final func fontGetUnderlineThickness(fontRid: RID, size: Int) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_underline_thickness, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_scale")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets scaling factor of the color bitmap font.
    public final func fontSetScale(fontRid: RID, size: Int, scale: Double) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: scale) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_scale")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns scaling factor of the color bitmap font.
    public final func fontGetScale(fontRid: RID, size: Int) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_texture_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_texture_count")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1311001310)!
            }
            
        }
        
    }()
    
    /// Returns number of textures used by font cache entry.
    public final func fontGetTextureCount(fontRid: RID, size: Vector2i) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_texture_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_clear_textures: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_clear_textures")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes all textures from font cache entry.
    /// 
    /// > Note: This function will not remove glyphs associated with the texture, use ``fontRemoveGlyph(fontRid:size:glyph:)`` to remove them manually.
    /// 
    public final func fontClearTextures(fontRid: RID, size: Vector2i) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_clear_textures, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_remove_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_texture")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Removes specified texture from the cache entry.
    /// 
    /// > Note: This function will not remove glyphs associated with the texture, remove them manually, using ``fontRemoveGlyph(fontRid:size:glyph:)``.
    /// 
    public final func fontRemoveTexture(fontRid: RID, size: Vector2i, textureIndex: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: textureIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_remove_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_set_texture_image: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_texture_image")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2354485091)!
            }
            
        }
        
    }()
    
    /// Sets font cache texture image data.
    public final func fontSetTextureImage(fontRid: RID, size: Vector2i, textureIndex: Int, image: Image?) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: textureIndex) { pArg2 in
                    withUnsafePointer(to: image?.handle) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_texture_image, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_texture_image: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_texture_image")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2451761155)!
            }
            
        }
        
    }()
    
    /// Returns font cache texture image data.
    public final func fontGetTextureImage(fontRid: RID, size: Vector2i, textureIndex: Int) -> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: textureIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_texture_image, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_font_set_texture_offsets: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_texture_offsets")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3005398047)!
            }
            
        }
        
    }()
    
    /// Sets array containing glyph packing data.
    public final func fontSetTextureOffsets(fontRid: RID, size: Vector2i, textureIndex: Int, offset: PackedInt32Array) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: textureIndex) { pArg2 in
                    withUnsafePointer(to: offset.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_texture_offsets, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_texture_offsets: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_texture_offsets")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3420028887)!
            }
            
        }
        
    }()
    
    /// Returns array containing glyph packing data.
    public final func fontGetTextureOffsets(fontRid: RID, size: Vector2i, textureIndex: Int) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: textureIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_texture_offsets, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_glyph_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_list")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 46086620)!
            }
            
        }
        
    }()
    
    /// Returns list of rendered glyphs in the cache entry.
    public final func fontGetGlyphList(fontRid: RID, size: Vector2i) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_clear_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_clear_glyphs")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes all rendered glyph information from the cache entry.
    /// 
    /// > Note: This function will not remove textures associated with the glyphs, use ``fontRemoveTexture(fontRid:size:textureIndex:)`` to remove them manually.
    /// 
    public final func fontClearGlyphs(fontRid: RID, size: Vector2i) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_clear_glyphs, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_remove_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_glyph")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Removes specified rendered glyph information from the cache entry.
    /// 
    /// > Note: This function will not remove textures associated with the glyphs, use ``fontRemoveTexture(fontRid:size:textureIndex:)`` to remove them manually.
    /// 
    public final func fontRemoveGlyph(fontRid: RID, size: Vector2i, glyph: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_remove_glyph, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_advance")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2555689501)!
            }
            
        }
        
    }()
    
    /// Returns glyph advance (offset of the next glyph).
    /// 
    /// > Note: Advance for glyphs outlines is the same as the base glyph advance and is not saved.
    /// 
    public final func fontGetGlyphAdvance(fontRid: RID, size: Int, glyph: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_advance, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_glyph_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_glyph_advance")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3219397315)!
            }
            
        }
        
    }()
    
    /// Sets glyph advance (offset of the next glyph).
    /// 
    /// > Note: Advance for glyphs outlines is the same as the base glyph advance and is not saved.
    /// 
    public final func fontSetGlyphAdvance(fontRid: RID, size: Int, glyph: Int, advance: Vector2) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: advance) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_glyph_advance, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_offset")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns glyph offset from the baseline.
    public final func fontGetGlyphOffset(fontRid: RID, size: Vector2i, glyph: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_glyph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_glyph_offset")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1812632090)!
            }
            
        }
        
    }()
    
    /// Sets glyph offset from the baseline.
    public final func fontSetGlyphOffset(fontRid: RID, size: Vector2i, glyph: Int, offset: Vector2) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: offset) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_glyph_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns size of the glyph.
    public final func fontGetGlyphSize(fontRid: RID, size: Vector2i, glyph: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_glyph_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_glyph_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1812632090)!
            }
            
        }
        
    }()
    
    /// Sets size of the glyph.
    public final func fontSetGlyphSize(fontRid: RID, size: Vector2i, glyph: Int, glSize: Vector2) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: glSize) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_glyph_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_uv_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_uv_rect")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2274268786)!
            }
            
        }
        
    }()
    
    /// Returns rectangle in the cache texture containing the glyph.
    public final func fontGetGlyphUvRect(fontRid: RID, size: Vector2i, glyph: Int) -> Rect2 {
        var _result: Rect2 = Rect2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_uv_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_glyph_uv_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_glyph_uv_rect")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1973324081)!
            }
            
        }
        
    }()
    
    /// Sets rectangle in the cache texture containing the glyph.
    public final func fontSetGlyphUvRect(fontRid: RID, size: Vector2i, glyph: Int, uvRect: Rect2) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: uvRect) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_glyph_uv_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_texture_idx: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_texture_idx")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4292800474)!
            }
            
        }
        
    }()
    
    /// Returns index of the cache texture containing the glyph.
    public final func fontGetGlyphTextureIdx(fontRid: RID, size: Vector2i, glyph: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_texture_idx, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_glyph_texture_idx: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_glyph_texture_idx")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4254580980)!
            }
            
        }
        
    }()
    
    /// Sets index of the cache texture containing the glyph.
    public final func fontSetGlyphTextureIdx(fontRid: RID, size: Vector2i, glyph: Int, textureIdx: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: textureIdx) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_glyph_texture_idx, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_glyph_texture_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_texture_rid")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1451696141)!
            }
            
        }
        
    }()
    
    /// Returns resource ID of the cache texture containing the glyph.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontGetGlyphTextureRid(fontRid: RID, size: Vector2i, glyph: Int) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_texture_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_glyph_texture_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_texture_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns size of the cache texture containing the glyph.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontGetGlyphTextureSize(fontRid: RID, size: Vector2i, glyph: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyph) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_texture_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_glyph_contours: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_contours")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2903964473)!
            }
            
        }
        
    }()
    
    /// Returns outline contours of the glyph as a ``GDictionary`` with the following contents:
    /// 
    /// `points`         - ``PackedVector3Array``, containing outline points. `x` and `y` are point coordinates. `z` is the type of the point, using the ``TextServer/ContourPointTag`` values.
    /// 
    /// `contours`       - ``PackedInt32Array``, containing indices the end points of each contour.
    /// 
    /// `orientation`    - [bool], contour orientation. If `true`, clockwise contours must be filled.
    /// 
    public final func fontGetGlyphContours(font: RID, size: Int, index: Int) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: font.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: index) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_contours, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_kerning_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_kerning_list")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1778388067)!
            }
            
        }
        
    }()
    
    /// Returns list of the kerning overrides.
    public final func fontGetKerningList(fontRid: RID, size: Int) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_kerning_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_font_clear_kerning_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_clear_kerning_map")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Removes all kerning overrides.
    public final func fontClearKerningMap(fontRid: RID, size: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_clear_kerning_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_remove_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_kerning")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2141860016)!
            }
            
        }
        
    }()
    
    /// Removes kerning override for the pair of glyphs.
    public final func fontRemoveKerning(fontRid: RID, size: Int, glyphPair: Vector2i) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyphPair) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_remove_kerning, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_set_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_kerning")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3630965883)!
            }
            
        }
        
    }()
    
    /// Sets kerning for the pair of glyphs.
    public final func fontSetKerning(fontRid: RID, size: Int, glyphPair: Vector2i, kerning: Vector2) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyphPair) { pArg2 in
                    withUnsafePointer(to: kerning) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_set_kerning, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_kerning")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1019980169)!
            }
            
        }
        
    }()
    
    /// Returns kerning for the pair of glyphs.
    public final func fontGetKerning(fontRid: RID, size: Int, glyphPair: Vector2i) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyphPair) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_kerning, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_glyph_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_glyph_index")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1765635060)!
            }
            
        }
        
    }()
    
    /// Returns the glyph index of a `char`, optionally modified by the `variationSelector`. See ``fontGetCharFromGlyphIndex(fontRid:size:glyphIndex:)``.
    public final func fontGetGlyphIndex(fontRid: RID, size: Int, char: Int, variationSelector: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: char) { pArg2 in
                    withUnsafePointer(to: variationSelector) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_get_glyph_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_char_from_glyph_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_char_from_glyph_index")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2156738276)!
            }
            
        }
        
    }()
    
    /// Returns character code associated with `glyphIndex`, or `0` if `glyphIndex` is invalid. See ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    public final func fontGetCharFromGlyphIndex(fontRid: RID, size: Int, glyphIndex: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: glyphIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_get_char_from_glyph_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_has_char: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_has_char")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a Unicode `char` is available in the font.
    public final func fontHasChar(fontRid: RID, char: Int) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: char) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_has_char, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_supported_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_supported_chars")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns a string containing all the characters available in the font.
    public final func fontGetSupportedChars(fontRid: RID) -> String {
        let _result = GString ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_supported_chars, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_font_render_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_render_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4254580980)!
            }
            
        }
        
    }()
    
    /// Renders the range of characters to the font cache texture.
    public final func fontRenderRange(fontRid: RID, size: Vector2i, start: Int, end: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: start) { pArg2 in
                    withUnsafePointer(to: end) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_font_render_range, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_render_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_render_glyph")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Renders specified glyph to the font cache texture.
    public final func fontRenderGlyph(fontRid: RID, size: Vector2i, index: Int) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: index) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_render_glyph, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_draw_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_draw_glyph")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1339057948)!
            }
            
        }
        
    }()
    
    /// Draws single glyph into a canvas item at the position, using `fontRid` at the size `size`.
    /// 
    /// > Note: Glyph index is specific to the font, use glyphs indices returned by ``shapedTextGetGlyphs(shaped:)`` or ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontDrawGlyph(fontRid: RID, canvas: RID, size: Int, pos: Vector2, index: Int, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: canvas.content) { pArg1 in
                withUnsafePointer(to: size) { pArg2 in
                    withUnsafePointer(to: pos) { pArg3 in
                        withUnsafePointer(to: index) { pArg4 in
                            withUnsafePointer(to: color) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(TextServer.method_font_draw_glyph, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_draw_glyph_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_draw_glyph_outline")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2626165733)!
            }
            
        }
        
    }()
    
    /// Draws single glyph outline of size `outlineSize` into a canvas item at the position, using `fontRid` at the size `size`.
    /// 
    /// > Note: Glyph index is specific to the font, use glyphs indices returned by ``shapedTextGetGlyphs(shaped:)`` or ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontDrawGlyphOutline(fontRid: RID, canvas: RID, size: Int, outlineSize: Int, pos: Vector2, index: Int, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: canvas.content) { pArg1 in
                withUnsafePointer(to: size) { pArg2 in
                    withUnsafePointer(to: outlineSize) { pArg3 in
                        withUnsafePointer(to: pos) { pArg4 in
                            withUnsafePointer(to: index) { pArg5 in
                                withUnsafePointer(to: color) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(TextServer.method_font_draw_glyph_outline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_is_language_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_is_language_supported")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3199320846)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if font supports given language (<a href="https://en.wikipedia.org/wiki/ISO_639-1">ISO 639</a> code).
    public final func fontIsLanguageSupported(fontRid: RID, language: String) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_is_language_supported, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_language_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2313957094)!
            }
            
        }
        
    }()
    
    /// Adds override for ``fontIsLanguageSupported(fontRid:language:)``.
    public final func fontSetLanguageSupportOverride(fontRid: RID, language: String, supported: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: supported) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_language_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_language_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2829184646)!
            }
            
        }
        
    }()
    
    /// Returns `true` if support override is enabled for the `language`.
    public final func fontGetLanguageSupportOverride(fontRid: RID, language: String) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_language_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_remove_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_language_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Remove language support override.
    public final func fontRemoveLanguageSupportOverride(fontRid: RID, language: String) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_remove_language_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_language_support_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_language_support_overrides")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2801473409)!
            }
            
        }
        
    }()
    
    /// Returns list of language support overrides.
    public final func fontGetLanguageSupportOverrides(fontRid: RID) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_language_support_overrides, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_is_script_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_is_script_supported")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3199320846)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if font supports given script (ISO 15924 code).
    public final func fontIsScriptSupported(fontRid: RID, script: String) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let script = GString(script)
            withUnsafePointer(to: script.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_is_script_supported, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_script_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2313957094)!
            }
            
        }
        
    }()
    
    /// Adds override for ``fontIsScriptSupported(fontRid:script:)``.
    public final func fontSetScriptSupportOverride(fontRid: RID, script: String, supported: Bool) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let script = GString(script)
            withUnsafePointer(to: script.content) { pArg1 in
                withUnsafePointer(to: supported) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_font_set_script_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_script_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2829184646)!
            }
            
        }
        
    }()
    
    /// Returns `true` if support override is enabled for the `script`.
    public final func fontGetScriptSupportOverride(fontRid: RID, script: String) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let script = GString(script)
            withUnsafePointer(to: script.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_get_script_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_remove_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_remove_script_support_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Removes script support override.
    public final func fontRemoveScriptSupportOverride(fontRid: RID, script: String) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            let script = GString(script)
            withUnsafePointer(to: script.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_remove_script_support_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_script_support_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_script_support_overrides")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2801473409)!
            }
            
        }
        
    }()
    
    /// Returns list of script support overrides.
    public final func fontGetScriptSupportOverrides(fontRid: RID) -> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_script_support_overrides, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_set_opentype_feature_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_opentype_feature_overrides")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1217542888)!
            }
            
        }
        
    }()
    
    /// Sets font OpenType feature set override.
    public final func fontSetOpentypeFeatureOverrides(fontRid: RID, overrides: GDictionary) {
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: overrides.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_font_set_opentype_feature_overrides, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_font_get_opentype_feature_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_opentype_feature_overrides")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns font OpenType feature set override.
    public final func fontGetOpentypeFeatureOverrides(fontRid: RID) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_get_opentype_feature_overrides, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_supported_feature_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_supported_feature_list")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns the dictionary of the supported OpenType features.
    public final func fontSupportedFeatureList(fontRid: RID) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_supported_feature_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_supported_variation_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_supported_variation_list")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns the dictionary of the supported OpenType variation coordinates.
    public final func fontSupportedVariationList(fontRid: RID) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: fontRid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_supported_variation_list, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_font_get_global_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_get_global_oversampling")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the font oversampling factor, shared by all fonts in the TextServer.
    public final func fontGetGlobalOversampling() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(TextServer.method_font_get_global_oversampling, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_font_set_global_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName("font_set_global_oversampling")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    /// Sets oversampling factor, shared by all font in the TextServer.
    /// 
    /// > Note: This value can be automatically changed by display server.
    /// 
    public final func fontSetGlobalOversampling(_ oversampling: Double) {
        withUnsafePointer(to: oversampling) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_font_set_global_oversampling, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_hex_code_box_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hex_code_box_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
    public final func getHexCodeBoxSize(_ size: Int, index: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: index) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_get_hex_code_box_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_hex_code_box: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_hex_code_box")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1602046441)!
            }
            
        }
        
    }()
    
    /// Draws box displaying character hexadecimal code. Used for replacing missing characters.
    public final func drawHexCodeBox(canvas: RID, size: Int, pos: Vector2, index: Int, color: Color) {
        withUnsafePointer(to: canvas.content) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: pos) { pArg2 in
                    withUnsafePointer(to: index) { pArg3 in
                        withUnsafePointer(to: color) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TextServer.method_draw_hex_code_box, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_create_shaped_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_shaped_text")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1231398698)!
            }
            
        }
        
    }()
    
    /// Creates a new buffer for complex text layout, with the given `direction` and `orientation`. To free the resulting buffer, use ``freeRid(_:)`` method.
    /// 
    /// > Note: Direction is ignored if server does not support ``Feature/bidiLayout`` feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: Orientation is ignored if server does not support ``Feature/verticalLayout`` feature (supported by ``TextServerAdvanced``).
    /// 
    public final func createShapedText(direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: orientation.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_create_shaped_text, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_clear")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Clears text buffer (removes text and inline objects).
    public final func shapedTextClear(rid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_clear, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_set_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_direction")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1551430183)!
            }
            
        }
        
    }()
    
    /// Sets desired text direction. If set to ``Direction/auto``, direction will be detected based on the buffer contents and current locale.
    /// 
    /// > Note: Direction is ignored if server does not support ``Feature/bidiLayout`` feature (supported by ``TextServerAdvanced``).
    /// 
    public final func shapedTextSetDirection(shaped: RID, direction: TextServer.Direction = .auto) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: direction.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_direction")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3065904362)!
            }
            
        }
        
    }()
    
    /// Returns direction of the text.
    public final func shapedTextGetDirection(shaped: RID) -> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.Direction (rawValue: _result)!
    }
    
    fileprivate static var method_shaped_text_get_inferred_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_inferred_direction")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3065904362)!
            }
            
        }
        
    }()
    
    /// Returns direction of the text, inferred by the BiDi algorithm.
    public final func shapedTextGetInferredDirection(shaped: RID) -> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_inferred_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.Direction (rawValue: _result)!
    }
    
    fileprivate static var method_shaped_text_set_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_bidi_override")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 684822712)!
            }
            
        }
        
    }()
    
    /// Overrides BiDi for the structured text.
    /// 
    /// Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
    /// 
    public final func shapedTextSetBidiOverride(shaped: RID, override: GArray) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: override.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_bidi_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_set_custom_punctuation: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_custom_punctuation")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
    public final func shapedTextSetCustomPunctuation(shaped: RID, punct: String) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            let punct = GString(punct)
            withUnsafePointer(to: punct.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_custom_punctuation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_custom_punctuation: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_custom_punctuation")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
    public final func shapedTextGetCustomPunctuation(shaped: RID) -> String {
        let _result = GString ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_custom_punctuation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_shaped_text_set_custom_ellipsis: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_custom_ellipsis")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets ellipsis character used for text clipping.
    public final func shapedTextSetCustomEllipsis(shaped: RID, char: Int) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: char) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_custom_ellipsis, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_custom_ellipsis: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_custom_ellipsis")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns ellipsis character used for text clipping.
    public final func shapedTextGetCustomEllipsis(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_custom_ellipsis, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_set_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_orientation")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3019609126)!
            }
            
        }
        
    }()
    
    /// Sets desired text orientation.
    /// 
    /// > Note: Orientation is ignored if server does not support ``Feature/verticalLayout`` feature (supported by ``TextServerAdvanced``).
    /// 
    public final func shapedTextSetOrientation(shaped: RID, orientation: TextServer.Orientation = .horizontal) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: orientation.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_orientation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_orientation")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3142708106)!
            }
            
        }
        
    }()
    
    /// Returns text orientation.
    public final func shapedTextGetOrientation(shaped: RID) -> TextServer.Orientation {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_orientation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TextServer.Orientation (rawValue: _result)!
    }
    
    fileprivate static var method_shaped_text_set_preserve_invalid: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_preserve_invalid")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
    public final func shapedTextSetPreserveInvalid(shaped: RID, enabled: Bool) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_preserve_invalid, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_preserve_invalid: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_preserve_invalid")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer is configured to display hexadecimal codes in place of invalid characters.
    /// 
    /// > Note: If set to `false`, nothing is displayed in place of invalid characters.
    /// 
    public final func shapedTextGetPreserveInvalid(shaped: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_preserve_invalid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_set_preserve_control: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_preserve_control")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` text buffer will display control characters.
    public final func shapedTextSetPreserveControl(shaped: RID, enabled: Bool) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_preserve_control, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_preserve_control: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_preserve_control")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer is configured to display control characters.
    public final func shapedTextGetPreserveControl(shaped: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_preserve_control, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_set_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_set_spacing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1307259930)!
            }
            
        }
        
    }()
    
    /// Sets extra spacing added between glyphs or lines in pixels.
    public final func shapedTextSetSpacing(shaped: RID, spacing: TextServer.SpacingType, value: Int) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: spacing.rawValue) { pArg1 in
                withUnsafePointer(to: value) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_set_spacing, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_spacing")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1213653558)!
            }
            
        }
        
    }()
    
    /// Returns extra spacing added between glyphs or lines in pixels.
    public final func shapedTextGetSpacing(shaped: RID, spacing: TextServer.SpacingType) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: spacing.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_spacing, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_add_string: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_add_string")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 623473029)!
            }
            
        }
        
    }()
    
    /// Adds text span and font to draw it to the text buffer.
    public final func shapedTextAddString(shaped: RID, text: String, fonts: VariantCollection<RID>, size: Int, opentypeFeatures: GDictionary = GDictionary (), language: String = "", meta: Variant?) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            let text = GString(text)
            withUnsafePointer(to: text.content) { pArg1 in
                withUnsafePointer(to: fonts.array.content) { pArg2 in
                    withUnsafePointer(to: size) { pArg3 in
                        withUnsafePointer(to: opentypeFeatures.content) { pArg4 in
                            let language = GString(language)
                            withUnsafePointer(to: language.content) { pArg5 in
                                withUnsafePointer(to: meta.content) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_add_string, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_add_object: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_add_object")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3664424789)!
            }
            
        }
        
    }()
    
    /// Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
    public final func shapedTextAddObject(shaped: RID, key: Variant?, size: Vector2, inlineAlign: InlineAlignment = .center, length: Int = 1, baseline: Double = 0.0) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: key.content) { pArg1 in
                withUnsafePointer(to: size) { pArg2 in
                    withUnsafePointer(to: inlineAlign.rawValue) { pArg3 in
                        withUnsafePointer(to: length) { pArg4 in
                            withUnsafePointer(to: baseline) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_add_object, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_resize_object: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_resize_object")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 790361552)!
            }
            
        }
        
    }()
    
    /// Sets new size and alignment of embedded object.
    public final func shapedTextResizeObject(shaped: RID, key: Variant?, size: Vector2, inlineAlign: InlineAlignment = .center, baseline: Double = 0.0) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: key.content) { pArg1 in
                withUnsafePointer(to: size) { pArg2 in
                    withUnsafePointer(to: inlineAlign.rawValue) { pArg3 in
                        withUnsafePointer(to: baseline) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_resize_object, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_get_span_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_get_span_count")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of text spans added using ``shapedTextAddString(shaped:text:fonts:size:opentypeFeatures:language:meta:)`` or ``shapedTextAddObject(shaped:key:size:inlineAlign:length:baseline:)``.
    public final func shapedGetSpanCount(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_get_span_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_get_span_meta: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_get_span_meta")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4069510997)!
            }
            
        }
        
    }()
    
    /// Returns text span metadata.
    public final func shapedGetSpanMeta(shaped: RID, index: Int) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: index) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_get_span_meta, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_shaped_set_span_update_font: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_set_span_update_font")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2022725822)!
            }
            
        }
        
    }()
    
    /// Changes text span font, font size, and OpenType features, without changing the text.
    public final func shapedSetSpanUpdateFont(shaped: RID, index: Int, fonts: VariantCollection<RID>, size: Int, opentypeFeatures: GDictionary = GDictionary ()) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: index) { pArg1 in
                withUnsafePointer(to: fonts.array.content) { pArg2 in
                    withUnsafePointer(to: size) { pArg3 in
                        withUnsafePointer(to: opentypeFeatures.content) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TextServer.method_shaped_set_span_update_font, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_substr: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_substr")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1937682086)!
            }
            
        }
        
    }()
    
    /// Returns text buffer for the substring of the text in the `shaped` text buffer (including inline objects).
    public final func shapedTextSubstr(shaped: RID, start: Int, length: Int) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: start) { pArg1 in
                withUnsafePointer(to: length) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_substr, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_parent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3814569979)!
            }
            
        }
        
    }()
    
    /// Returns the parent buffer from which the substring originates.
    public final func shapedTextGetParent(shaped: RID) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_parent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_fit_to_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_fit_to_width")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 530670926)!
            }
            
        }
        
    }()
    
    /// Adjusts text width to fit to specified width, returns new text width.
    public final func shapedTextFitToWidth(shaped: RID, width: Double, justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound]) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: justificationFlags.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_fit_to_width, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_tab_align: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_tab_align")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1283669550)!
            }
            
        }
        
    }()
    
    /// Aligns shaped text to the given tab-stops.
    public final func shapedTextTabAlign(shaped: RID, tabStops: PackedFloat32Array) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: tabStops.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_tab_align, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_shape")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Shapes buffer if it's not shaped. Returns `true` if the string is shaped successfully.
    /// 
    /// > Note: It is not necessary to call this function manually, buffer will be shaped automatically as soon as any of its output data is requested.
    /// 
    public final func shapedTextShape(shaped: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_shape, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_is_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_is_ready")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if buffer is successfully shaped.
    public final func shapedTextIsReady(shaped: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_is_ready, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_has_visible_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_has_visible_chars")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer contains any visible characters.
    public final func shapedTextHasVisibleChars(shaped: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_has_visible_chars, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_glyphs")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns an array of glyphs in the visual order.
    public final func shapedTextGetGlyphs(shaped: RID) -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_glyphs, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_shaped_text_sort_logical: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_sort_logical")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2670461153)!
            }
            
        }
        
    }()
    
    /// Returns text glyphs in the logical order.
    public final func shapedTextSortLogical(shaped: RID) -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_sort_logical, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_shaped_text_get_glyph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_glyph_count")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of glyphs in the buffer.
    public final func shapedTextGetGlyphCount(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_glyph_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 733700038)!
            }
            
        }
        
    }()
    
    /// Returns substring buffer character range in the parent buffer.
    public final func shapedTextGetRange(shaped: RID) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_range, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_line_breaks_adv: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_line_breaks_adv")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2376991424)!
            }
            
        }
        
    }()
    
    /// Breaks text to the lines and columns. Returns character ranges for each segment.
    public final func shapedTextGetLineBreaksAdv(shaped: RID, width: PackedFloat32Array, start: Int = 0, once: Bool = true, breakFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound]) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: width.content) { pArg1 in
                withUnsafePointer(to: start) { pArg2 in
                    withUnsafePointer(to: once) { pArg3 in
                        withUnsafePointer(to: breakFlags.rawValue) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_line_breaks_adv, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_line_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_line_breaks")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2651359741)!
            }
            
        }
        
    }()
    
    /// Breaks text to the lines and returns character ranges for each line.
    public final func shapedTextGetLineBreaks(shaped: RID, width: Double, start: Int = 0, breakFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound]) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: start) { pArg2 in
                    withUnsafePointer(to: breakFlags.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_line_breaks, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_word_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_word_breaks")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4099476853)!
            }
            
        }
        
    }()
    
    /// Breaks text into words and returns array of character ranges. Use `graphemeFlags` to set what characters are used for breaking (see ``TextServer/GraphemeFlag``).
    public final func shapedTextGetWordBreaks(shaped: RID, graphemeFlags: TextServer.GraphemeFlag = [.space, .punctuation], skipGraphemeFlags: TextServer.GraphemeFlag = [.virtual]) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: graphemeFlags.rawValue) { pArg1 in
                withUnsafePointer(to: skipGraphemeFlags.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_word_breaks, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_trim_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_trim_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the position of the overrun trim.
    public final func shapedTextGetTrimPos(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_trim_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_ellipsis_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns position of the ellipsis.
    public final func shapedTextGetEllipsisPos(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_ellipsis_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_ellipsis_glyphs")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns array of the glyphs in the ellipsis.
    public final func shapedTextGetEllipsisGlyphs(shaped: RID) -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_ellipsis_glyphs, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_glyph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_ellipsis_glyph_count")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of glyphs in the ellipsis.
    public final func shapedTextGetEllipsisGlyphCount(shaped: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_ellipsis_glyph_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_overrun_trim_to_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_overrun_trim_to_width")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2723146520)!
            }
            
        }
        
    }()
    
    /// Trims text if it exceeds the given width.
    public final func shapedTextOverrunTrimToWidth(shaped: RID, width: Double = 0, overrunTrimFlags: TextServer.TextOverrunFlag = []) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: overrunTrimFlags.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_overrun_trim_to_width, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_objects: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_objects")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns array of inline objects.
    public final func shapedTextGetObjects(shaped: RID) -> GArray {
        let _result: GArray = GArray ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_objects, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_object_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_object_rect")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 447978354)!
            }
            
        }
        
    }()
    
    /// Returns bounding rectangle of the inline object.
    public final func shapedTextGetObjectRect(shaped: RID, key: Variant?) -> Rect2 {
        var _result: Rect2 = Rect2 ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: key.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_object_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_object_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_object_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2524675647)!
            }
            
        }
        
    }()
    
    /// Returns the character range of the inline object.
    public final func shapedTextGetObjectRange(shaped: RID, key: Variant?) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: key.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_object_range, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_object_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_object_glyph")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1260085030)!
            }
            
        }
        
    }()
    
    /// Returns the glyph index of the inline object.
    public final func shapedTextGetObjectGlyph(shaped: RID, key: Variant?) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: key.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_object_glyph, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_size")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2440833711)!
            }
            
        }
        
    }()
    
    /// Returns size of the text.
    public final func shapedTextGetSize(shaped: RID) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_size, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_ascent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
    /// 
    /// > Note: Overall ascent can be higher than font ascent, if some glyphs are displaced from the baseline.
    /// 
    public final func shapedTextGetAscent(shaped: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_ascent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_descent")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
    /// 
    /// > Note: Overall descent can be higher than font descent, if some glyphs are displaced from the baseline.
    /// 
    public final func shapedTextGetDescent(shaped: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_descent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_width")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns width (for horizontal layout) or height (for vertical) of the text.
    public final func shapedTextGetWidth(shaped: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_width, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_underline_position")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns pixel offset of the underline below the baseline.
    public final func shapedTextGetUnderlinePosition(shaped: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_underline_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_underline_thickness")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns thickness of the underline.
    public final func shapedTextGetUnderlineThickness(shaped: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_underline_thickness, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_carets")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1574219346)!
            }
            
        }
        
    }()
    
    /// Returns shapes of the carets corresponding to the character offset `position` in the text. Returned caret shape is 1 pixel wide rectangle.
    public final func shapedTextGetCarets(shaped: RID, position: Int) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_carets, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_selection")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3714187733)!
            }
            
        }
        
    }()
    
    /// Returns selection rectangles for the specified character range.
    public final func shapedTextGetSelection(shaped: RID, start: Int, end: Int) -> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: start) { pArg1 in
                withUnsafePointer(to: end) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_selection, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_hit_test_grapheme: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_hit_test_grapheme")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3149310417)!
            }
            
        }
        
    }()
    
    /// Returns grapheme index at the specified pixel offset at the baseline, or `-1` if none is found.
    public final func shapedTextHitTestGrapheme(shaped: RID, coords: Double) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_hit_test_grapheme, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_hit_test_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_hit_test_position")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3149310417)!
            }
            
        }
        
    }()
    
    /// Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
    public final func shapedTextHitTestPosition(shaped: RID, coords: Double) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: coords) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_hit_test_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_grapheme_bounds: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_grapheme_bounds")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2546185844)!
            }
            
        }
        
    }()
    
    /// Returns composite character's bounds as offsets from the start of the line.
    public final func shapedTextGetGraphemeBounds(shaped: RID, pos: Int) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_grapheme_bounds, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_next_grapheme_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_next_grapheme_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns grapheme end position closest to the `pos`.
    public final func shapedTextNextGraphemePos(shaped: RID, pos: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_next_grapheme_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_prev_grapheme_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_prev_grapheme_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns grapheme start position closest to the `pos`.
    public final func shapedTextPrevGraphemePos(shaped: RID, pos: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_prev_grapheme_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_get_character_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_character_breaks")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 788230395)!
            }
            
        }
        
    }()
    
    /// Returns array of the composite character boundaries.
    public final func shapedTextGetCharacterBreaks(shaped: RID) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_character_breaks, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_next_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_next_character_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character end position closest to the `pos`.
    public final func shapedTextNextCharacterPos(shaped: RID, pos: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_next_character_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_prev_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_prev_character_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character start position closest to the `pos`.
    public final func shapedTextPrevCharacterPos(shaped: RID, pos: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_prev_character_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_closest_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_closest_character_pos")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character position closest to the `pos`.
    public final func shapedTextClosestCharacterPos(shaped: RID, pos: Int) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: pos) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_closest_character_pos, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shaped_text_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_draw")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 880389142)!
            }
            
        }
        
    }()
    
    /// Draw shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
    public final func shapedTextDraw(shaped: RID, canvas: RID, pos: Vector2, clipL: Double = -1, clipR: Double = -1, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: canvas.content) { pArg1 in
                withUnsafePointer(to: pos) { pArg2 in
                    withUnsafePointer(to: clipL) { pArg3 in
                        withUnsafePointer(to: clipR) { pArg4 in
                            withUnsafePointer(to: color) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(TextServer.method_shaped_text_draw, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_draw_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_draw_outline")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2559184194)!
            }
            
        }
        
    }()
    
    /// Draw the outline of the shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
    public final func shapedTextDrawOutline(shaped: RID, canvas: RID, pos: Vector2, clipL: Double = -1, clipR: Double = -1, outlineSize: Int = 1, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: canvas.content) { pArg1 in
                withUnsafePointer(to: pos) { pArg2 in
                    withUnsafePointer(to: clipL) { pArg3 in
                        withUnsafePointer(to: clipR) { pArg4 in
                            withUnsafePointer(to: outlineSize) { pArg5 in
                                withUnsafePointer(to: color) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_draw_outline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_shaped_text_get_dominant_direction_in_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("shaped_text_get_dominant_direction_in_range")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3326907668)!
            }
            
        }
        
    }()
    
    /// Returns dominant direction of in the range of text.
    public final func shapedTextGetDominantDirectionInRange(shaped: RID, start: Int, end: Int) -> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: shaped.content) { pArg0 in
            withUnsafePointer(to: start) { pArg1 in
                withUnsafePointer(to: end) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_shaped_text_get_dominant_direction_in_range, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return TextServer.Direction (rawValue: _result)!
    }
    
    fileprivate static var method_format_number: GDExtensionMethodBindPtr = {
        let methodName = StringName("format_number")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Converts a number from the Western Arabic (0..9) to the numeral systems used in `language`.
    /// 
    /// If `language` is omitted, the active locale will be used.
    /// 
    public final func formatNumber(_ number: String, language: String = "") -> String {
        let _result = GString ()
        let number = GString(number)
        withUnsafePointer(to: number.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_format_number, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_parse_number: GDExtensionMethodBindPtr = {
        let methodName = StringName("parse_number")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Converts `number` from the numeral systems used in `language` to Western Arabic (0..9).
    public final func parseNumber(_ number: String, language: String = "") -> String {
        let _result = GString ()
        let number = GString(number)
        withUnsafePointer(to: number.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_parse_number, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_percent_sign: GDExtensionMethodBindPtr = {
        let methodName = StringName("percent_sign")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 993269549)!
            }
            
        }
        
    }()
    
    /// Returns percent sign used in the `language`.
    public final func percentSign(language: String = "") -> String {
        let _result = GString ()
        let language = GString(language)
        withUnsafePointer(to: language.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_percent_sign, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_string_get_word_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName("string_get_word_breaks")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 581857818)!
            }
            
        }
        
    }()
    
    /// Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
    /// 
    /// When `charsPerLine` is greater than zero, line break boundaries are returned instead.
    /// 
    public final func stringGetWordBreaks(string: String, language: String = "", charsPerLine: Int = 0) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: charsPerLine) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_string_get_word_breaks, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_string_get_character_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName("string_get_character_breaks")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2333794773)!
            }
            
        }
        
    }()
    
    /// Returns array of the composite character boundaries.
    /// 
    public final func stringGetCharacterBreaks(string: String, language: String = "") -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_string_get_character_breaks, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_confusable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_confusable")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1433197768)!
            }
            
        }
        
    }()
    
    /// Returns index of the first string in `dict` which is visually confusable with the `string`, or `-1` if none is found.
    /// 
    /// > Note: This method doesn't detect invisible characters, for spoof detection use it in combination with ``spoofCheck(string:)``.
    /// 
    /// > Note: Always returns `-1` if the server does not support the ``Feature/unicodeSecurity`` feature.
    /// 
    public final func isConfusable(string: String, dict: PackedStringArray) -> Int {
        var _result: Int = 0
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: dict.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_is_confusable, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_spoof_check: GDExtensionMethodBindPtr = {
        let methodName = StringName("spoof_check")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `string` is likely to be an attempt at confusing the reader.
    /// 
    /// > Note: Always returns `false` if the server does not support the ``Feature/unicodeSecurity`` feature.
    /// 
    public final func spoofCheck(string: String) -> Bool {
        var _result: Bool = false
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_spoof_check, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_strip_diacritics: GDExtensionMethodBindPtr = {
        let methodName = StringName("strip_diacritics")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3135753539)!
            }
            
        }
        
    }()
    
    /// Strips diacritics from the string.
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stripDiacritics(string: String) -> String {
        let _result = GString ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_strip_diacritics, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_is_valid_identifier: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_valid_identifier")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `string` is a valid identifier.
    /// 
    /// If the text server supports the ``Feature/unicodeIdentifiers`` feature, a valid identifier must:
    /// 
    /// - Conform to normalization form C.
    /// 
    /// - Begin with a Unicode character of class XID_Start or `"_"`.
    /// 
    /// - May contain Unicode characters of class XID_Continue in the other positions.
    /// 
    /// - Use UAX #31 recommended scripts only (mixed scripts are allowed).
    /// 
    /// If the ``Feature/unicodeIdentifiers`` feature is not supported, a valid identifier must:
    /// 
    /// - Begin with a Unicode character of class XID_Start or `"_"`.
    /// 
    /// - May contain Unicode characters of class XID_Continue in the other positions.
    /// 
    public final func isValidIdentifier(string: String) -> Bool {
        var _result: Bool = false
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_is_valid_identifier, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_valid_letter: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_valid_letter")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given code point is a valid letter, i.e. it belongs to the Unicode category "L".
    public final func isValidLetter(unicode: UInt) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: unicode) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TextServer.method_is_valid_letter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_string_to_upper: GDExtensionMethodBindPtr = {
        let methodName = StringName("string_to_upper")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Returns the string converted to uppercase.
    /// 
    /// > Note: Casing is locale dependent and context sensitive if server support ``Feature/contextSensitiveCaseConversion`` feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stringToUpper(string: String, language: String = "") -> String {
        let _result = GString ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_string_to_upper, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_string_to_lower: GDExtensionMethodBindPtr = {
        let methodName = StringName("string_to_lower")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Returns the string converted to lowercase.
    /// 
    /// > Note: Casing is locale dependent and context sensitive if server support ``Feature/contextSensitiveCaseConversion`` feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stringToLower(string: String, language: String = "") -> String {
        let _result = GString ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_string_to_lower, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_string_to_title: GDExtensionMethodBindPtr = {
        let methodName = StringName("string_to_title")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Returns the string converted to title case.
    /// 
    /// > Note: Casing is locale dependent and context sensitive if server support ``Feature/contextSensitiveCaseConversion`` feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stringToTitle(string: String, language: String = "") -> String {
        let _result = GString ()
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TextServer.method_string_to_title, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_parse_structured_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("parse_structured_text")
        return withUnsafePointer(to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3310685015)!
            }
            
        }
        
    }()
    
    /// Default implementation of the BiDi algorithm override function. See ``TextServer/StructuredTextParser`` for more info.
    public final func parseStructuredText(parserType: TextServer.StructuredTextParser, args: GArray, text: String) -> VariantCollection<Vector3i> {
        var _result: Int64 = 0
        withUnsafePointer(to: parserType.rawValue) { pArg0 in
            withUnsafePointer(to: args.content) { pArg1 in
                let text = GString(text)
                withUnsafePointer(to: text.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TextServer.method_parse_structured_text, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return VariantCollection<Vector3i>(content: _result)
    }
    
}

