// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Describes a Bézier curve in 3D space.
/// 
/// This class describes a Bézier curve in 3D space. It is mainly used to give a shape to a ``Path3D``, but can be manually sampled for other purposes.
/// 
/// It keeps a cache of precalculated points along the curve, to speed up further calculations.
/// 
open class Curve3D: Resource {
    override open class var godotClassName: StringName { "Curve3D" }
    
    /* Properties */
    
    /// The distance in meters between two adjacent cached points. Changing it forces the cache to be recomputed the next time the ``getBakedPoints()`` or ``getBakedLength()`` function is called. The smaller the distance, the more points in the cache and the more memory it will consume, so use with care.
    final public var bakeInterval: Double {
        get {
            return get_bake_interval ()
        }
        
        set {
            set_bake_interval (newValue)
        }
        
    }
    
    /// The number of points describing the curve.
    final public var pointCount: Int32 {
        get {
            return get_point_count ()
        }
        
        set {
            set_point_count (newValue)
        }
        
    }
    
    /// If `true`, the curve will bake up vectors used for orientation. This is used when ``PathFollow3D/rotationMode`` is set to ``PathFollow3D/RotationMode/oriented``. Changing it forces the cache to be recomputed.
    final public var upVectorEnabled: Bool {
        get {
            return is_up_vector_enabled ()
        }
        
        set {
            set_up_vector_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_point_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_point_count")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_point_count() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Curve3D.method_get_point_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_point_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_point_count")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_point_count(_ count: Int32) {
        withUnsafePointer(to: count) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_set_point_count, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_point: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_point")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2931053748)!
            }
            
        }
        
    }()
    
    /// Adds a point with the specified `position` relative to the curve's own position, with control points `in` and `out`. Appends the new point at the end of the point list.
    /// 
    /// If `index` is given, the new point is inserted before the existing point identified by index `index`. Every existing point starting from `index` is shifted further down the list of points. The index must be greater than or equal to `0` and must not exceed the number of existing points in the line. See ``pointCount``.
    /// 
    public final func addPoint(position: Vector3, `in`: Vector3 = Vector3 (x: 0, y: 0, z: 0), out: Vector3 = Vector3 (x: 0, y: 0, z: 0), index: Int32 = -1) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: `in`) { pArg1 in
                withUnsafePointer(to: out) { pArg2 in
                    withUnsafePointer(to: index) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Curve3D.method_add_point, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_point_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_point_position")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530502735)!
            }
            
        }
        
    }()
    
    /// Sets the position for the vertex `idx`. If the index is out of bounds, the function sends an error to the console.
    public final func setPointPosition(idx: Int32, position: Vector3) {
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_set_point_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_point_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_point_position")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 711720468)!
            }
            
        }
        
    }()
    
    /// Returns the position of the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0, 0)`.
    public final func getPointPosition(idx: Int32) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_point_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_point_tilt: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_point_tilt")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1602489585)!
            }
            
        }
        
    }()
    
    /// Sets the tilt angle in radians for the point `idx`. If the index is out of bounds, the function sends an error to the console.
    /// 
    /// The tilt controls the rotation along the look-at axis an object traveling the path would have. In the case of a curve controlling a ``PathFollow3D``, this tilt is an offset over the natural tilt the ``PathFollow3D`` calculates.
    /// 
    public final func setPointTilt(idx: Int32, tilt: Double) {
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: tilt) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_set_point_tilt, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_point_tilt: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_point_tilt")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2339986948)!
            }
            
        }
        
    }()
    
    /// Returns the tilt angle in radians for the point `idx`. If the index is out of bounds, the function sends an error to the console, and returns `0`.
    public final func getPointTilt(idx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_point_tilt, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_point_in: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_point_in")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530502735)!
            }
            
        }
        
    }()
    
    /// Sets the position of the control point leading to the vertex `idx`. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
    public final func setPointIn(idx: Int32, position: Vector3) {
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_set_point_in, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_point_in: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_point_in")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 711720468)!
            }
            
        }
        
    }()
    
    /// Returns the position of the control point leading to the vertex `idx`. The returned position is relative to the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0, 0)`.
    public final func getPointIn(idx: Int32) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_point_in, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_point_out: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_point_out")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530502735)!
            }
            
        }
        
    }()
    
    /// Sets the position of the control point leading out of the vertex `idx`. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
    public final func setPointOut(idx: Int32, position: Vector3) {
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_set_point_out, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_point_out: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_point_out")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 711720468)!
            }
            
        }
        
    }()
    
    /// Returns the position of the control point leading out of the vertex `idx`. The returned position is relative to the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0, 0)`.
    public final func getPointOut(idx: Int32) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_point_out, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_point: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_point")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Deletes the point `idx` from the curve. Sends an error to the console if `idx` is out of bounds.
    public final func removePoint(idx: Int32) {
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_remove_point, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_points: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_points")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all points from the curve.
    public final func clearPoints() {
        gi.object_method_bind_ptrcall(Curve3D.method_clear_points, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_sample: GDExtensionMethodBindPtr = {
        let methodName = StringName("sample")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3285246857)!
            }
            
        }
        
    }()
    
    /// Returns the position between the vertex `idx` and the vertex `idx + 1`, where `t` controls if the point is the first vertex (`t = 0.0`), the last vertex (`t = 1.0`), or in between. Values of `t` outside the range (`0.0 >= t <=1`) give strange, but predictable results.
    /// 
    /// If `idx` is out of bounds it is truncated to the first or last vertex, and `t` is ignored. If the curve has no points, the function sends an error to the console, and returns `(0, 0, 0)`.
    /// 
    public final func sample(idx: Int32, t: Double) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: t) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_sample, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_samplef: GDExtensionMethodBindPtr = {
        let methodName = StringName("samplef")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2553580215)!
            }
            
        }
        
    }()
    
    /// Returns the position at the vertex `fofs`. It calls ``sample(idx:t:)`` using the integer part of `fofs` as `idx`, and its fractional part as `t`.
    public final func samplef(fofs: Double) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: fofs) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_samplef, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bake_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bake_interval")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bake_interval(_ distance: Double) {
        withUnsafePointer(to: distance) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_set_bake_interval, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bake_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bake_interval")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bake_interval() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Curve3D.method_get_bake_interval, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_up_vector_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_up_vector_enabled")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_up_vector_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_set_up_vector_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_up_vector_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_up_vector_enabled")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_up_vector_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Curve3D.method_is_up_vector_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_baked_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_baked_length")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the total length of the curve, based on the cached points. Given enough density (see ``bakeInterval``), it should be approximate enough.
    public final func getBakedLength() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Curve3D.method_get_baked_length, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_sample_baked: GDExtensionMethodBindPtr = {
        let methodName = StringName("sample_baked")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1350085894)!
            }
            
        }
        
    }()
    
    /// Returns a point within the curve at position `offset`, where `offset` is measured as a distance in 3D units along the curve. To do that, it finds the two cached points where the `offset` lies between, then interpolates the values. This interpolation is cubic if `cubic` is set to `true`, or linear if set to `false`.
    /// 
    /// Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
    /// 
    public final func sampleBaked(offset: Double = 0.0, cubic: Bool = false) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: cubic) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_sample_baked, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_sample_baked_with_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("sample_baked_with_rotation")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1939359131)!
            }
            
        }
        
    }()
    
    /// Returns a ``Transform3D`` with `origin` as point position, `basis.x` as sideway vector, `basis.y` as up vector, `basis.z` as forward vector. When the curve length is 0, there is no reasonable way to calculate the rotation, all vectors aligned with global space axes. See also ``sampleBaked(offset:cubic:)``.
    public final func sampleBakedWithRotation(offset: Double = 0.0, cubic: Bool = false, applyTilt: Bool = false) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: cubic) { pArg1 in
                withUnsafePointer(to: applyTilt) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Curve3D.method_sample_baked_with_rotation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_sample_baked_up_vector: GDExtensionMethodBindPtr = {
        let methodName = StringName("sample_baked_up_vector")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1362627031)!
            }
            
        }
        
    }()
    
    /// Returns an up vector within the curve at position `offset`, where `offset` is measured as a distance in 3D units along the curve. To do that, it finds the two cached up vectors where the `offset` lies between, then interpolates the values. If `applyTilt` is `true`, an interpolated tilt is applied to the interpolated up vector.
    /// 
    /// If the curve has no up vectors, the function sends an error to the console, and returns `(0, 1, 0)`.
    /// 
    public final func sampleBakedUpVector(offset: Double, applyTilt: Bool = false) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: applyTilt) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_sample_baked_up_vector, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_baked_points: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_baked_points")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 497664490)!
            }
            
        }
        
    }()
    
    /// Returns the cache of points as a ``PackedVector3Array``.
    public final func getBakedPoints() -> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        gi.object_method_bind_ptrcall(Curve3D.method_get_baked_points, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_baked_tilts: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_baked_tilts")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 675695659)!
            }
            
        }
        
    }()
    
    /// Returns the cache of tilts as a ``PackedFloat32Array``.
    public final func getBakedTilts() -> PackedFloat32Array {
        let _result: PackedFloat32Array = PackedFloat32Array ()
        gi.object_method_bind_ptrcall(Curve3D.method_get_baked_tilts, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_baked_up_vectors: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_baked_up_vectors")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 497664490)!
            }
            
        }
        
    }()
    
    /// Returns the cache of up vectors as a ``PackedVector3Array``.
    /// 
    /// If ``upVectorEnabled`` is `false`, the cache will be empty.
    /// 
    public final func getBakedUpVectors() -> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        gi.object_method_bind_ptrcall(Curve3D.method_get_baked_up_vectors, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_closest_point: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_closest_point")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 192990374)!
            }
            
        }
        
    }()
    
    /// Returns the closest point on baked segments (in curve's local space) to `toPoint`.
    /// 
    /// `toPoint` must be in this curve's local space.
    /// 
    public final func getClosestPoint(toPoint: Vector3) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: toPoint) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_closest_point, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_closest_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_closest_offset")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1109078154)!
            }
            
        }
        
    }()
    
    /// Returns the closest offset to `toPoint`. This offset is meant to be used in ``sampleBaked(offset:cubic:)`` or ``sampleBakedUpVector(offset:applyTilt:)``.
    /// 
    /// `toPoint` must be in this curve's local space.
    /// 
    public final func getClosestOffset(toPoint: Vector3) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: toPoint) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Curve3D.method_get_closest_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_tessellate: GDExtensionMethodBindPtr = {
        let methodName = StringName("tessellate")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1519759391)!
            }
            
        }
        
    }()
    
    /// Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
    /// 
    /// This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
    /// 
    /// `maxStages` controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
    /// 
    /// `toleranceDegrees` controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
    /// 
    public final func tessellate(maxStages: Int32 = 5, toleranceDegrees: Double = 4) -> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        withUnsafePointer(to: maxStages) { pArg0 in
            withUnsafePointer(to: toleranceDegrees) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_tessellate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_tessellate_even_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("tessellate_even_length")
        return withUnsafePointer(to: &Curve3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 133237049)!
            }
            
        }
        
    }()
    
    /// Returns a list of points along the curve, with almost uniform density. `maxStages` controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
    /// 
    /// `toleranceLength` controls the maximal distance between two neighboring points, before the segment has to be subdivided.
    /// 
    public final func tessellateEvenLength(maxStages: Int32 = 5, toleranceLength: Double = 0.2) -> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        withUnsafePointer(to: maxStages) { pArg0 in
            withUnsafePointer(to: toleranceLength) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Curve3D.method_tessellate_even_length, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

