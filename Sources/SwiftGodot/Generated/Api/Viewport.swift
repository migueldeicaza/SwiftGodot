// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstract base class for viewports. Encapsulates drawing and interaction with a game world.
/// 
/// A ``Viewport`` creates a different view into the screen, or a sub-view inside another viewport. Child 2D nodes will display on it, and child Camera3D 3D nodes will render on it too.
/// 
/// Optionally, a viewport can have its own 2D or 3D world, so it doesn't share what it draws with other viewports.
/// 
/// Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it.
/// 
/// Also, viewports can be assigned to different screens in case the devices have multiple screens.
/// 
/// Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``sizeChanged``
/// - ``guiFocusChanged``
open class Viewport: Node {
    override open class var godotClassName: StringName { "Viewport" }
    public enum PositionalShadowAtlasQuadrantSubdiv: Int64, CaseIterable, CustomDebugStringConvertible {
        /// This quadrant will not be used.
        case disabled = 0 // SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED
        /// This quadrant will only be used by one shadow map.
        case shadowAtlasQuadrantSubdiv1 = 1 // SHADOW_ATLAS_QUADRANT_SUBDIV_1
        /// This quadrant will be split in 4 and used by up to 4 shadow maps.
        case shadowAtlasQuadrantSubdiv4 = 2 // SHADOW_ATLAS_QUADRANT_SUBDIV_4
        /// This quadrant will be split 16 ways and used by up to 16 shadow maps.
        case shadowAtlasQuadrantSubdiv16 = 3 // SHADOW_ATLAS_QUADRANT_SUBDIV_16
        /// This quadrant will be split 64 ways and used by up to 64 shadow maps.
        case shadowAtlasQuadrantSubdiv64 = 4 // SHADOW_ATLAS_QUADRANT_SUBDIV_64
        /// This quadrant will be split 256 ways and used by up to 256 shadow maps. Unless the ``positionalShadowAtlasSize`` is very high, the shadows in this quadrant will be very low resolution.
        case shadowAtlasQuadrantSubdiv256 = 5 // SHADOW_ATLAS_QUADRANT_SUBDIV_256
        /// This quadrant will be split 1024 ways and used by up to 1024 shadow maps. Unless the ``positionalShadowAtlasSize`` is very high, the shadows in this quadrant will be very low resolution.
        case shadowAtlasQuadrantSubdiv1024 = 6 // SHADOW_ATLAS_QUADRANT_SUBDIV_1024
        /// Represents the size of the ``Viewport/PositionalShadowAtlasQuadrantSubdiv`` enum.
        case max = 7 // SHADOW_ATLAS_QUADRANT_SUBDIV_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .shadowAtlasQuadrantSubdiv1: return ".shadowAtlasQuadrantSubdiv1"
                case .shadowAtlasQuadrantSubdiv4: return ".shadowAtlasQuadrantSubdiv4"
                case .shadowAtlasQuadrantSubdiv16: return ".shadowAtlasQuadrantSubdiv16"
                case .shadowAtlasQuadrantSubdiv64: return ".shadowAtlasQuadrantSubdiv64"
                case .shadowAtlasQuadrantSubdiv256: return ".shadowAtlasQuadrantSubdiv256"
                case .shadowAtlasQuadrantSubdiv1024: return ".shadowAtlasQuadrantSubdiv1024"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum Scaling3DMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Use bilinear scaling for the viewport's 3D buffer. The amount of scaling can be set using ``scaling3dScale``. Values less than `1.0` will result in undersampling while values greater than `1.0` will result in supersampling. A value of `1.0` disables scaling.
        case bilinear = 0 // SCALING_3D_MODE_BILINEAR
        /// Use AMD FidelityFX Super Resolution 1.0 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` disables scaling.
        case fsr = 1 // SCALING_3D_MODE_FSR
        /// Use AMD FidelityFX Super Resolution 2.2 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``Viewport/scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR2. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` will use FSR2 at native resolution as a TAA solution.
        case fsr2 = 2 // SCALING_3D_MODE_FSR2
        /// Represents the size of the ``Viewport/Scaling3DMode`` enum.
        case max = 3 // SCALING_3D_MODE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .bilinear: return ".bilinear"
                case .fsr: return ".fsr"
                case .fsr2: return ".fsr2"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum MSAA: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Multisample antialiasing mode disabled. This is the default value, and is also the fastest setting.
        case disabled = 0 // MSAA_DISABLED
        /// Use 2× Multisample Antialiasing. This has a moderate performance cost. It helps reduce aliasing noticeably, but 4× MSAA still looks substantially better.
        case msaa2x = 1 // MSAA_2X
        /// Use 4× Multisample Antialiasing. This has a significant performance cost, and is generally a good compromise between performance and quality.
        case msaa4x = 2 // MSAA_4X
        /// Use 8× Multisample Antialiasing. This has a very high performance cost. The difference between 4× and 8× MSAA may not always be visible in real gameplay conditions. Likely unsupported on low-end and older hardware.
        case msaa8x = 3 // MSAA_8X
        /// Represents the size of the ``Viewport/MSAA`` enum.
        case max = 4 // MSAA_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .msaa2x: return ".msaa2x"
                case .msaa4x: return ".msaa4x"
                case .msaa8x: return ".msaa8x"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum ScreenSpaceAA: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Do not perform any antialiasing in the full screen post-process.
        case disabled = 0 // SCREEN_SPACE_AA_DISABLED
        /// Use fast approximate antialiasing. FXAA is a popular screen-space antialiasing method, which is fast but will make the image look blurry, especially at lower resolutions. It can still work relatively well at large resolutions such as 1440p and 4K.
        case fxaa = 1 // SCREEN_SPACE_AA_FXAA
        /// Represents the size of the ``Viewport/ScreenSpaceAA`` enum.
        case max = 2 // SCREEN_SPACE_AA_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .fxaa: return ".fxaa"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum RenderInfo: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Amount of objects in frame.
        case objectsInFrame = 0 // RENDER_INFO_OBJECTS_IN_FRAME
        /// Amount of vertices in frame.
        case primitivesInFrame = 1 // RENDER_INFO_PRIMITIVES_IN_FRAME
        /// Amount of draw calls in frame.
        case drawCallsInFrame = 2 // RENDER_INFO_DRAW_CALLS_IN_FRAME
        /// Represents the size of the ``Viewport/RenderInfo`` enum.
        case max = 3 // RENDER_INFO_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .objectsInFrame: return ".objectsInFrame"
                case .primitivesInFrame: return ".primitivesInFrame"
                case .drawCallsInFrame: return ".drawCallsInFrame"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum RenderInfoType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Visible render pass (excluding shadows).
        case visible = 0 // RENDER_INFO_TYPE_VISIBLE
        /// Shadow render pass. Objects will be rendered several times depending on the number of amounts of lights with shadows and the number of directional shadow splits.
        case shadow = 1 // RENDER_INFO_TYPE_SHADOW
        /// Canvas item rendering. This includes all 2D rendering.
        case canvas = 2 // RENDER_INFO_TYPE_CANVAS
        /// Represents the size of the ``Viewport/RenderInfoType`` enum.
        case max = 3 // RENDER_INFO_TYPE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .visible: return ".visible"
                case .shadow: return ".shadow"
                case .canvas: return ".canvas"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum DebugDraw: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Objects are displayed normally.
        case disabled = 0 // DEBUG_DRAW_DISABLED
        /// Objects are displayed without light information.
        case unshaded = 1 // DEBUG_DRAW_UNSHADED
        /// Objects are displayed without textures and only with lighting information.
        case lighting = 2 // DEBUG_DRAW_LIGHTING
        /// Objects are displayed semi-transparent with additive blending so you can see where they are drawing over top of one another. A higher overdraw means you are wasting performance on drawing pixels that are being hidden behind others.
        case overdraw = 3 // DEBUG_DRAW_OVERDRAW
        /// Objects are displayed as wireframe models.
        case wireframe = 4 // DEBUG_DRAW_WIREFRAME
        /// Objects are displayed without lighting information and their textures replaced by normal mapping.
        case normalBuffer = 5 // DEBUG_DRAW_NORMAL_BUFFER
        /// Objects are displayed with only the albedo value from ``VoxelGI``s.
        case voxelGiAlbedo = 6 // DEBUG_DRAW_VOXEL_GI_ALBEDO
        /// Objects are displayed with only the lighting value from ``VoxelGI``s.
        case voxelGiLighting = 7 // DEBUG_DRAW_VOXEL_GI_LIGHTING
        /// Objects are displayed with only the emission color from ``VoxelGI``s.
        case voxelGiEmission = 8 // DEBUG_DRAW_VOXEL_GI_EMISSION
        /// Draws the shadow atlas that stores shadows from ``OmniLight3D``s and ``SpotLight3D``s in the upper left quadrant of the ``Viewport``.
        case shadowAtlas = 9 // DEBUG_DRAW_SHADOW_ATLAS
        /// Draws the shadow atlas that stores shadows from ``DirectionalLight3D``s in the upper left quadrant of the ``Viewport``.
        case directionalShadowAtlas = 10 // DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS
        /// Draws the scene luminance buffer (if available) in the upper left quadrant of the ``Viewport``.
        case sceneLuminance = 11 // DEBUG_DRAW_SCENE_LUMINANCE
        /// Draws the screen-space ambient occlusion texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssaoEnabled`` set in your ``WorldEnvironment``.
        case ssao = 12 // DEBUG_DRAW_SSAO
        /// Draws the screen-space indirect lighting texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssilEnabled`` set in your ``WorldEnvironment``.
        case ssil = 13 // DEBUG_DRAW_SSIL
        /// Colors each PSSM split for the ``DirectionalLight3D``s in the scene a different color so you can see where the splits are. In order, they will be colored red, green, blue, and yellow.
        case pssmSplits = 14 // DEBUG_DRAW_PSSM_SPLITS
        /// Draws the decal atlas used by ``Decal``s and light projector textures in the upper left quadrant of the ``Viewport``.
        case decalAtlas = 15 // DEBUG_DRAW_DECAL_ATLAS
        /// Draws the cascades used to render signed distance field global illumination (SDFGI).
        /// 
        /// Does nothing if the current environment's ``Environment/sdfgiEnabled`` is `false` or SDFGI is not supported on the platform.
        /// 
        case sdfgi = 16 // DEBUG_DRAW_SDFGI
        /// Draws the probes used for signed distance field global illumination (SDFGI).
        /// 
        /// Does nothing if the current environment's ``Environment/sdfgiEnabled`` is `false` or SDFGI is not supported on the platform.
        /// 
        case sdfgiProbes = 17 // DEBUG_DRAW_SDFGI_PROBES
        /// Draws the buffer used for global illumination (GI).
        case giBuffer = 18 // DEBUG_DRAW_GI_BUFFER
        /// Draws all of the objects at their highest polycount, without low level of detail (LOD).
        case disableLod = 19 // DEBUG_DRAW_DISABLE_LOD
        /// Draws the cluster used by ``OmniLight3D`` nodes to optimize light rendering.
        case clusterOmniLights = 20 // DEBUG_DRAW_CLUSTER_OMNI_LIGHTS
        /// Draws the cluster used by ``SpotLight3D`` nodes to optimize light rendering.
        case clusterSpotLights = 21 // DEBUG_DRAW_CLUSTER_SPOT_LIGHTS
        /// Draws the cluster used by ``Decal`` nodes to optimize decal rendering.
        case clusterDecals = 22 // DEBUG_DRAW_CLUSTER_DECALS
        /// Draws the cluster used by ``ReflectionProbe`` nodes to optimize decal rendering.
        case clusterReflectionProbes = 23 // DEBUG_DRAW_CLUSTER_REFLECTION_PROBES
        /// Draws the buffer used for occlusion culling.
        case occluders = 24 // DEBUG_DRAW_OCCLUDERS
        /// Draws vector lines over the viewport to indicate the movement of pixels between frames.
        case motionVectors = 25 // DEBUG_DRAW_MOTION_VECTORS
        /// Draws the internal resolution buffer of the scene before post-processing is applied.
        case internalBuffer = 26 // DEBUG_DRAW_INTERNAL_BUFFER
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .unshaded: return ".unshaded"
                case .lighting: return ".lighting"
                case .overdraw: return ".overdraw"
                case .wireframe: return ".wireframe"
                case .normalBuffer: return ".normalBuffer"
                case .voxelGiAlbedo: return ".voxelGiAlbedo"
                case .voxelGiLighting: return ".voxelGiLighting"
                case .voxelGiEmission: return ".voxelGiEmission"
                case .shadowAtlas: return ".shadowAtlas"
                case .directionalShadowAtlas: return ".directionalShadowAtlas"
                case .sceneLuminance: return ".sceneLuminance"
                case .ssao: return ".ssao"
                case .ssil: return ".ssil"
                case .pssmSplits: return ".pssmSplits"
                case .decalAtlas: return ".decalAtlas"
                case .sdfgi: return ".sdfgi"
                case .sdfgiProbes: return ".sdfgiProbes"
                case .giBuffer: return ".giBuffer"
                case .disableLod: return ".disableLod"
                case .clusterOmniLights: return ".clusterOmniLights"
                case .clusterSpotLights: return ".clusterSpotLights"
                case .clusterDecals: return ".clusterDecals"
                case .clusterReflectionProbes: return ".clusterReflectionProbes"
                case .occluders: return ".occluders"
                case .motionVectors: return ".motionVectors"
                case .internalBuffer: return ".internalBuffer"
            }
            
        }
        
    }
    
    public enum DefaultCanvasItemTextureFilter: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The texture filter reads from the nearest pixel only. This makes the texture look pixelated from up close, and grainy from a distance (due to mipmaps not being sampled).
        case nearest = 0 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST
        /// The texture filter blends between the nearest 4 pixels. This makes the texture look smooth from up close, and grainy from a distance (due to mipmaps not being sampled).
        case linear = 1 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR
        /// The texture filter blends between the nearest 4 pixels and between the nearest 2 mipmaps (or uses the nearest mipmap if ``ProjectSettings/rendering/textures/defaultFilters/useNearestMipmapFilter`` is `true`). This makes the texture look smooth from up close, and smooth from a distance.
        /// 
        /// Use this for non-pixel art textures that may be viewed at a low scale (e.g. due to ``Camera2D`` zoom or sprite scaling), as mipmaps are important to smooth out pixels that are smaller than on-screen pixels.
        /// 
        case linearWithMipmaps = 2 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS
        /// The texture filter reads from the nearest pixel and blends between the nearest 2 mipmaps (or uses the nearest mipmap if ``ProjectSettings/rendering/textures/defaultFilters/useNearestMipmapFilter`` is `true`). This makes the texture look pixelated from up close, and smooth from a distance.
        /// 
        /// Use this for non-pixel art textures that may be viewed at a low scale (e.g. due to ``Camera2D`` zoom or sprite scaling), as mipmaps are important to smooth out pixels that are smaller than on-screen pixels.
        /// 
        case nearestWithMipmaps = 3 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS
        /// Represents the size of the ``Viewport/DefaultCanvasItemTextureFilter`` enum.
        case max = 4 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .nearest: return ".nearest"
                case .linear: return ".linear"
                case .linearWithMipmaps: return ".linearWithMipmaps"
                case .nearestWithMipmaps: return ".nearestWithMipmaps"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum DefaultCanvasItemTextureRepeat: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Disables textures repeating. Instead, when reading UVs outside the 0-1 range, the value will be clamped to the edge of the texture, resulting in a stretched out look at the borders of the texture.
        case disabled = 0 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_DISABLED
        /// Enables the texture to repeat when UV coordinates are outside the 0-1 range. If using one of the linear filtering modes, this can result in artifacts at the edges of a texture when the sampler filters across the edges of the texture.
        case enabled = 1 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_ENABLED
        /// Flip the texture when repeating so that the edge lines up instead of abruptly changing.
        case mirror = 2 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR
        /// Represents the size of the ``Viewport/DefaultCanvasItemTextureRepeat`` enum.
        case max = 3 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .enabled: return ".enabled"
                case .mirror: return ".mirror"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum SDFOversize: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The signed distance field only covers the viewport's own rectangle.
        case sdfOversize100Percent = 0 // SDF_OVERSIZE_100_PERCENT
        /// The signed distance field is expanded to cover 20% of the viewport's size around the borders.
        case sdfOversize120Percent = 1 // SDF_OVERSIZE_120_PERCENT
        /// The signed distance field is expanded to cover 50% of the viewport's size around the borders.
        case sdfOversize150Percent = 2 // SDF_OVERSIZE_150_PERCENT
        /// The signed distance field is expanded to cover 100% (double) of the viewport's size around the borders.
        case sdfOversize200Percent = 3 // SDF_OVERSIZE_200_PERCENT
        /// Represents the size of the ``Viewport/SDFOversize`` enum.
        case max = 4 // SDF_OVERSIZE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .sdfOversize100Percent: return ".sdfOversize100Percent"
                case .sdfOversize120Percent: return ".sdfOversize120Percent"
                case .sdfOversize150Percent: return ".sdfOversize150Percent"
                case .sdfOversize200Percent: return ".sdfOversize200Percent"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum SDFScale: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The signed distance field is rendered at full resolution.
        case sdfScale100Percent = 0 // SDF_SCALE_100_PERCENT
        /// The signed distance field is rendered at half the resolution of this viewport.
        case sdfScale50Percent = 1 // SDF_SCALE_50_PERCENT
        /// The signed distance field is rendered at a quarter the resolution of this viewport.
        case sdfScale25Percent = 2 // SDF_SCALE_25_PERCENT
        /// Represents the size of the ``Viewport/SDFScale`` enum.
        case max = 3 // SDF_SCALE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .sdfScale100Percent: return ".sdfScale100Percent"
                case .sdfScale50Percent: return ".sdfScale50Percent"
                case .sdfScale25Percent: return ".sdfScale25Percent"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum VRSMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Variable Rate Shading is disabled.
        case disabled = 0 // VRS_DISABLED
        /// Variable Rate Shading uses a texture. Note, for stereoscopic use a texture atlas with a texture for each view.
        case texture = 1 // VRS_TEXTURE
        /// Variable Rate Shading's texture is supplied by the primary ``XRInterface``.
        case xr = 2 // VRS_XR
        /// Represents the size of the ``Viewport/VRSMode`` enum.
        case max = 3 // VRS_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .texture: return ".texture"
                case .xr: return ".xr"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum VRSUpdateMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The input texture for variable rate shading will not be processed.
        case disabled = 0 // VRS_UPDATE_DISABLED
        /// The input texture for variable rate shading will be processed once.
        case once = 1 // VRS_UPDATE_ONCE
        /// The input texture for variable rate shading will be processed each frame.
        case always = 2 // VRS_UPDATE_ALWAYS
        /// Represents the size of the ``Viewport/VRSUpdateMode`` enum.
        case max = 3 // VRS_UPDATE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .once: return ".once"
                case .always: return ".always"
                case .max: return ".max"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// Disable 3D rendering (but keep 2D rendering).
    final public var disable3d: Bool {
        get {
            return is_3d_disabled ()
        }
        
        set {
            set_disable_3d (newValue)
        }
        
    }
    
    /// If `true`, the viewport will use the primary XR interface to render XR output. When applicable this can result in a stereoscopic image and the resulting render being output to a headset.
    final public var useXr: Bool {
        get {
            return is_using_xr ()
        }
        
        set {
            set_use_xr (newValue)
        }
        
    }
    
    /// If `true`, the viewport will use a unique copy of the ``World3D`` defined in ``world3d``.
    final public var ownWorld3d: Bool {
        get {
            return is_using_own_world_3d ()
        }
        
        set {
            set_use_own_world_3d (newValue)
        }
        
    }
    
    /// The custom ``World3D`` which can be used as 3D environment source.
    final public var world3d: World3D? {
        get {
            return get_world_3d ()
        }
        
        set {
            set_world_3d (newValue)
        }
        
    }
    
    /// The custom ``World2D`` which can be used as 2D environment source.
    final public var world2d: World2D? {
        get {
            return get_world_2d ()
        }
        
        set {
            set_world_2d (newValue)
        }
        
    }
    
    /// If `true`, the viewport should render its background as transparent.
    final public var transparentBg: Bool {
        get {
            return has_transparent_background ()
        }
        
        set {
            set_transparent_background (newValue)
        }
        
    }
    
    /// If `true`, this viewport will mark incoming input events as handled by itself. If `false`, this is instead done by the first parent viewport that is set to handle input locally.
    /// 
    /// A ``SubViewportContainer`` will automatically set this property to `false` for the ``Viewport`` contained inside of it.
    /// 
    /// See also ``setInputAsHandled()`` and ``isInputHandled()``.
    /// 
    final public var handleInputLocally: Bool {
        get {
            return is_handling_input_locally ()
        }
        
        set {
            set_handle_input_locally (newValue)
        }
        
    }
    
    /// If `true`, ``CanvasItem`` nodes will internally snap to full pixels. Their position can still be sub-pixel, but the decimals will not have effect. This can lead to a crisper appearance at the cost of less smooth movement, especially when ``Camera2D`` smoothing is enabled.
    final public var snap2dTransformsToPixel: Bool {
        get {
            return is_snap_2d_transforms_to_pixel_enabled ()
        }
        
        set {
            set_snap_2d_transforms_to_pixel (newValue)
        }
        
    }
    
    /// If `true`, vertices of ``CanvasItem`` nodes will snap to full pixels. Only affects the final vertex positions, not the transforms. This can lead to a crisper appearance at the cost of less smooth movement, especially when ``Camera2D`` smoothing is enabled.
    final public var snap2dVerticesToPixel: Bool {
        get {
            return is_snap_2d_vertices_to_pixel_enabled ()
        }
        
        set {
            set_snap_2d_vertices_to_pixel (newValue)
        }
        
    }
    
    /// The multisample anti-aliasing mode for 2D/Canvas rendering. A higher number results in smoother edges at the cost of significantly worse performance. A value of 2 or 4 is best unless targeting very high-end systems. This has no effect on shader-induced aliasing or texture aliasing.
    final public var msaa2d: Viewport.MSAA {
        get {
            return get_msaa_2d ()
        }
        
        set {
            set_msaa_2d (newValue)
        }
        
    }
    
    /// The multisample anti-aliasing mode for 3D rendering. A higher number results in smoother edges at the cost of significantly worse performance. A value of 2 or 4 is best unless targeting very high-end systems. See also bilinear scaling 3d ``scaling3dMode`` for supersampling, which provides higher quality but is much more expensive. This has no effect on shader-induced aliasing or texture aliasing.
    final public var msaa3d: Viewport.MSAA {
        get {
            return get_msaa_3d ()
        }
        
        set {
            set_msaa_3d (newValue)
        }
        
    }
    
    /// Sets the screen-space antialiasing method used. Screen-space antialiasing works by selectively blurring edges in a post-process shader. It differs from MSAA which takes multiple coverage samples while rendering objects. Screen-space AA methods are typically faster than MSAA and will smooth out specular aliasing, but tend to make scenes appear blurry.
    final public var screenSpaceAa: Viewport.ScreenSpaceAA {
        get {
            return get_screen_space_aa ()
        }
        
        set {
            set_screen_space_aa (newValue)
        }
        
    }
    
    /// Enables Temporal Anti-Aliasing for this viewport. TAA works by jittering the camera and accumulating the images of the last rendered frames, motion vector rendering is used to account for camera and object motion.
    /// 
    /// > Note: The implementation is not complete yet, some visual instances such as particles and skinned meshes may show artifacts.
    /// 
    final public var useTaa: Bool {
        get {
            return is_using_taa ()
        }
        
        set {
            set_use_taa (newValue)
        }
        
    }
    
    /// If `true`, uses a fast post-processing filter to make banding significantly less visible in 3D. 2D rendering is _not_ affected by debanding unless the ``Environment/backgroundMode`` is ``Environment/BGMode/canvas``. See also ``ProjectSettings/rendering/antiAliasing/quality/useDebanding``.
    /// 
    /// In some cases, debanding may introduce a slightly noticeable dithering pattern. It's recommended to enable debanding only when actually needed since the dithering pattern will make lossless-compressed screenshots larger.
    /// 
    final public var useDebanding: Bool {
        get {
            return is_using_debanding ()
        }
        
        set {
            set_use_debanding (newValue)
        }
        
    }
    
    /// If `true`, ``OccluderInstance3D`` nodes will be usable for occlusion culling in 3D for this viewport. For the root viewport, ``ProjectSettings/rendering/occlusionCulling/useOcclusionCulling`` must be set to `true` instead.
    /// 
    /// > Note: Enabling occlusion culling has a cost on the CPU. Only enable occlusion culling if you actually plan to use it, and think whether your scene can actually benefit from occlusion culling. Large, open scenes with few or no objects blocking the view will generally not benefit much from occlusion culling. Large open scenes generally benefit more from mesh LOD and visibility ranges (``GeometryInstance3D/visibilityRangeBegin`` and ``GeometryInstance3D/visibilityRangeEnd``) compared to occlusion culling.
    /// 
    /// > Note: Due to memory constraints, occlusion culling is not supported by default in Web export templates. It can be enabled by compiling custom Web export templates with `module_raycast_enabled=yes`.
    /// 
    final public var useOcclusionCulling: Bool {
        get {
            return is_using_occlusion_culling ()
        }
        
        set {
            set_use_occlusion_culling (newValue)
        }
        
    }
    
    /// The automatic LOD bias to use for meshes rendered within the ``Viewport`` (this is analogous to ``ReflectionProbe/meshLodThreshold``). Higher values will use less detailed versions of meshes that have LOD variations generated. If set to `0.0`, automatic LOD is disabled. Increase ``meshLodThreshold`` to improve performance at the cost of geometry detail.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/meshLod/lodChange/thresholdPixels`` project setting.
    /// 
    /// > Note: ``meshLodThreshold`` does not affect ``GeometryInstance3D`` visibility ranges (also known as "manual" LOD or hierarchical LOD).
    /// 
    final public var meshLodThreshold: Double {
        get {
            return get_mesh_lod_threshold ()
        }
        
        set {
            set_mesh_lod_threshold (newValue)
        }
        
    }
    
    /// The overlay mode for test rendered geometry in debug purposes.
    final public var debugDraw: Viewport.DebugDraw {
        get {
            return get_debug_draw ()
        }
        
        set {
            set_debug_draw (newValue)
        }
        
    }
    
    /// If `true`, 2D rendering will use an high dynamic range (HDR) format framebuffer matching the bit depth of the 3D framebuffer. When using the Forward+ renderer this will be an `RGBA16` framebuffer, while when using the Mobile renderer it will be an `RGB10_A2` framebuffer. Additionally, 2D rendering will take place in linear color space and will be converted to sRGB space immediately before blitting to the screen (if the Viewport is attached to the screen). Practically speaking, this means that the end result of the Viewport will not be clamped into the `0-1` range and can be used in 3D rendering without color space adjustments. This allows 2D rendering to take advantage of effects requiring high dynamic range (e.g. 2D glow) as well as substantially improves the appearance of effects requiring highly detailed gradients.
    /// 
    /// > Note: This setting will have no effect when using the GL Compatibility renderer as the GL Compatibility renderer always renders in low dynamic range for performance reasons.
    /// 
    final public var useHdr2d: Bool {
        get {
            return is_using_hdr_2d ()
        }
        
        set {
            set_use_hdr_2d (newValue)
        }
        
    }
    
    /// Sets scaling 3d mode. Bilinear scaling renders at different resolution to either undersample or supersample the viewport. FidelityFX Super Resolution 1.0, abbreviated to FSR, is an upscaling technology that produces high quality images at fast framerates by using a spatially aware upscaling algorithm. FSR is slightly more expensive than bilinear, but it produces significantly higher image quality. FSR should be used where possible.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/mode`` project setting.
    /// 
    final public var scaling3dMode: Viewport.Scaling3DMode {
        get {
            return get_scaling_3d_mode ()
        }
        
        set {
            set_scaling_3d_mode (newValue)
        }
        
    }
    
    /// Scales the 3D render buffer based on the viewport size uses an image filter specified in ``ProjectSettings/rendering/scaling3d/mode`` to scale the output image to the full viewport size. Values lower than `1.0` can be used to speed up 3D rendering at the cost of quality (undersampling). Values greater than `1.0` are only valid for bilinear mode and can be used to improve 3D rendering quality at a high performance cost (supersampling). See also ``ProjectSettings/rendering/antiAliasing/quality/msaa3d`` for multi-sample antialiasing, which is significantly cheaper but only smooths the edges of polygons.
    /// 
    /// When using FSR upscaling, AMD recommends exposing the following values as preset options to users "Ultra Quality: 0.77", "Quality: 0.67", "Balanced: 0.59", "Performance: 0.5" instead of exposing the entire scale.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/scale`` project setting.
    /// 
    final public var scaling3dScale: Double {
        get {
            return get_scaling_3d_scale ()
        }
        
        set {
            set_scaling_3d_scale (newValue)
        }
        
    }
    
    /// Affects the final texture sharpness by reading from a lower or higher mipmap (also called "texture LOD bias"). Negative values make mipmapped textures sharper but grainier when viewed at a distance, while positive values make mipmapped textures blurrier (even when up close).
    /// 
    /// Enabling temporal antialiasing (``useTaa``) will automatically apply a `-0.5` offset to this value, while enabling FXAA (``screenSpaceAa``) will automatically apply a `-0.25` offset to this value. If both TAA and FXAA are enabled at the same time, an offset of `-0.75` is applied to this value.
    /// 
    /// > Note: If ``scaling3dScale`` is lower than `1.0` (exclusive), ``textureMipmapBias`` is used to adjust the automatic mipmap bias which is calculated internally based on the scale factor. The formula for this is `log2(scaling_3d_scale) + mipmap_bias`.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/textures/defaultFilters/textureMipmapBias`` project setting.
    /// 
    final public var textureMipmapBias: Double {
        get {
            return get_texture_mipmap_bias ()
        }
        
        set {
            set_texture_mipmap_bias (newValue)
        }
        
    }
    
    /// Determines how sharp the upscaled image will be when using the FSR upscaling mode. Sharpness halves with every whole number. Values go from 0.0 (sharpest) to 2.0. Values above 2.0 won't make a visible difference.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/fsrSharpness`` project setting.
    /// 
    final public var fsrSharpness: Double {
        get {
            return get_fsr_sharpness ()
        }
        
        set {
            set_fsr_sharpness (newValue)
        }
        
    }
    
    /// The Variable Rate Shading (VRS) mode that is used for this viewport. Note, if hardware does not support VRS this property is ignored.
    final public var vrsMode: Viewport.VRSMode {
        get {
            return get_vrs_mode ()
        }
        
        set {
            set_vrs_mode (newValue)
        }
        
    }
    
    /// Sets the update mode for Variable Rate Shading (VRS) for the viewport. VRS requires the input texture to be converted to the format usable by the VRS method supported by the hardware. The update mode defines how often this happens. If the GPU does not support VRS, or VRS is not enabled, this property is ignored.
    final public var vrsUpdateMode: Viewport.VRSUpdateMode {
        get {
            return get_vrs_update_mode ()
        }
        
        set {
            set_vrs_update_mode (newValue)
        }
        
    }
    
    /// Texture to use when ``vrsMode`` is set to ``Viewport/VRSMode/texture``.
    /// 
    /// The texture _must_ use a lossless compression format so that colors can be matched precisely. The following VRS densities are mapped to various colors, with brighter colors representing a lower level of shading precision:
    /// 
    final public var vrsTexture: Texture2D? {
        get {
            return get_vrs_texture ()
        }
        
        set {
            set_vrs_texture (newValue)
        }
        
    }
    
    /// Sets the default filter mode used by ``CanvasItem``s in this Viewport. See ``Viewport/DefaultCanvasItemTextureFilter`` for options.
    final public var canvasItemDefaultTextureFilter: Viewport.DefaultCanvasItemTextureFilter {
        get {
            return get_default_canvas_item_texture_filter ()
        }
        
        set {
            set_default_canvas_item_texture_filter (newValue)
        }
        
    }
    
    /// Sets the default repeat mode used by ``CanvasItem``s in this Viewport. See ``Viewport/DefaultCanvasItemTextureRepeat`` for options.
    final public var canvasItemDefaultTextureRepeat: Viewport.DefaultCanvasItemTextureRepeat {
        get {
            return get_default_canvas_item_texture_repeat ()
        }
        
        set {
            set_default_canvas_item_texture_repeat (newValue)
        }
        
    }
    
    /// If `true`, the viewport will process 2D audio streams.
    final public var audioListenerEnable2d: Bool {
        get {
            return is_audio_listener_2d ()
        }
        
        set {
            set_as_audio_listener_2d (newValue)
        }
        
    }
    
    /// If `true`, the viewport will process 3D audio streams.
    final public var audioListenerEnable3d: Bool {
        get {
            return is_audio_listener_3d ()
        }
        
        set {
            set_as_audio_listener_3d (newValue)
        }
        
    }
    
    /// If `true`, the objects rendered by viewport become subjects of mouse picking process.
    /// 
    /// > Note: The number of simultaneously pickable objects is limited to 64 and they are selected in a non-deterministic order, which can be different in each picking process.
    /// 
    final public var physicsObjectPicking: Bool {
        get {
            return get_physics_object_picking ()
        }
        
        set {
            set_physics_object_picking (newValue)
        }
        
    }
    
    /// If `true`, objects receive mouse picking events sorted primarily by their ``CanvasItem/zIndex`` and secondarily by their position in the scene tree. If `false`, the order is undetermined.
    /// 
    /// > Note: This setting is disabled by default because of its potential expensive computational cost.
    /// 
    /// > Note: Sorting happens after selecting the pickable objects. Because of the limitation of 64 simultaneously pickable objects, it is not guaranteed that the object with the highest ``CanvasItem/zIndex`` receives the picking event.
    /// 
    final public var physicsObjectPickingSort: Bool {
        get {
            return get_physics_object_picking_sort ()
        }
        
        set {
            set_physics_object_picking_sort (newValue)
        }
        
    }
    
    /// If `true`, the input_event signal will only be sent to one physics object in the mouse picking process. If you want to get the top object only, you must also enable ``physicsObjectPickingSort``.
    /// 
    /// If `false`, an input_event signal will be sent to all physics objects in the mouse picking process.
    /// 
    /// This applies to 2D CanvasItem object picking only.
    /// 
    final public var physicsObjectPickingFirstOnly: Bool {
        get {
            return get_physics_object_picking_first_only ()
        }
        
        set {
            set_physics_object_picking_first_only (newValue)
        }
        
    }
    
    /// If `true`, the viewport will not receive input events.
    final public var guiDisableInput: Bool {
        get {
            return is_input_disabled ()
        }
        
        set {
            set_disable_input (newValue)
        }
        
    }
    
    /// If `true`, the GUI controls on the viewport will lay pixel perfectly.
    final public var guiSnapControlsToPixels: Bool {
        get {
            return is_snap_controls_to_pixels_enabled ()
        }
        
        set {
            set_snap_controls_to_pixels (newValue)
        }
        
    }
    
    /// If `true`, sub-windows (popups and dialogs) will be embedded inside application window as control-like nodes. If `false`, they will appear as separate windows handled by the operating system.
    final public var guiEmbedSubwindows: Bool {
        get {
            return is_embedding_subwindows ()
        }
        
        set {
            set_embedding_subwindows (newValue)
        }
        
    }
    
    /// Controls how much of the original viewport's size should be covered by the 2D signed distance field. This SDF can be sampled in ``CanvasItem`` shaders and is also used for ``GPUParticles2D`` collision. Higher values allow portions of occluders located outside the viewport to still be taken into account in the generated signed distance field, at the cost of performance. If you notice particles falling through ``LightOccluder2D``s as the occluders leave the viewport, increase this setting.
    /// 
    /// The percentage is added on each axis and on both sides. For example, with the default ``SDFOversize/sdfOversize120Percent``, the signed distance field will cover 20% of the viewport's size outside the viewport on each side (top, right, bottom, left).
    /// 
    final public var sdfOversize: Viewport.SDFOversize {
        get {
            return get_sdf_oversize ()
        }
        
        set {
            set_sdf_oversize (newValue)
        }
        
    }
    
    /// The resolution scale to use for the 2D signed distance field. Higher values lead to a more precise and more stable signed distance field as the camera moves, at the cost of performance.
    final public var sdfScale: Viewport.SDFScale {
        get {
            return get_sdf_scale ()
        }
        
        set {
            set_sdf_scale (newValue)
        }
        
    }
    
    /// The shadow atlas' resolution (used for omni and spot lights). The value is rounded up to the nearest power of 2.
    /// 
    /// > Note: If this is set to `0`, no positional shadows will be visible at all. This can improve performance significantly on low-end systems by reducing both the CPU and GPU load (as fewer draw calls are needed to draw the scene without shadows).
    /// 
    final public var positionalShadowAtlasSize: Int32 {
        get {
            return get_positional_shadow_atlas_size ()
        }
        
        set {
            set_positional_shadow_atlas_size (newValue)
        }
        
    }
    
    /// Use 16 bits for the omni/spot shadow depth map. Enabling this results in shadows having less precision and may result in shadow acne, but can lead to performance improvements on some devices.
    final public var positionalShadowAtlas16Bits: Bool {
        get {
            return get_positional_shadow_atlas_16_bits ()
        }
        
        set {
            set_positional_shadow_atlas_16_bits (newValue)
        }
        
    }
    
    /// The subdivision amount of the first quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad0: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (0)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (0, newValue)
        }
        
    }
    
    /// The subdivision amount of the second quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad1: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (1)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (1, newValue)
        }
        
    }
    
    /// The subdivision amount of the third quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad2: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (2)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (2, newValue)
        }
        
    }
    
    /// The subdivision amount of the fourth quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad3: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (3)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (3, newValue)
        }
        
    }
    
    /// The canvas transform of the viewport, useful for changing the on-screen positions of all child ``CanvasItem``s. This is relative to the global canvas transform of the viewport.
    final public var canvasTransform: Transform2D {
        get {
            return get_canvas_transform ()
        }
        
        set {
            set_canvas_transform (newValue)
        }
        
    }
    
    /// The global canvas transform of the viewport. The canvas transform is relative to this.
    final public var globalCanvasTransform: Transform2D {
        get {
            return get_global_canvas_transform ()
        }
        
        set {
            set_global_canvas_transform (newValue)
        }
        
    }
    
    /// The rendering layers in which this ``Viewport`` renders ``CanvasItem`` nodes.
    final public var canvasCullMask: UInt32 {
        get {
            return get_canvas_cull_mask ()
        }
        
        set {
            set_canvas_cull_mask (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_world_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2736080068)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_world_2d(_ world2d: World2D?) {
        withUnsafePointer(to: world2d?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_world_2d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_world_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2339128592)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_world_2d() -> World2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_world_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_world_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2339128592)!
            }
            
        }
        
    }()
    
    /// Returns the first valid ``World2D`` for this viewport, searching the ``world2d`` property of itself and any Viewport ancestor.
    public final func findWorld2d() -> World2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_find_world_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_canvas_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2761652528)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_canvas_transform(_ xform: Transform2D) {
        withUnsafePointer(to: xform) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_canvas_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_canvas_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_canvas_transform() -> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall(Viewport.method_get_canvas_transform, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_global_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_global_canvas_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2761652528)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_global_canvas_transform(_ xform: Transform2D) {
        withUnsafePointer(to: xform) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_global_canvas_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_global_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_global_canvas_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_global_canvas_transform() -> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall(Viewport.method_get_global_canvas_transform, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_final_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_final_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the viewport's coordinate system to the embedder's coordinate system.
    public final func getFinalTransform() -> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall(Viewport.method_get_final_transform, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_screen_transform")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the Viewport's coordinates to the screen coordinates of the containing window manager window.
    public final func getScreenTransform() -> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall(Viewport.method_get_screen_transform, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_visible_rect")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the visible rectangle in global screen coordinates.
    public final func getVisibleRect() -> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall(Viewport.method_get_visible_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_transparent_background: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_transparent_background")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transparent_background(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_transparent_background, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_transparent_background: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_transparent_background")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func has_transparent_background() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_has_transparent_background, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_hdr_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_hdr_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_hdr_2d(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_hdr_2d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_hdr_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_hdr_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_hdr_2d() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_hdr_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_msaa_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_msaa_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3330258708)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_msaa_2d(_ msaa: Viewport.MSAA) {
        withUnsafePointer(to: msaa.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_msaa_2d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_msaa_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_msaa_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2542055527)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_msaa_2d() -> Viewport.MSAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_msaa_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.MSAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_msaa_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_msaa_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3330258708)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_msaa_3d(_ msaa: Viewport.MSAA) {
        withUnsafePointer(to: msaa.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_msaa_3d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_msaa_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_msaa_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2542055527)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_msaa_3d() -> Viewport.MSAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_msaa_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.MSAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_screen_space_aa: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_screen_space_aa")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3544169389)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_screen_space_aa(_ screenSpaceAa: Viewport.ScreenSpaceAA) {
        withUnsafePointer(to: screenSpaceAa.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_screen_space_aa, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_screen_space_aa: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_screen_space_aa")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1390814124)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_screen_space_aa() -> Viewport.ScreenSpaceAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_screen_space_aa, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.ScreenSpaceAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_use_taa: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_taa")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_taa(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_taa, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_taa: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_taa")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_taa() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_taa, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_debanding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_debanding")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_debanding(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_debanding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_debanding: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_debanding")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_debanding() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_debanding, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_occlusion_culling")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_occlusion_culling(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_occlusion_culling, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_occlusion_culling")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_occlusion_culling() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_occlusion_culling, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_debug_draw")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1970246205)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_draw(_ debugDraw: Viewport.DebugDraw) {
        withUnsafePointer(to: debugDraw.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_debug_draw, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_debug_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_debug_draw")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 579191299)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_debug_draw() -> Viewport.DebugDraw {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_debug_draw, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.DebugDraw (rawValue: _result)!
    }
    
    fileprivate static var method_get_render_info: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_render_info")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 481977019)!
            }
            
        }
        
    }()
    
    /// Returns rendering statistics of the given type. See ``Viewport/RenderInfoType`` and ``Viewport/RenderInfo`` for options.
    public final func getRenderInfo(type: Viewport.RenderInfoType, info: Viewport.RenderInfo) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: type.rawValue) { pArg0 in
            withUnsafePointer(to: info.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Viewport.method_get_render_info, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_texture")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1746695840)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's texture.
    /// 
    /// > Note: When trying to store the current texture (e.g. in a file), it might be completely black or outdated if used too early, especially when used in e.g. ``Node/_ready()``. To make sure the texture you get is correct, you can await [signal RenderingServer.frame_post_draw] signal.
    /// 
    public final func getTexture() -> ViewportTexture? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_physics_object_picking: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_physics_object_picking")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_object_picking(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_physics_object_picking, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_physics_object_picking: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_physics_object_picking")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_object_picking() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_get_physics_object_picking, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_object_picking_sort: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_physics_object_picking_sort")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_object_picking_sort(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_physics_object_picking_sort, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_physics_object_picking_sort: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_physics_object_picking_sort")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_object_picking_sort() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_get_physics_object_picking_sort, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_object_picking_first_only: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_physics_object_picking_first_only")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_object_picking_first_only(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_physics_object_picking_first_only, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_physics_object_picking_first_only: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_physics_object_picking_first_only")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_object_picking_first_only() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_get_physics_object_picking_first_only, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_viewport_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_viewport_rid")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's RID from the ``RenderingServer``.
    public final func getViewportRid() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(Viewport.method_get_viewport_rid, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_push_text_input: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_text_input")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Helper method which calls the `set_text()` method on the currently focused ``Control``, provided that it is defined (e.g. if the focused Control is ``Button`` or ``LineEdit``).
    public final func pushTextInput(text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_push_text_input, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_input: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_input")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3644664830)!
            }
            
        }
        
    }()
    
    /// Triggers the given `event` in this ``Viewport``. This can be used to pass an ``InputEvent`` between viewports, or to locally apply inputs that were sent over the network or saved to a file.
    /// 
    /// If `inLocalCoords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `inLocalCoords` is `true`, the event's position is in viewport coordinates.
    /// 
    /// While this method serves a similar purpose as ``Input/parseInputEvent(_:)``, it does not remap the specified `event` based on project settings like ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse``.
    /// 
    /// Calling this method will propagate calls to child nodes for following methods in the given order:
    /// 
    /// - ``Node/_input(event:)``
    /// 
    /// - ``Control/_guiInput(event:)`` for ``Control`` nodes
    /// 
    /// - ``Node/_shortcutInput(event:)``
    /// 
    /// - ``Node/_unhandledKeyInput(event:)``
    /// 
    /// - ``Node/_unhandledInput(event:)``
    /// 
    /// If an earlier method marks the input as handled via ``setInputAsHandled()``, any later method in this list will not be called.
    /// 
    /// If none of the methods handle the event and ``physicsObjectPicking`` is `true`, the event is used for physics object picking.
    /// 
    public final func pushInput(event: InputEvent?, inLocalCoords: Bool = false) {
        withUnsafePointer(to: event?.handle) { pArg0 in
            withUnsafePointer(to: inLocalCoords) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Viewport.method_push_input, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_push_unhandled_input: GDExtensionMethodBindPtr = {
        let methodName = StringName("push_unhandled_input")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3644664830)!
            }
            
        }
        
    }()
    
    /// Triggers the given `event` in this ``Viewport``. This can be used to pass an ``InputEvent`` between viewports, or to locally apply inputs that were sent over the network or saved to a file.
    /// 
    /// If `inLocalCoords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `inLocalCoords` is `true`, the event's position is in viewport coordinates.
    /// 
    /// Calling this method will propagate calls to child nodes for following methods in the given order:
    /// 
    /// - ``Node/_shortcutInput(event:)``
    /// 
    /// - ``Node/_unhandledKeyInput(event:)``
    /// 
    /// - ``Node/_unhandledInput(event:)``
    /// 
    /// If an earlier method marks the input as handled via ``setInputAsHandled()``, any later method in this list will not be called.
    /// 
    /// If none of the methods handle the event and ``physicsObjectPicking`` is `true`, the event is used for physics object picking.
    /// 
    /// > Note: This method doesn't propagate input events to embedded ``Window``s or ``SubViewport``s.
    /// 
    public final func pushUnhandledInput(event: InputEvent?, inLocalCoords: Bool = false) {
        withUnsafePointer(to: event?.handle) { pArg0 in
            withUnsafePointer(to: inLocalCoords) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Viewport.method_push_unhandled_input, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mouse_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mouse_position")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the mouse's position in this ``Viewport`` using the coordinate system of this ``Viewport``.
    public final func getMousePosition() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(Viewport.method_get_mouse_position, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_warp_mouse: GDExtensionMethodBindPtr = {
        let methodName = StringName("warp_mouse")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Moves the mouse pointer to the specified position in this ``Viewport`` using the coordinate system of this ``Viewport``.
    /// 
    /// > Note: ``warpMouse(position:)`` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
    /// 
    public final func warpMouse(position: Vector2) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_warp_mouse, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_update_mouse_cursor_state: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_mouse_cursor_state")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Force instantly updating the display based on the current mouse cursor position. This includes updating the mouse cursor shape and sending necessary [signal Control.mouse_entered], [signal CollisionObject2D.mouse_entered], [signal CollisionObject3D.mouse_entered] and [signal Window.mouse_entered] signals and their respective `mouse_exited` counterparts.
    public final func updateMouseCursorState() {
        gi.object_method_bind_ptrcall(Viewport.method_update_mouse_cursor_state, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_gui_get_drag_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_get_drag_data")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1214101251)!
            }
            
        }
        
    }()
    
    /// Returns the drag data from the GUI, that was previously returned by ``Control/_getDragData(atPosition:)``.
    public final func guiGetDragData() -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        gi.object_method_bind_ptrcall(Viewport.method_gui_get_drag_data, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_gui_is_dragging: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_is_dragging")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the viewport is currently performing a drag operation.
    /// 
    /// Alternative to ``Node/notificationDragBegin`` and ``Node/notificationDragEnd`` when you prefer polling the value.
    /// 
    public final func guiIsDragging() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_gui_is_dragging, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_gui_is_drag_successful: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_is_drag_successful")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the drag operation is successful.
    public final func guiIsDragSuccessful() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_gui_is_drag_successful, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_gui_release_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_release_focus")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes the focus from the currently focused ``Control`` within this viewport. If no ``Control`` has the focus, does nothing.
    public final func guiReleaseFocus() {
        gi.object_method_bind_ptrcall(Viewport.method_gui_release_focus, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_gui_get_focus_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_get_focus_owner")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Returns the ``Control`` having the focus within this viewport. If no ``Control`` has the focus, returns null.
    public final func guiGetFocusOwner() -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_gui_get_focus_owner, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_gui_get_hovered_control: GDExtensionMethodBindPtr = {
        let methodName = StringName("gui_get_hovered_control")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Returns the ``Control`` that the mouse is currently hovering over in this viewport. If no ``Control`` has the cursor, returns null.
    /// 
    /// Typically the leaf ``Control`` node or deepest level of the subtree which claims hover. This is very useful when used together with ``Node/isAncestorOf(node:)`` to find if the mouse is within a control tree.
    /// 
    public final func guiGetHoveredControl() -> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_gui_get_hovered_control, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_disable_input: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_input")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_input(_ disable: Bool) {
        withUnsafePointer(to: disable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_disable_input, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_input_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_input_disabled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_input_disabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_input_disabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_positional_shadow_atlas_size")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_positional_shadow_atlas_size(_ size: Int32) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_positional_shadow_atlas_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_positional_shadow_atlas_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_positional_shadow_atlas_size")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_positional_shadow_atlas_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Viewport.method_get_positional_shadow_atlas_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_16_bits: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_positional_shadow_atlas_16_bits")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_positional_shadow_atlas_16_bits(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_positional_shadow_atlas_16_bits, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_positional_shadow_atlas_16_bits: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_positional_shadow_atlas_16_bits")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_positional_shadow_atlas_16_bits() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_get_positional_shadow_atlas_16_bits, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_controls_to_pixels: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_snap_controls_to_pixels")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_controls_to_pixels(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_snap_controls_to_pixels, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_snap_controls_to_pixels_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_snap_controls_to_pixels_enabled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_controls_to_pixels_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_snap_controls_to_pixels_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_2d_transforms_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_snap_2d_transforms_to_pixel")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_2d_transforms_to_pixel(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_snap_2d_transforms_to_pixel, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_snap_2d_transforms_to_pixel_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_snap_2d_transforms_to_pixel_enabled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_2d_transforms_to_pixel_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_snap_2d_transforms_to_pixel_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_2d_vertices_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_snap_2d_vertices_to_pixel")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_2d_vertices_to_pixel(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_snap_2d_vertices_to_pixel, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_snap_2d_vertices_to_pixel_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_snap_2d_vertices_to_pixel_enabled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_2d_vertices_to_pixel_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_snap_2d_vertices_to_pixel_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_quadrant_subdiv: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_positional_shadow_atlas_quadrant_subdiv")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2596956071)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets the number of subdivisions to use in the specified quadrant. A higher number of subdivisions allows you to have more shadows in the scene at once, but reduces the quality of the shadows. A good practice is to have quadrants with a varying number of subdivisions and to have as few subdivisions as possible.
    fileprivate final func set_positional_shadow_atlas_quadrant_subdiv(_ quadrant: Int32, _ subdiv: Viewport.PositionalShadowAtlasQuadrantSubdiv) {
        withUnsafePointer(to: quadrant) { pArg0 in
            withUnsafePointer(to: subdiv.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Viewport.method_set_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_positional_shadow_atlas_quadrant_subdiv: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_positional_shadow_atlas_quadrant_subdiv")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2676778355)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns the positional shadow atlas quadrant subdivision of the specified quadrant.
    fileprivate final func get_positional_shadow_atlas_quadrant_subdiv(_ quadrant: Int32) -> Viewport.PositionalShadowAtlasQuadrantSubdiv {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: quadrant) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_get_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Viewport.PositionalShadowAtlasQuadrantSubdiv (rawValue: _result)!
    }
    
    fileprivate static var method_set_input_as_handled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_input_as_handled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the input from propagating further down the ``SceneTree``.
    /// 
    /// > Note: This does not affect the methods in ``Input``, only the way events are propagated.
    /// 
    public final func setInputAsHandled() {
        gi.object_method_bind_ptrcall(Viewport.method_set_input_as_handled, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_is_input_handled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_input_handled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the current ``InputEvent`` has been handled. Input events are not handled until ``setInputAsHandled()`` has been called during the lifetime of an ``InputEvent``.
    /// 
    /// This is usually done as part of input handling methods like ``Node/_input(event:)``, ``Control/_guiInput(event:)`` or others, as well as in corresponding signal handlers.
    /// 
    /// If ``handleInputLocally`` is set to `false`, this method will try finding the first parent viewport that is set to handle input locally, and return its value for ``isInputHandled()`` instead.
    /// 
    public final func isInputHandled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_input_handled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_handle_input_locally: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_handle_input_locally")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_handle_input_locally(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_handle_input_locally, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_handling_input_locally: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_handling_input_locally")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_handling_input_locally() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_handling_input_locally, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_default_canvas_item_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_canvas_item_texture_filter")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2815160100)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_canvas_item_texture_filter(_ mode: Viewport.DefaultCanvasItemTextureFilter) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_default_canvas_item_texture_filter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_canvas_item_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_canvas_item_texture_filter")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 896601198)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_canvas_item_texture_filter() -> Viewport.DefaultCanvasItemTextureFilter {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_default_canvas_item_texture_filter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.DefaultCanvasItemTextureFilter (rawValue: _result)!
    }
    
    fileprivate static var method_set_embedding_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_embedding_subwindows")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_embedding_subwindows(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_embedding_subwindows, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_embedding_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_embedding_subwindows")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_embedding_subwindows() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_embedding_subwindows, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_embedded_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_embedded_subwindows")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a list of the visible embedded ``Window``s inside the viewport.
    /// 
    /// > Note: ``Window``s inside other viewports will not be listed.
    /// 
    public final func getEmbeddedSubwindows() -> ObjectCollection<Window> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(Viewport.method_get_embedded_subwindows, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return ObjectCollection<Window>(content: _result)
    }
    
    fileprivate static var method_set_canvas_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_canvas_cull_mask")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_canvas_cull_mask(_ mask: UInt32) {
        withUnsafePointer(to: mask) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_canvas_cull_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_canvas_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_canvas_cull_mask")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_canvas_cull_mask() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(Viewport.method_get_canvas_cull_mask, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_canvas_cull_mask_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_canvas_cull_mask_bit")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Set/clear individual bits on the rendering layer mask. This simplifies editing this ``Viewport``'s layers.
    public final func setCanvasCullMaskBit(layer: UInt32, enable: Bool) {
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Viewport.method_set_canvas_cull_mask_bit, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_canvas_cull_mask_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_canvas_cull_mask_bit")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns an individual bit on the rendering layer mask.
    public final func getCanvasCullMaskBit(layer: UInt32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: layer) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_get_canvas_cull_mask_bit, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_default_canvas_item_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_default_canvas_item_texture_repeat")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1658513413)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_canvas_item_texture_repeat(_ mode: Viewport.DefaultCanvasItemTextureRepeat) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_default_canvas_item_texture_repeat, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_default_canvas_item_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_default_canvas_item_texture_repeat")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4049774160)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_canvas_item_texture_repeat() -> Viewport.DefaultCanvasItemTextureRepeat {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_default_canvas_item_texture_repeat, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.DefaultCanvasItemTextureRepeat (rawValue: _result)!
    }
    
    fileprivate static var method_set_sdf_oversize: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_sdf_oversize")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2574159017)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sdf_oversize(_ oversize: Viewport.SDFOversize) {
        withUnsafePointer(to: oversize.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_sdf_oversize, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_sdf_oversize: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_sdf_oversize")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2631427510)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_sdf_oversize() -> Viewport.SDFOversize {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_sdf_oversize, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.SDFOversize (rawValue: _result)!
    }
    
    fileprivate static var method_set_sdf_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_sdf_scale")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1402773951)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sdf_scale(_ scale: Viewport.SDFScale) {
        withUnsafePointer(to: scale.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_sdf_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_sdf_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_sdf_scale")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3162688184)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_sdf_scale() -> Viewport.SDFScale {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_sdf_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.SDFScale (rawValue: _result)!
    }
    
    fileprivate static var method_set_mesh_lod_threshold: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_mesh_lod_threshold")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mesh_lod_threshold(_ pixels: Double) {
        withUnsafePointer(to: pixels) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_mesh_lod_threshold, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_mesh_lod_threshold: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_mesh_lod_threshold")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mesh_lod_threshold() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Viewport.method_get_mesh_lod_threshold, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_as_audio_listener_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_as_audio_listener_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_audio_listener_2d(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_as_audio_listener_2d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_audio_listener_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_audio_listener_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_audio_listener_2d() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_audio_listener_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_camera_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_camera_2d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3551466917)!
            }
            
        }
        
    }()
    
    /// Returns the currently active 2D camera. Returns null if there are no active cameras.
    public final func getCamera2d() -> Camera2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_camera_2d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_world_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1400875337)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_world_3d(_ world3d: World3D?) {
        withUnsafePointer(to: world3d?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_world_3d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_world_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 317588385)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_world_3d() -> World3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_world_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_world_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 317588385)!
            }
            
        }
        
    }()
    
    /// Returns the first valid ``World3D`` for this viewport, searching the ``world3d`` property of itself and any Viewport ancestor.
    public final func findWorld3d() -> World3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_find_world_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_use_own_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_own_world_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_own_world_3d(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_own_world_3d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_own_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_own_world_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_own_world_3d() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_own_world_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_camera_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_camera_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2285090890)!
            }
            
        }
        
    }()
    
    /// Returns the currently active 3D camera.
    public final func getCamera3d() -> Camera3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_camera_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_as_audio_listener_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_as_audio_listener_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_audio_listener_3d(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_as_audio_listener_3d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_audio_listener_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_audio_listener_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_audio_listener_3d() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_audio_listener_3d, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_disable_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_disable_3d")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_3d(_ disable: Bool) {
        withUnsafePointer(to: disable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_disable_3d, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_3d_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_3d_disabled")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_3d_disabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_3d_disabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_xr: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_xr")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_xr(_ use: Bool) {
        withUnsafePointer(to: use) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_use_xr, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_xr: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_xr")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_xr() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Viewport.method_is_using_xr, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scaling_3d_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scaling_3d_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1531597597)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scaling_3d_mode(_ scaling3dMode: Viewport.Scaling3DMode) {
        withUnsafePointer(to: scaling3dMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_scaling_3d_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_scaling_3d_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scaling_3d_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2597660574)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scaling_3d_mode() -> Viewport.Scaling3DMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_scaling_3d_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.Scaling3DMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_scaling_3d_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scaling_3d_scale")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scaling_3d_scale(_ scale: Double) {
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_scaling_3d_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_scaling_3d_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scaling_3d_scale")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scaling_3d_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Viewport.method_get_scaling_3d_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_fsr_sharpness: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_fsr_sharpness")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fsr_sharpness(_ fsrSharpness: Double) {
        withUnsafePointer(to: fsrSharpness) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_fsr_sharpness, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_fsr_sharpness: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_fsr_sharpness")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_fsr_sharpness() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Viewport.method_get_fsr_sharpness, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_texture_mipmap_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_texture_mipmap_bias")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture_mipmap_bias(_ textureMipmapBias: Double) {
        withUnsafePointer(to: textureMipmapBias) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_texture_mipmap_bias, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_texture_mipmap_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_texture_mipmap_bias")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture_mipmap_bias() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Viewport.method_get_texture_mipmap_bias, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_vrs_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vrs_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2749867817)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_mode(_ mode: Viewport.VRSMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_vrs_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_vrs_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vrs_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 349660525)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_mode() -> Viewport.VRSMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_vrs_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.VRSMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_vrs_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vrs_update_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3182412319)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_update_mode(_ mode: Viewport.VRSUpdateMode) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_vrs_update_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_vrs_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vrs_update_mode")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2255951583)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_update_mode() -> Viewport.VRSUpdateMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Viewport.method_get_vrs_update_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Viewport.VRSUpdateMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_vrs_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vrs_texture")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_texture(_ texture: Texture2D?) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Viewport.method_set_vrs_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_vrs_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vrs_texture")
        return withUnsafePointer(to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_texture() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Viewport.method_get_vrs_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    // Signals 
    /// Emitted when the size of the viewport is changed, whether by resizing of window, or some other means.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sizeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sizeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "size_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Control) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0]!.toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Control ?? lookupObject (nativeHandle: ptr_0!) ?? Control (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a Control node grabs keyboard focus.
    /// 
    /// > Note: A Control node losing focus doesn't cause this signal to be emitted.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.guiFocusChanged.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var guiFocusChanged: Signal1 { Signal1 (target: self, signalName: "gui_focus_changed") }
    
}

