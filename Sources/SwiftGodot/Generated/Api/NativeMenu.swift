// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A server interface for OS native menus.
/// 
/// ``NativeMenu`` handles low-level access to the OS native global menu bar and popup menus.
/// 
/// > Note: This is low-level API, consider using ``MenuBar`` with ``MenuBar/preferGlobalMenu`` set to `true`, and ``PopupMenu`` with ``PopupMenu/preferNativeMenu`` set to `true`.
/// 
/// To create a menu, use ``createMenu()``, add menu items using `add_*_item` methods. To remove a menu, use ``freeMenu(rid:)``.
/// 
open class NativeMenu: Object {
    /// The shared instance of this class
    public static var shared: NativeMenu = {
        return withUnsafePointer (to: &NativeMenu.godotClassName.content) { ptr in
            NativeMenu (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "NativeMenu" }
    public enum Feature: Int64, CaseIterable, CustomDebugStringConvertible {
        /// ``NativeMenu`` supports native global main menu.
        case globalMenu = 0 // FEATURE_GLOBAL_MENU
        /// ``NativeMenu`` supports native popup menus.
        case popupMenu = 1 // FEATURE_POPUP_MENU
        /// ``NativeMenu`` supports menu open and close callbacks.
        case openCloseCallback = 2 // FEATURE_OPEN_CLOSE_CALLBACK
        /// ``NativeMenu`` supports menu item hover callback.
        case hoverCallback = 3 // FEATURE_HOVER_CALLBACK
        /// ``NativeMenu`` supports menu item accelerator/key callback.
        case keyCallback = 4 // FEATURE_KEY_CALLBACK
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .globalMenu: return ".globalMenu"
                case .popupMenu: return ".popupMenu"
                case .openCloseCallback: return ".openCloseCallback"
                case .hoverCallback: return ".hoverCallback"
                case .keyCallback: return ".keyCallback"
            }
            
        }
        
    }
    
    public enum SystemMenus: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Invalid special system menu ID.
        case invalidMenuId = 0 // INVALID_MENU_ID
        /// Global main menu ID.
        case mainMenuId = 1 // MAIN_MENU_ID
        /// Application (first menu after "Apple" menu on macOS) menu ID.
        case applicationMenuId = 2 // APPLICATION_MENU_ID
        /// "Window" menu ID (on macOS this menu includes standard window control items and a list of open windows).
        case windowMenuId = 3 // WINDOW_MENU_ID
        /// "Help" menu ID (on macOS this menu includes help search bar).
        case helpMenuId = 4 // HELP_MENU_ID
        /// Dock icon right-click menu ID (on macOS this menu include standard application control items and a list of open windows).
        case dockMenuId = 5 // DOCK_MENU_ID
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .invalidMenuId: return ".invalidMenuId"
                case .mainMenuId: return ".mainMenuId"
                case .applicationMenuId: return ".applicationMenuId"
                case .windowMenuId: return ".windowMenuId"
                case .helpMenuId: return ".helpMenuId"
                case .dockMenuId: return ".dockMenuId"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_has_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_feature")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1708975490)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the specified `feature` is supported by the current ``NativeMenu``, `false` otherwise.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func hasFeature(_ feature: NativeMenu.Feature) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: feature.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_has_feature, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_system_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 718213027)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a special system menu is supported.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func hasSystemMenu(menuId: NativeMenu.SystemMenus) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: menuId.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_has_system_menu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_system_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 469707506)!
            }
            
        }
        
    }()
    
    /// Returns RID of a special system menu.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getSystemMenu(menuId: NativeMenu.SystemMenus) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: menuId.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_system_menu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_system_menu_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_system_menu_name")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1281499290)!
            }
            
        }
        
    }()
    
    /// Returns readable name of a special system menu.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getSystemMenuName(menuId: NativeMenu.SystemMenus) -> String {
        let _result = GString ()
        withUnsafePointer(to: menuId.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_system_menu_name, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_create_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new global menu object.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func createMenu() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(method_create_menu, UnsafeMutableRawPointer(mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_has_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `rid` is valid global menu.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func hasMenu(rid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_has_menu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_free_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("free_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Frees a global menu object created by this ``NativeMenu``.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func freeMenu(rid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_free_menu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_size")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2440833711)!
            }
            
        }
        
    }()
    
    /// Returns global menu size.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getSize(rid: RID) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_size, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName("popup")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Shows the global menu at `position` in the screen coordinates.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func popup(rid: RID, position: Vector2i) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_popup, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_interface_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_interface_direction")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets the menu text layout direction from right-to-left if `isRtl` is `true`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setInterfaceDirection(rid: RID, isRtl: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: isRtl) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_set_interface_direction, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_popup_open_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_popup_open_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3379118538)!
            }
            
        }
        
    }()
    
    /// Registers callable to emit after the menu is closed.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setPopupOpenCallback(rid: RID, callback: Callable) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: callback.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_set_popup_open_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_popup_open_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_popup_open_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3170603026)!
            }
            
        }
        
    }()
    
    /// Returns global menu open callback.
    /// 
    /// b]Note:** This method is implemented only on macOS.
    /// 
    public static func getPopupOpenCallback(rid: RID) -> Callable {
        let _result: Callable = Callable ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_popup_open_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_popup_close_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_popup_close_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3379118538)!
            }
            
        }
        
    }()
    
    /// Registers callable to emit when the menu is about to show.
    /// 
    /// > Note: The OS can simulate menu opening to track menu item changes and global shortcuts, in which case the corresponding close callback is not triggered. Use ``isOpened(rid:)`` to check if the menu is currently opened.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setPopupCloseCallback(rid: RID, callback: Callable) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: callback.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_set_popup_close_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_popup_close_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_popup_close_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3170603026)!
            }
            
        }
        
    }()
    
    /// Returns global menu close callback.
    /// 
    /// b]Note:** This method is implemented only on macOS.
    /// 
    public static func getPopupCloseCallback(rid: RID) -> Callable {
        let _result: Callable = Callable ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_popup_close_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_minimum_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_minimum_width")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the minimum width of the global menu.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setMinimumWidth(rid: RID, width: Double) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_set_minimum_width, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_minimum_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_minimum_width")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns global menu minimum width.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getMinimumWidth(rid: RID) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_minimum_width, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_opened: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_opened")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the menu is currently opened.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func isOpened(rid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_is_opened, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_submenu_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_submenu_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1002030223)!
            }
            
        }
        
    }()
    
    /// Adds an item that will act as a submenu of the global menu `rid`. The `submenuRid` argument is the RID of the global menu that will be shown when the item is clicked.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func addSubmenuItem(rid: RID, label: String, submenuRid: RID, tag: Variant?, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: submenuRid.content) { pArg2 in
                    withUnsafePointer(to: tag.content) { pArg3 in
                        withUnsafePointer(to: index) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(method_add_submenu_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2553375659)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addItem(rid: RID, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: callback.content) { pArg2 in
                    withUnsafePointer(to: keyCallback.content) { pArg3 in
                        withUnsafePointer(to: tag.content) { pArg4 in
                            withUnsafePointer(to: accelerator.rawValue) { pArg5 in
                                withUnsafePointer(to: index) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(method_add_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_check_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2553375659)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addCheckItem(rid: RID, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: callback.content) { pArg2 in
                    withUnsafePointer(to: keyCallback.content) { pArg3 in
                        withUnsafePointer(to: tag.content) { pArg4 in
                            withUnsafePointer(to: accelerator.rawValue) { pArg5 in
                                withUnsafePointer(to: index) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(method_add_check_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_icon_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2987595282)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` and icon `icon` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addIconItem(rid: RID, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: icon?.handle) { pArg1 in
                let label = GString(label)
                withUnsafePointer(to: label.content) { pArg2 in
                    withUnsafePointer(to: callback.content) { pArg3 in
                        withUnsafePointer(to: keyCallback.content) { pArg4 in
                            withUnsafePointer(to: tag.content) { pArg5 in
                                withUnsafePointer(to: accelerator.rawValue) { pArg6 in
                                    withUnsafePointer(to: index) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                gi.object_method_bind_ptrcall(method_add_icon_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_icon_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_check_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2987595282)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` and icon `icon` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addIconCheckItem(rid: RID, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: icon?.handle) { pArg1 in
                let label = GString(label)
                withUnsafePointer(to: label.content) { pArg2 in
                    withUnsafePointer(to: callback.content) { pArg3 in
                        withUnsafePointer(to: keyCallback.content) { pArg4 in
                            withUnsafePointer(to: tag.content) { pArg5 in
                                withUnsafePointer(to: accelerator.rawValue) { pArg6 in
                                    withUnsafePointer(to: index) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                gi.object_method_bind_ptrcall(method_add_icon_check_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_radio_check_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2553375659)!
            }
            
        }
        
    }()
    
    /// Adds a new radio-checkable item with text `label` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(rid:idx:checked:)`` for more info on how to control it.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addRadioCheckItem(rid: RID, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: callback.content) { pArg2 in
                    withUnsafePointer(to: keyCallback.content) { pArg3 in
                        withUnsafePointer(to: tag.content) { pArg4 in
                            withUnsafePointer(to: accelerator.rawValue) { pArg5 in
                                withUnsafePointer(to: index) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(method_add_radio_check_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_icon_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_radio_check_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2987595282)!
            }
            
        }
        
    }()
    
    /// Adds a new radio-checkable item with text `label` and icon `icon` to the global menu `rid`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(rid:idx:checked:)`` for more info on how to control it.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addIconRadioCheckItem(rid: RID, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: icon?.handle) { pArg1 in
                let label = GString(label)
                withUnsafePointer(to: label.content) { pArg2 in
                    withUnsafePointer(to: callback.content) { pArg3 in
                        withUnsafePointer(to: keyCallback.content) { pArg4 in
                            withUnsafePointer(to: tag.content) { pArg5 in
                                withUnsafePointer(to: accelerator.rawValue) { pArg6 in
                                    withUnsafePointer(to: index) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                gi.object_method_bind_ptrcall(method_add_icon_radio_check_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_multistate_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_multistate_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1558592568)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` to the global menu `rid`.
    /// 
    /// Contrarily to normal binary items, multistate items can have more than two states, as defined by `maxStates`. Each press or activate of the item will increase the state by one. The default value is defined by `defaultState`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: By default, there's no indication of the current item state, it should be changed manually.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: On Windows, `accelerator` and `keyCallback` are ignored.
    /// 
    public static func addMultistateItem(rid: RID, label: String, maxStates: Int32, defaultState: Int32, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant?, accelerator: Key = .none, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: maxStates) { pArg2 in
                    withUnsafePointer(to: defaultState) { pArg3 in
                        withUnsafePointer(to: callback.content) { pArg4 in
                            withUnsafePointer(to: keyCallback.content) { pArg5 in
                                withUnsafePointer(to: tag.content) { pArg6 in
                                    withUnsafePointer(to: accelerator.rawValue) { pArg7 in
                                        withUnsafePointer(to: index) { pArg8 in
                                            withUnsafePointer(to: UnsafeRawPointersN9(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8)) { pArgs in
                                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 9) { pArgs in
                                                    gi.object_method_bind_ptrcall(method_add_multistate_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_separator")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 448810126)!
            }
            
        }
        
    }()
    
    /// Adds a separator between items to the global menu `rid`. Separators also occupy an index.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func addSeparator(rid: RID, index: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: index) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_add_separator, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_find_item_index_with_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_item_index_with_text")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1362438794)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the specified `text`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func findItemIndexWithText(rid: RID, text: String) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            let text = GString(text)
            withUnsafePointer(to: text.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_find_item_index_with_text, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_find_item_index_with_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_item_index_with_tag")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1260085030)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the specified `tag`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func findItemIndexWithTag(rid: RID, tag: Variant?) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: tag.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_find_item_index_with_tag, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_find_item_index_with_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_item_index_with_submenu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 893635918)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the submenu specified by `submenuRid`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func findItemIndexWithSubmenu(rid: RID, submenuRid: RID) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: submenuRid.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_find_item_index_with_submenu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_checked")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is checked.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func isItemChecked(rid: RID, idx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_is_item_checked, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_checkable")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is checkable in some way, i.e. if it has a checkbox or radio button.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func isItemCheckable(rid: RID, idx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_is_item_checkable, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_radio_checkable")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` has radio button-style checkability.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func isItemRadioCheckable(rid: RID, idx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_is_item_radio_checkable, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639989698)!
            }
            
        }
        
    }()
    
    /// Returns the callback of the item at index `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemCallback(rid: RID, idx: Int32) -> Callable {
        let _result: Callable = Callable ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_key_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_key_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1639989698)!
            }
            
        }
        
    }()
    
    /// Returns the callback of the item accelerator at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getItemKeyCallback(rid: RID, idx: Int32) -> Callable {
        let _result: Callable = Callable ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_key_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_tag")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4069510997)!
            }
            
        }
        
    }()
    
    /// Returns the metadata of the specified item, which might be of any type. You can set it with ``setItemTag(rid:idx:tag:)``, which provides a simple way of assigning context data to items.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemTag(rid: RID, idx: Int32) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_tag, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_get_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_text")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1464764419)!
            }
            
        }
        
    }()
    
    /// Returns the text of the item at index `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemText(rid: RID, idx: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_text, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_submenu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1066463050)!
            }
            
        }
        
    }()
    
    /// Returns the submenu ID of the item at index `idx`. See ``addSubmenuItem(rid:label:submenuRid:tag:index:)`` for more info on how to add a submenu.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemSubmenu(rid: RID, idx: Int32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_submenu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_accelerator")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 316800700)!
            }
            
        }
        
    }()
    
    /// Returns the accelerator of the item at index `idx`. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getItemAccelerator(rid: RID, idx: Int32) -> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_accelerator, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return Key (rawValue: _result)!
    }
    
    fileprivate static var method_is_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_disabled")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is disabled. When it is disabled it can't be selected, or its action invoked.
    /// 
    /// See ``setItemDisabled(rid:idx:disabled:)`` for more info on how to disable an item.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func isItemDisabled(rid: RID, idx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_is_item_disabled, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_hidden")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is hidden.
    /// 
    /// See ``setItemHidden(rid:idx:hidden:)`` for more info on how to hide an item.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func isItemHidden(rid: RID, idx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_is_item_hidden, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_tooltip")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1464764419)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip associated with the specified index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getItemTooltip(rid: RID, idx: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_tooltip, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_state: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_state")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns the state of a multistate item. See ``addMultistateItem(rid:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemState(rid: RID, idx: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_state, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_max_states: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_max_states")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns number of states of a multistate item. See ``addMultistateItem(rid:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemMaxStates(rid: RID, idx: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_max_states, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_icon")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3391850701)!
            }
            
        }
        
    }()
    
    /// Returns the icon of the item at index `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemIcon(rid: RID, idx: Int32) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_icon, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_item_indentation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_indentation_level")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns the horizontal offset of the item at the given `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func getItemIndentationLevel(rid: RID, idx: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_get_item_indentation_level, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_checked")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2658558584)!
            }
            
        }
        
    }()
    
    /// Sets the checkstate status of the item at index `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemChecked(rid: RID, idx: Int32, checked: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: checked) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_checked, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_checkable")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2658558584)!
            }
            
        }
        
    }()
    
    /// Sets whether the item at index `idx` has a checkbox. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemCheckable(rid: RID, idx: Int32, checkable: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: checkable) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_checkable, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_radio_checkable")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2658558584)!
            }
            
        }
        
    }()
    
    /// Sets the type of the item at the specified index `idx` to radio button. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemRadioCheckable(rid: RID, idx: Int32, checkable: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: checkable) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_radio_checkable, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2779810226)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. Callback is emitted when an item is pressed.
    /// 
    /// > Note: The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemCallback(rid: RID, idx: Int32, callback: Callable) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: callback.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_hover_callbacks: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_hover_callbacks")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2779810226)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. The callback is emitted when an item is hovered.
    /// 
    /// > Note: The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemHoverCallbacks(rid: RID, idx: Int32, callback: Callable) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: callback.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_hover_callbacks, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_key_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_key_callback")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2779810226)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. Callback is emitted when its accelerator is activated.
    /// 
    /// > Note: The `keyCallback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemKeyCallback(rid: RID, idx: Int32, keyCallback: Callable) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: keyCallback.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_key_callback, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_tag")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2706844827)!
            }
            
        }
        
    }()
    
    /// Sets the metadata of an item, which may be of any type. You can later get it with ``getItemTag(rid:idx:)``, which provides a simple way of assigning context data to items.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemTag(rid: RID, idx: Int32, tag: Variant?) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: tag.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_tag, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_text")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4153150897)!
            }
            
        }
        
    }()
    
    /// Sets the text of the item at index `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemText(rid: RID, idx: Int32, text: String) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                let text = GString(text)
                withUnsafePointer(to: text.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_text, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_submenu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2310537182)!
            }
            
        }
        
    }()
    
    /// Sets the submenu RID of the item at index `idx`. The submenu is a global menu that would be shown when the item is clicked.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemSubmenu(rid: RID, idx: Int32, submenuRid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: submenuRid.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_submenu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_accelerator")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 786300043)!
            }
            
        }
        
    }()
    
    /// Sets the accelerator of the item at index `idx`. `keycode` can be a single ``Key``, or a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemAccelerator(rid: RID, idx: Int32, keycode: Key) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: keycode.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_accelerator, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_disabled")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2658558584)!
            }
            
        }
        
    }()
    
    /// Enables/disables the item at index `idx`. When it is disabled, it can't be selected and its action can't be invoked.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemDisabled(rid: RID, idx: Int32, disabled: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: disabled) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_disabled, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_hidden")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2658558584)!
            }
            
        }
        
    }()
    
    /// Hides/shows the item at index `idx`. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemHidden(rid: RID, idx: Int32, hidden: Bool) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: hidden) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_hidden, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_tooltip")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4153150897)!
            }
            
        }
        
    }()
    
    /// Sets the ``String`` tooltip of the item at the specified index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemTooltip(rid: RID, idx: Int32, tooltip: String) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                let tooltip = GString(tooltip)
                withUnsafePointer(to: tooltip.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_tooltip, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_state: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_state")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets the state of a multistate item. See ``addMultistateItem(rid:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemState(rid: RID, idx: Int32, state: Int32) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: state) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_state, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_max_states: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_max_states")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets number of state of a multistate item. See ``addMultistateItem(rid:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func setItemMaxStates(rid: RID, idx: Int32, maxStates: Int32) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: maxStates) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_max_states, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_icon")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1388763257)!
            }
            
        }
        
    }()
    
    /// Replaces the ``Texture2D`` icon of the specified `idx`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    /// > Note: This method is not supported by macOS Dock menu items.
    /// 
    public static func setItemIcon(rid: RID, idx: Int32, icon: Texture2D?) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: icon?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_icon, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_indentation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_indentation_level")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets the horizontal offset of the item at the given `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func setItemIndentationLevel(rid: RID, idx: Int32, level: Int32) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: level) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_set_item_indentation_level, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_count")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of items in the global menu `rid`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getItemCount(rid: RID) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_item_count, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_system_menu")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Return `true` is global menu is a special system menu.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func isSystemMenu(rid: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_is_system_menu, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_item")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Removes the item at index `idx` from the global menu `rid`.
    /// 
    /// > Note: The indices of items after the removed item will be shifted by one.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func removeItem(rid: RID, idx: Int32) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: idx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(method_remove_item, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &NativeMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Removes all items from the global menu `rid`.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func clear(rid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_clear, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
}

