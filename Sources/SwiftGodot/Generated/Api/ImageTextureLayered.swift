// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for texture types which contain the data of multiple ``ImageTexture``s. Each image is of the same size and format.
/// 
/// Base class for ``Texture2DArray``, ``Cubemap`` and ``CubemapArray``. Cannot be used directly, but contains all the functions necessary for accessing the derived resource types. See also ``Texture3D``.
open class ImageTextureLayered: TextureLayered {
    override open class var godotClassName: StringName { "ImageTextureLayered" }
    /* Methods */
    fileprivate static var method_create_from_images: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_from_images")
        return withUnsafePointer(to: &ImageTextureLayered.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2785773503)!
            }
            
        }
        
    }()
    
    /// Creates an ``ImageTextureLayered`` from an array of ``Image``s. See ``Image/create(width:height:useMipmaps:format:)`` for the expected data format. The first image decides the width, height, image format and mipmapping setting. The other images _must_ have the same width, height, image format and mipmapping setting.
    /// 
    /// Each ``Image`` represents one `layer`.
    /// 
    public final func createFromImages(_ images: ObjectCollection<Image>) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: images.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(ImageTextureLayered.method_create_from_images, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_update_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_layer")
        return withUnsafePointer(to: &ImageTextureLayered.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3331733361)!
            }
            
        }
        
    }()
    
    /// Replaces the existing ``Image`` data at the given `layer` with this new image.
    /// 
    /// The given ``Image`` must have the same width, height, image format, and mipmapping flag as the rest of the referenced images.
    /// 
    /// If the image format is unsupported, it will be decompressed and converted to a similar and supported ``Image.Format``.
    /// 
    /// The update is immediate: it's synchronized with drawing.
    /// 
    public final func updateLayer(image: Image?, layer: Int32) {
        withUnsafePointer(to: image?.handle) { pArg0 in
            withUnsafePointer(to: layer) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(ImageTextureLayered.method_update_layer, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
}

