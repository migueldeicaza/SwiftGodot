// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif
public class GD {
    fileprivate static var method_sinh: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("sinh")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2140049587)!
        }
        
    }()
    
    /// Returns the hyperbolic sine of `x`.
    /// 
    public static func sinh(x: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_sinh(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_abs: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("abs")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 4776452)!
        }
        
    }()
    
    /// Returns the absolute value of a ``Variant`` parameter `x` (i.e. non-negative value). Supported types: integer, float, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``.
    /// 
    /// > Note: For better type safety, use ``absf()``, ``absi()``, ``Vector2/abs()``, ``Vector2i/abs()``, ``Vector3/abs()``, ``Vector3i/abs()``, ``Vector4/abs()``, or ``Vector4i/abs()``.
    /// 
    public static func abs(x: Variant?) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: x.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_abs(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_sign: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("sign")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 4776452)!
        }
        
    }()
    
    /// Returns the same type of ``Variant`` as `x`, with `-1` for negative values, `1` for positive values, and `0` for zeros. For `nan` values it returns 0.
    /// 
    /// Supported types: integer, float, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``.
    /// 
    /// > Note: For better type safety, use ``signf()``, ``signi()``, ``Vector2/sign()``, ``Vector2i/sign()``, ``Vector3/sign()``, ``Vector3i/sign()``, ``Vector4/sign()``, or ``Vector4i/sign()``.
    /// 
    public static func sign(x: Variant?) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: x.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_sign(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_signf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("signf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2140049587)!
        }
        
    }()
    
    /// Returns `-1.0` if `x` is negative, `1.0` if `x` is positive, and `0.0` if `x` is zero. For `nan` values of `x` it returns 0.0.
    /// 
    public static func signf(x: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_signf(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_signi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("signi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2157319888)!
        }
        
    }()
    
    /// Returns `-1` if `x` is negative, `1` if `x` is positive, and `0` if if `x` is zero.
    /// 
    public static func signi(x: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_signi(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_snappedi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("snappedi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3570758393)!
        }
        
    }()
    
    /// Returns the multiple of `step` that is the closest to `x`.
    /// 
    /// A type-safe version of ``snapped()``, returning an integer.
    /// 
    public static func snappedi(x: Double, step: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: step) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_snappedi(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_nan: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_nan")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is a NaN ("Not a Number" or invalid) value.
    public static func isNan(x: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_nan(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_inf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_inf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is either positive infinity or negative infinity.
    public static func isInf(x: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_inf(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_equal_approx: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_equal_approx")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1400789633)!
        }
        
    }()
    
    /// Returns `true` if `a` and `b` are approximately equal to each other.
    /// 
    /// Here, "approximately equal" means that `a` and `b` are within a small internal epsilon of each other, which scales with the magnitude of the numbers.
    /// 
    /// Infinity values of the same sign are considered equal.
    /// 
    public static func isEqualApprox(a: Double, b: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: a) { pArg0 in
            withUnsafePointer(to: b) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_is_equal_approx(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_zero_approx: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_zero_approx")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is zero or almost zero. The comparison is done using a tolerance calculation with a small internal epsilon.
    /// 
    /// This function is faster than using ``isEqualApprox()`` with one value as zero.
    /// 
    public static func isZeroApprox(x: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_zero_approx(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_finite: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_finite")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3569215213)!
        }
        
    }()
    
    /// Returns whether `x` is a finite value, i.e. it is not ``@GDScript.NAN``, positive infinity, or negative infinity.
    public static func isFinite(x: Double) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_finite(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_ease: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("ease")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns an "eased" value of `x` based on an easing function defined with `curve`. This easing function is based on an exponent. The `curve` can be any floating-point number, with specific values leading to the following behaviors:
    /// 
    /// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/ease_cheatsheet.png">ease() curve values cheatsheet</a>
    /// 
    /// See also ``smoothstep()``. If you need to perform more advanced transitions, use ``Tween/interpolateValue(initialValue:deltaValue:elapsedTime:duration:transType:easeType:)``.
    /// 
    public static func ease(x: Double, curve: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: curve) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_ease(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_step_decimals: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("step_decimals")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2780425386)!
        }
        
    }()
    
    /// Returns the position of the first non-zero digit, after the decimal point. Note that the maximum return value is 10, which is a design decision in the implementation.
    /// 
    public static func stepDecimals(x: Double) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: x) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_step_decimals(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_cubic_interpolate: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("cubic_interpolate")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1090965791)!
        }
        
    }()
    
    /// Cubic interpolates between two values by the factor defined in `weight` with `pre` and `post` values.
    public static func cubicInterpolate(from: Double, to: Double, pre: Double, post: Double, weight: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: pre) { pArg2 in
                    withUnsafePointer(to: post) { pArg3 in
                        withUnsafePointer(to: weight) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    method_cubic_interpolate(&_result, pArgs, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_cubic_interpolate_angle: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("cubic_interpolate_angle")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1090965791)!
        }
        
    }()
    
    /// Cubic interpolates between two rotation values with shortest path by the factor defined in `weight` with `pre` and `post` values. See also ``lerpAngle()``.
    public static func cubicInterpolateAngle(from: Double, to: Double, pre: Double, post: Double, weight: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: pre) { pArg2 in
                    withUnsafePointer(to: post) { pArg3 in
                        withUnsafePointer(to: weight) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    method_cubic_interpolate_angle(&_result, pArgs, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_cubic_interpolate_in_time: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("cubic_interpolate_in_time")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 388121036)!
        }
        
    }()
    
    /// Cubic interpolates between two values by the factor defined in `weight` with `pre` and `post` values.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate()`` by the time values.
    /// 
    public static func cubicInterpolateInTime(from: Double, to: Double, pre: Double, post: Double, weight: Double, toT: Double, preT: Double, postT: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: pre) { pArg2 in
                    withUnsafePointer(to: post) { pArg3 in
                        withUnsafePointer(to: weight) { pArg4 in
                            withUnsafePointer(to: toT) { pArg5 in
                                withUnsafePointer(to: preT) { pArg6 in
                                    withUnsafePointer(to: postT) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                method_cubic_interpolate_in_time(&_result, pArgs, 8)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_cubic_interpolate_angle_in_time: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("cubic_interpolate_angle_in_time")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 388121036)!
        }
        
    }()
    
    /// Cubic interpolates between two rotation values with shortest path by the factor defined in `weight` with `pre` and `post` values. See also ``lerpAngle()``.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate()`` by the time values.
    /// 
    public static func cubicInterpolateAngleInTime(from: Double, to: Double, pre: Double, post: Double, weight: Double, toT: Double, preT: Double, postT: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: pre) { pArg2 in
                    withUnsafePointer(to: post) { pArg3 in
                        withUnsafePointer(to: weight) { pArg4 in
                            withUnsafePointer(to: toT) { pArg5 in
                                withUnsafePointer(to: preT) { pArg6 in
                                    withUnsafePointer(to: postT) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                method_cubic_interpolate_angle_in_time(&_result, pArgs, 8)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_interpolate: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("bezier_interpolate")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1090965791)!
        }
        
    }()
    
    /// Returns the point at the given `t` on a one-dimensional <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a> defined by the given `control1`, `control2`, and `end` points.
    public static func bezierInterpolate(start: Double, control1: Double, control2: Double, end: Double, t: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: start) { pArg0 in
            withUnsafePointer(to: control1) { pArg1 in
                withUnsafePointer(to: control2) { pArg2 in
                    withUnsafePointer(to: end) { pArg3 in
                        withUnsafePointer(to: t) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    method_bezier_interpolate(&_result, pArgs, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_derivative: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("bezier_derivative")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1090965791)!
        }
        
    }()
    
    /// Returns the derivative at the given `t` on a one-dimensional <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a> defined by the given `control1`, `control2`, and `end` points.
    public static func bezierDerivative(start: Double, control1: Double, control2: Double, end: Double, t: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: start) { pArg0 in
            withUnsafePointer(to: control1) { pArg1 in
                withUnsafePointer(to: control2) { pArg2 in
                    withUnsafePointer(to: end) { pArg3 in
                        withUnsafePointer(to: t) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    method_bezier_derivative(&_result, pArgs, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_angle_difference: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("angle_difference")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns the difference between the two angles, in the range of `[-PI, +PI]`. When `from` and `to` are opposite, returns `-PI` if `from` is smaller than `to`, or `PI` otherwise.
    public static func angleDifference(from: Double, to: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_angle_difference(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_lerp_angle: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("lerp_angle")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Linearly interpolates between two angles (in radians) by a `weight` value between 0.0 and 1.0.
    /// 
    /// Similar to ``lerp()``, but interpolates correctly when the angles wrap around ``@GDScript.TAU``. To perform eased interpolation with ``lerpAngle()``, combine it with ``ease()`` or ``smoothstep()``.
    /// 
    /// > Note: This function lerps through the shortest path between `from` and `to`. However, when these two angles are approximately `PI + k * TAU` apart for any integer `k`, it's not obvious which way they lerp due to floating-point precision errors. For example, `lerp_angle(0, PI, weight)` lerps counter-clockwise, while `lerp_angle(0, PI + 5 * TAU, weight)` lerps clockwise.
    /// 
    public static func lerpAngle(from: Double, to: Double, weight: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: weight) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_lerp_angle(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remap: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("remap")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1090965791)!
        }
        
    }()
    
    /// Maps a `value` from range `[istart, istop]` to `[ostart, ostop]`. See also ``lerp()`` and ``inverseLerp()``. If `value` is outside `[istart, istop]`, then the resulting value will also be outside `[ostart, ostop]`. If this is not desired, use ``clamp()`` on the result of this function.
    /// 
    /// For complex use cases where multiple ranges are needed, consider using ``Curve`` or ``Gradient`` instead.
    /// 
    /// > Note: If `istart == istop`, the return value is undefined (most likely NaN, INF, or -INF).
    /// 
    public static func remap(value: Double, istart: Double, istop: Double, ostart: Double, ostop: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: istart) { pArg1 in
                withUnsafePointer(to: istop) { pArg2 in
                    withUnsafePointer(to: ostart) { pArg3 in
                        withUnsafePointer(to: ostop) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    method_remap(&_result, pArgs, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_smoothstep: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("smoothstep")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Returns the result of smoothly interpolating the value of `x` between `0` and `1`, based on the where `x` lies with respect to the edges `from` and `to`.
    /// 
    /// The return value is `0` if `x <= from`, and `1` if `x >= to`. If `x` lies between `from` and `to`, the returned value follows an S-shaped curve that maps `x` between `0` and `1`.
    /// 
    /// This S-shaped curve is the cubic Hermite interpolator, given by `f(y) = 3*y^2 - 2*y^3` where `y = (x-from) / (to-from)`.
    /// 
    /// Compared to ``ease()`` with a curve value of `-1.6521`, ``smoothstep()`` returns the smoothest possible curve with no sudden changes in the derivative. If you need to perform more advanced transitions, use ``Tween`` or ``AnimationPlayer``.
    /// 
    /// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/smoothstep_ease_comparison.png">Comparison between smoothstep() and ease(x, -1.6521) return values</a>
    /// 
    public static func smoothstep(from: Double, to: Double, x: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: x) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_smoothstep(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_move_toward: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("move_toward")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Moves `from` toward `to` by the `delta` amount. Will not go past `to`.
    /// 
    /// Use a negative `delta` value to move away.
    /// 
    public static func moveToward(from: Double, to: Double, delta: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: delta) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_move_toward(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rotate_toward: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("rotate_toward")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Rotates `from` toward `to` by the `delta` amount. Will not go past `to`.
    /// 
    /// Similar to ``moveToward()``, but interpolates correctly when the angles wrap around ``@GDScript.TAU``.
    /// 
    /// If `delta` is negative, this function will rotate away from `to`, toward the opposite angle, and will not go past the opposite angle.
    /// 
    public static func rotateToward(from: Double, to: Double, delta: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: delta) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_rotate_toward(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_linear_to_db: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("linear_to_db")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2140049587)!
        }
        
    }()
    
    /// Converts from linear energy to decibels (audio). This can be used to implement volume sliders that behave as expected (since volume isn't linear).
    /// 
    /// **Example:**
    /// 
    public static func linearToDb(lin: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: lin) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_linear_to_db(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_db_to_linear: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("db_to_linear")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2140049587)!
        }
        
    }()
    
    /// Converts from decibels to linear energy (audio).
    public static func dbToLinear(db: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: db) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_db_to_linear(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_wrap: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("wrap")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3389874542)!
        }
        
    }()
    
    /// Wraps the ``Variant`` `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    /// Variant types integer and float are supported. If any of the arguments is float this function returns a float, otherwise it returns an integer.
    /// 
    public static func wrap(value: Variant?, min: Variant?, max: Variant?) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: value.content) { pArg0 in
            withUnsafePointer(to: min.content) { pArg1 in
                withUnsafePointer(to: max.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_wrap(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_wrapi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("wrapi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 650295447)!
        }
        
    }()
    
    /// Wraps the integer `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    public static func wrapi(value: Int64, min: Int64, max: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: min) { pArg1 in
                withUnsafePointer(to: max) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_wrapi(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_wrapf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("wrapf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Wraps the float `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    /// > Note: If `min` is `0`, this is equivalent to ``fposmod()``, so prefer using that instead.
    /// 
    /// ``wrapf()`` is more flexible than using the ``fposmod()`` approach by giving the user control over the minimum value.
    /// 
    public static func wrapf(value: Double, min: Double, max: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: min) { pArg1 in
                withUnsafePointer(to: max) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_wrapf(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_max: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("max")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3896050336)!
        }
        
    }()
    
    /// Returns the maximum of the given numeric values. This function can take any number of arguments.
    /// 
    /// > Note: When using this on vectors it will _not_ perform component-wise maximum, and will pick the largest value when compared using `x < y`. To perform component-wise maximum, use ``Vector2/max(with:)``, ``Vector2i/max(with:)``, ``Vector3/max(with:)``, ``Vector3i/max(with:)``, ``Vector4/max(with:)``, and ``Vector4i/max(with:)``.
    /// 
    public static func max(arg1: Variant?, arg2: Variant?, _ arguments: Variant?...) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            withUnsafePointer(to: arg2.content) { pArg1 in
                if arguments.isEmpty {
                    withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                            method_max(&_result, pArgs, 2)
                        }
                        
                    }
                    
                } else {
                    // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 2 + arguments.count) { pArgsBuffer in
                        defer { pArgsBuffer.deinitialize() }
                        guard let pArgs = pArgsBuffer.baseAddress else {
                            fatalError("pArgsBuffer.baseAddress is nil")
                        }
                        pArgsBuffer.initializeElement(at: 0, to: pArg0)
                        pArgsBuffer.initializeElement(at: 1, to: pArg1)
                        // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                            defer { contentsBuffer.deinitialize() }
                            guard let contentsPtr = contentsBuffer.baseAddress else {
                                fatalError("contentsBuffer.baseAddress is nil")
                            }
                            
                            for i in 0..<arguments.count {
                                // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                pArgsBuffer.initializeElement(at: 2 + i, to: contentsPtr + i)
                            }
                        
                            method_max(&_result, pArgs, Int32(2 + arguments.count))
                        }                           
                    }
                    
                }
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_maxi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("maxi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3133453818)!
        }
        
    }()
    
    /// Returns the maximum of two integer values.
    /// 
    public static func maxi(a: Int64, b: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: a) { pArg0 in
            withUnsafePointer(to: b) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_maxi(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_maxf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("maxf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns the maximum of two float values.
    /// 
    public static func maxf(a: Double, b: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: a) { pArg0 in
            withUnsafePointer(to: b) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_maxf(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_min: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("min")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3896050336)!
        }
        
    }()
    
    /// Returns the minimum of the given numeric values. This function can take any number of arguments.
    /// 
    /// > Note: When using this on vectors it will _not_ perform component-wise minimum, and will pick the smallest value when compared using `x < y`. To perform component-wise minimum, use ``Vector2/min(with:)``, ``Vector2i/min(with:)``, ``Vector3/min(with:)``, ``Vector3i/min(with:)``, ``Vector4/min(with:)``, and ``Vector4i/min(with:)``.
    /// 
    public static func min(arg1: Variant?, arg2: Variant?, _ arguments: Variant?...) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            withUnsafePointer(to: arg2.content) { pArg1 in
                if arguments.isEmpty {
                    withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                            method_min(&_result, pArgs, 2)
                        }
                        
                    }
                    
                } else {
                    // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 2 + arguments.count) { pArgsBuffer in
                        defer { pArgsBuffer.deinitialize() }
                        guard let pArgs = pArgsBuffer.baseAddress else {
                            fatalError("pArgsBuffer.baseAddress is nil")
                        }
                        pArgsBuffer.initializeElement(at: 0, to: pArg0)
                        pArgsBuffer.initializeElement(at: 1, to: pArg1)
                        // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                            defer { contentsBuffer.deinitialize() }
                            guard let contentsPtr = contentsBuffer.baseAddress else {
                                fatalError("contentsBuffer.baseAddress is nil")
                            }
                            
                            for i in 0..<arguments.count {
                                // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                pArgsBuffer.initializeElement(at: 2 + i, to: contentsPtr + i)
                            }
                        
                            method_min(&_result, pArgs, Int32(2 + arguments.count))
                        }                           
                    }
                    
                }
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_mini: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("mini")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3133453818)!
        }
        
    }()
    
    /// Returns the minimum of two integer values.
    /// 
    public static func mini(a: Int64, b: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: a) { pArg0 in
            withUnsafePointer(to: b) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_mini(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_minf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("minf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns the minimum of two float values.
    /// 
    public static func minf(a: Double, b: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: a) { pArg0 in
            withUnsafePointer(to: b) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_minf(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clamp: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("clamp")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3389874542)!
        }
        
    }()
    
    /// Clamps the `value`, returning a ``Variant`` not less than `min` and not more than `max`. Any values that can be compared with the less than and greater than operators will work.
    /// 
    /// > Note: For better type safety, use ``clampf()``, ``clampi()``, ``Vector2/clamp(min:max:)``, ``Vector2i/clamp(min:max:)``, ``Vector3/clamp(min:max:)``, ``Vector3i/clamp(min:max:)``, ``Vector4/clamp(min:max:)``, ``Vector4i/clamp(min:max:)``, or ``Color/clamp(min:max:)`` (not currently supported by this method).
    /// 
    /// > Note: When using this on vectors it will _not_ perform component-wise clamping, and will pick `min` if `value < min` or `max` if `value > max`. To perform component-wise clamping use the methods listed above.
    /// 
    public static func clamp(value: Variant?, min: Variant?, max: Variant?) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: value.content) { pArg0 in
            withUnsafePointer(to: min.content) { pArg1 in
                withUnsafePointer(to: max.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_clamp(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_clampi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("clampi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 650295447)!
        }
        
    }()
    
    /// Clamps the `value`, returning an integer not less than `min` and not more than `max`.
    /// 
    public static func clampi(value: Int64, min: Int64, max: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: min) { pArg1 in
                withUnsafePointer(to: max) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_clampi(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clampf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("clampf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 998901048)!
        }
        
    }()
    
    /// Clamps the `value`, returning a float not less than `min` and not more than `max`.
    /// 
    public static func clampf(value: Double, min: Double, max: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: min) { pArg1 in
                withUnsafePointer(to: max) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            method_clampf(&_result, pArgs, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_nearest_po2: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("nearest_po2")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2157319888)!
        }
        
    }()
    
    /// Returns the smallest integer power of 2 that is greater than or equal to `value`.
    /// 
    /// > Warning: Due to its implementation, this method returns `0` rather than `1` for values less than or equal to `0`, with an exception for `value` being the smallest negative 64-bit integer (`-9223372036854775808`) in which case the `value` is returned unchanged.
    /// 
    public static func nearestPo2(value: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_nearest_po2(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_pingpong: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("pingpong")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Wraps `value` between `0` and the `length`. If the limit is reached, the next value the function returns is decreased to the `0` side or increased to the `length` side (like a triangle wave). If `length` is less than zero, it becomes positive.
    /// 
    public static func pingpong(value: Double, length: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: length) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_pingpong(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_randomize: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randomize")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1691721052)!
        }
        
    }()
    
    /// Randomizes the seed (or the internal state) of the random number generator. The current implementation uses a number based on the device's time.
    /// 
    /// > Note: This function is called automatically when the project is run. If you need to fix the seed to have consistent, reproducible results, use ``seed()`` to initialize the random number generator.
    /// 
    public static func randomize() {
        method_randomize(nil, nil, 0)
        
    }
    
    fileprivate static var method_randi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randi")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 701202648)!
        }
        
    }()
    
    /// Returns a random unsigned 32-bit integer. Use remainder to obtain a random value in the interval `[0, N - 1]` (where N is smaller than 2^32).
    /// 
    public static func randi() -> Int64 {
        var _result: Int64 = 0
        method_randi(&_result, nil, 0)
        return _result
    }
    
    fileprivate static var method_randf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randf")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2086227845)!
        }
        
    }()
    
    /// Returns a random floating-point value between `0.0` and `1.0` (inclusive).
    /// 
    public static func randf() -> Double {
        var _result: Double = 0.0
        method_randf(&_result, nil, 0)
        return _result
    }
    
    fileprivate static var method_randi_range: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randi_range")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3133453818)!
        }
        
    }()
    
    /// Returns a random signed 32-bit integer between `from` and `to` (inclusive). If `to` is lesser than `from`, they are swapped.
    /// 
    public static func randiRange(from: Int64, to: Int64) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_randi_range(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_randf_range: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randf_range")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns a random floating-point value between `from` and `to` (inclusive).
    /// 
    public static func randfRange(from: Double, to: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: to) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_randf_range(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_randfn: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("randfn")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 92296394)!
        }
        
    }()
    
    /// Returns a <a href="https://en.wikipedia.org/wiki/Normal_distribution">normally-distributed</a>, pseudo-random floating-point value from the specified `mean` and a standard `deviation`. This is also known as a Gaussian distribution.
    /// 
    /// > Note: This method uses the <a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform">Box-Muller transform</a> algorithm.
    /// 
    public static func randfn(mean: Double, deviation: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: mean) { pArg0 in
            withUnsafePointer(to: deviation) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_randfn(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_seed: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("seed")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 382931173)!
        }
        
    }()
    
    /// Sets the seed for the random number generator to `base`. Setting the seed manually can ensure consistent, repeatable results for most random functions.
    /// 
    public static func seed(base: Int64) {
        withUnsafePointer(to: base) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_seed(nil, pArgs, 1)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_rand_from_seed: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("rand_from_seed")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1391063685)!
        }
        
    }()
    
    /// Given a `seed`, returns a ``PackedInt64Array`` of size `2`, where its first element is the randomized integer value, and the second element is the same as `seed`. Passing the same `seed` consistently returns the same array.
    /// 
    /// > Note: "Seed" here refers to the internal state of the pseudo random number generator, currently implemented as a 64 bit integer.
    /// 
    public static func randFromSeed(_ seed: Int64) -> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        withUnsafePointer(to: seed) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_rand_from_seed(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_weakref: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("weakref")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 4776452)!
        }
        
    }()
    
    /// Returns a ``WeakRef`` instance holding a weak reference to `obj`. Returns an empty ``WeakRef`` instance if `obj` is `null`. Prints an error and returns `null` if `obj` is neither ``Object``-derived nor `null`.
    /// 
    /// A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. However, until the object is actually destroyed the weak reference may return the object even if there are no strong references to it.
    /// 
    public static func weakref(obj: Variant?) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: obj.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_weakref(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_typeof: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("typeof")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 326422594)!
        }
        
    }()
    
    /// Returns the internal type of the given `variable`, using the ``Variant.GType`` values.
    /// 
    /// See also ``typeString()``.
    /// 
    public static func typeof(variable: Variant?) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: variable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_typeof(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_type_convert: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("type_convert")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2453062746)!
        }
        
    }()
    
    /// Converts the given `variant` to the given `type`, using the ``Variant.GType`` values. This method is generous with how it handles types, it can automatically convert between array types, convert numeric ``String``s to integer, and converting most things to ``String``.
    /// 
    /// If the type conversion cannot be done, this method will return the default value for that type, for example converting ``Rect2`` to ``Vector2`` will always return ``Vector2/zero``. This method will never show error messages as long as `type` is a valid Variant type.
    /// 
    /// The returned value is a ``Variant``, but the data inside and its type will be the same as the requested type.
    /// 
    public static func typeConvert(variant: Variant?, type: Int64) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: variant.content) { pArg0 in
            withUnsafePointer(to: type) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_type_convert(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_str: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("str")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 32569176)!
        }
        
    }()
    
    /// Converts one or more arguments of any ``Variant`` type to a ``String`` in the best way possible.
    /// 
    public static func str(arg1: Variant?, _ arguments: Variant?...) -> String {
        let _result = GString()
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_str(&_result.content, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_str(&_result.content, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        return _result.description
    }
    
    fileprivate static var method_error_string: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("error_string")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 942708242)!
        }
        
    }()
    
    /// Returns a human-readable name for the given ``GodotError`` code.
    /// 
    public static func errorString(error: Int64) -> String {
        let _result = GString ()
        withUnsafePointer(to: error) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_error_string(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_type_string: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("type_string")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 942708242)!
        }
        
    }()
    
    /// Returns a human-readable name of the given `type`, using the ``Variant.GType`` values.
    /// 
    /// See also ``typeof()``.
    /// 
    public static func typeString(type: Int64) -> String {
        let _result = GString ()
        withUnsafePointer(to: type) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_type_string(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_print: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("print")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Converts one or more arguments of any type to string in the best way possible and prints them to the console.
    /// 
    /// > Note: Consider using ``pushError()`` and ``pushWarning()`` to print error and warning messages instead of ``print()`` or ``printRich()``. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
    /// 
    public static func print(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_print(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_print(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_print_rich: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("print_rich")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Converts one or more arguments of any type to string in the best way possible and prints them to the console.
    /// 
    /// The following BBCode tags are supported: `b`, `i`, `u`, `s`, `indent`, `code`, `url`, `center`, `right`, `color`, `bgcolor`, `fgcolor`.
    /// 
    /// Color tags only support the following named colors: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `pink`, `purple`, `cyan`, `white`, `orange`, `gray`. Hexadecimal color codes are not supported.
    /// 
    /// URL tags only support URLs wrapped by a URL tag, not URLs with a different title.
    /// 
    /// When printing to standard output, the supported subset of BBCode is converted to ANSI escape codes for the terminal emulator to display. Support for ANSI escape codes varies across terminal emulators, especially for italic and strikethrough. In standard output, `code` is represented with faint text but without any font change. Unsupported tags are left as-is in standard output.
    /// 
    /// > Note: Consider using ``pushError()`` and ``pushWarning()`` to print error and warning messages instead of ``print()`` or ``printRich()``. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
    /// 
    /// > Note: On Windows, only Windows 10 and later correctly displays ANSI escape codes in standard output.
    /// 
    /// > Note: Output displayed in the editor supports clickable [code skip-lint]<a href="address">text</a>` tags. The [code skip-lint][url]` tag's `address` value is handled by ``OS/shellOpen(uri:)`` when clicked.
    /// 
    public static func printRich(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_print_rich(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_print_rich(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_printerr: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("printerr")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to strings in the best way possible to standard error line.
    /// 
    public static func printerr(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_printerr(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_printerr(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_printt: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("printt")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to the console with a tab between each argument.
    /// 
    public static func printt(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_printt(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_printt(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_prints: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("prints")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to the console with a space between each argument.
    /// 
    public static func prints(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_prints(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_prints(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_printraw: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("printraw")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to strings in the best way possible to the OS terminal. Unlike ``print()``, no newline is automatically added at the end.
    /// 
    /// > Note: The OS terminal is _not_ the same as the editor's Output dock. The output sent to the OS terminal can be seen when running Godot from a terminal. On Windows, this requires using the `console.exe` executable.
    /// 
    public static func printraw(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_printraw(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_printraw(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_print_verbose: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("print_verbose")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// If verbose mode is enabled (``OS/isStdoutVerbose()`` returning `true`), converts one or more arguments of any type to string in the best way possible and prints them to the console.
    public static func printVerbose(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_print_verbose(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_print_verbose(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_push_error: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("push_error")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Pushes an error message to Godot's built-in debugger and to the OS terminal.
    /// 
    /// > Note: This function does not pause project execution. To print an error message and pause project execution in debug builds, use `assert(false, "test error")` instead.
    /// 
    public static func pushError(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_push_error(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_push_error(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_push_warning: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("push_warning")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2648703342)!
        }
        
    }()
    
    /// Pushes a warning message to Godot's built-in debugger and to the OS terminal.
    /// 
    public static func pushWarning(arg1: Variant?, _ arguments: Variant?...) {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: arg1.content) { pArg0 in
            if arguments.isEmpty {
                withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                        method_push_warning(&_result, pArgs, 1)
                    }
                    
                }
                
            } else {
                // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 1 + arguments.count) { pArgsBuffer in
                    defer { pArgsBuffer.deinitialize() }
                    guard let pArgs = pArgsBuffer.baseAddress else {
                        fatalError("pArgsBuffer.baseAddress is nil")
                    }
                    pArgsBuffer.initializeElement(at: 0, to: pArg0)
                    // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                        defer { contentsBuffer.deinitialize() }
                        guard let contentsPtr = contentsBuffer.baseAddress else {
                            fatalError("contentsBuffer.baseAddress is nil")
                        }
                        
                        for i in 0..<arguments.count {
                            // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                            contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                            // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                            pArgsBuffer.initializeElement(at: 1 + i, to: contentsPtr + i)
                        }
                    
                        method_push_warning(&_result, pArgs, Int32(1 + arguments.count))
                    }                           
                }
                
            }
        }
        
        
    }
    
    fileprivate static var method_var_to_str: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("var_to_str")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 866625479)!
        }
        
    }()
    
    /// Converts a ``Variant`` `variable` to a formatted ``String`` that can then be parsed using ``strToVar()``.
    /// 
    /// Prints:
    /// 
    /// > Note: Converting ``Signal`` or ``Callable`` is not supported and will result in an empty value for these types, regardless of their data.
    /// 
    public static func varToStr(variable: Variant?) -> String {
        let _result = GString ()
        withUnsafePointer(to: variable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_var_to_str(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_str_to_var: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("str_to_var")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1891498491)!
        }
        
    }()
    
    /// Converts a formatted `string` that was returned by ``varToStr()`` to the original ``Variant``.
    /// 
    public static func strToVar(string: String) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        let string = GString(string)
        withUnsafePointer(to: string.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_str_to_var(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_var_to_bytes: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("var_to_bytes")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2947269930)!
        }
        
    }()
    
    /// Encodes a ``Variant`` value to a byte array, without encoding objects. Deserialization can be done with ``bytesToVar()``.
    /// 
    /// > Note: If you need object serialization, see ``varToBytesWithObjects()``.
    /// 
    /// > Note: Encoding ``Callable`` is not supported and will result in an empty value, regardless of the data.
    /// 
    public static func varToBytes(variable: Variant?) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: variable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_var_to_bytes(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bytes_to_var: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("bytes_to_var")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 4249819452)!
        }
        
    }()
    
    /// Decodes a byte array back to a ``Variant`` value, without decoding objects.
    /// 
    /// > Note: If you need object deserialization, see ``bytesToVarWithObjects()``.
    /// 
    public static func bytesToVar(bytes: PackedByteArray) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: bytes.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_bytes_to_var(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_var_to_bytes_with_objects: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("var_to_bytes_with_objects")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2947269930)!
        }
        
    }()
    
    /// Encodes a ``Variant`` value to a byte array. Encoding objects is allowed (and can potentially include executable code). Deserialization can be done with ``bytesToVarWithObjects()``.
    /// 
    /// > Note: Encoding ``Callable`` is not supported and will result in an empty value, regardless of the data.
    /// 
    public static func varToBytesWithObjects(variable: Variant?) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: variable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_var_to_bytes_with_objects(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bytes_to_var_with_objects: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("bytes_to_var_with_objects")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 4249819452)!
        }
        
    }()
    
    /// Decodes a byte array back to a ``Variant`` value. Decoding objects is allowed.
    /// 
    /// > Warning: Deserialized object can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats (remote code execution).
    /// 
    public static func bytesToVarWithObjects(bytes: PackedByteArray) -> Variant? {
        var _result: Variant.ContentType = Variant.zero
        withUnsafePointer(to: bytes.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_bytes_to_var_with_objects(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return Variant(takingOver: _result)
    }
    
    fileprivate static var method_hash: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("hash")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 326422594)!
        }
        
    }()
    
    /// Returns the integer hash of the passed `variable`.
    /// 
    public static func hash(variable: Variant?) -> Int64 {
        var _result: Int64 = 0
        withUnsafePointer(to: variable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_hash(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_instance_from_id: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("instance_from_id")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1156694636)!
        }
        
    }()
    
    /// Returns the ``Object`` that corresponds to `instanceId`. All Objects have a unique instance ID. See also ``Object/getInstanceId()``.
    /// 
    public static func instanceFromId(instanceId: Int64) -> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: instanceId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_instance_from_id(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_instance_id_valid: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_instance_id_valid")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 2232439758)!
        }
        
    }()
    
    /// Returns `true` if the Object that corresponds to `id` is a valid object (e.g. has not been deleted from memory). All Objects have a unique instance ID.
    public static func isInstanceIdValid(id: Int64) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_instance_id_valid(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_instance_valid: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_instance_valid")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 996128841)!
        }
        
    }()
    
    /// Returns `true` if `instance` is a valid Object (e.g. has not been deleted from memory).
    public static func isInstanceValid(instance: Variant?) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: instance.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_is_instance_valid(&_result, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rid_allocate_id: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("rid_allocate_id")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 701202648)!
        }
        
    }()
    
    /// Allocates a unique ID which can be used by the implementation to construct an RID. This is used mainly from native extensions to implement servers.
    public static func ridAllocateId() -> Int64 {
        var _result: Int64 = 0
        method_rid_allocate_id(&_result, nil, 0)
        return _result
    }
    
    fileprivate static var method_rid_from_int64: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("rid_from_int64")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 3426892196)!
        }
        
    }()
    
    /// Creates an RID from a `base`. This is used mainly from native extensions to build servers.
    public static func ridFromInt64(base: Int64) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: base) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    method_rid_from_int64(&_result.content, pArgs, 1)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_same: GDExtensionPtrUtilityFunction = {
        let methodName = StringName("is_same")
        return withUnsafePointer(to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function(ptr, 1409423524)!
        }
        
    }()
    
    /// Returns `true`, for value types, if `a` and `b` share the same value. Returns `true`, for reference types, if the references of `a` and `b` are the same.
    /// 
    /// These are ``Variant`` value types: `null`, [bool], integer, float, ``String``, ``StringName``, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``, ``Rect2``, ``Rect2i``, ``Transform2D``, ``Transform3D``, ``Plane``, ``Quaternion``, ``AABB``, ``Basis``, ``Projection``, ``Color``, ``NodePath``, ``RID``, ``Callable`` and ``Signal``.
    /// 
    /// These are ``Variant`` reference types: ``Object``, ``GDictionary``, ``GArray``, ``PackedByteArray``, ``PackedInt32Array``, ``PackedInt64Array``, ``PackedFloat32Array``, ``PackedFloat64Array``, ``PackedStringArray``, ``PackedVector2Array``, ``PackedVector3Array``, ``PackedVector4Array``, and ``PackedColorArray``.
    /// 
    public static func isSame(a: Variant?, b: Variant?) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: a.content) { pArg0 in
            withUnsafePointer(to: b.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        method_is_same(&_result, pArgs, 2)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

