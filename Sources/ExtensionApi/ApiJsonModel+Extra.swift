//
//  ApiJsonModel+Extra.swift
//
//
//  Created by Miguel de Icaza on 3/24/23.
//

// This file contains manually written extensions for autogenerated model sources.
import Foundation

// Protocols to share features between JGodotExtensionClass and JGodotBuiltinClass
public protocol JGodotEnum {
    var name: String { get }
    var values: [JGodotValueElement] { get }
    var rawBitfield: Bool? { get }
    var isBitfield: Bool { get }}

extension JGodotEnum {
    public var isBitfield: Bool { rawBitfield ?? false }
}

extension JGodotBuiltinClassEnum: JGodotEnum {
    public var rawBitfield: Bool? { nil }
}
extension JGodotGlobalEnumElement: JGodotEnum {
    public var rawBitfield: Bool? { self.isBitfield }
}
public protocol JClassInfo {
    var name: String { get }
    associatedtype EnumType: JGodotEnum
    var enums: [EnumType]? { get }
}

extension JGodotBuiltinClass: JClassInfo {}
extension JGodotExtensionAPIClass: JClassInfo {}

// Used to unify the class methods and the utility methods
public protocol TypeWithMeta {
    var type: String {get}
    var meta: String? { get }
}

public protocol JGodotArgumentType : TypeWithMeta {
    var name: String { get }
    var type: String { get }
    var description: String? { get }
    var defaultValue: String? { get }
    var meta: String? { get }
}

extension JGodotArgumentType {
    public var description: String? { return nil }
    public var defaultValue: String? { return nil }
    public var meta: String? { return nil }
}

extension JGodotArgument: JGodotArgumentType {}
extension JGodotSingleton: JGodotArgumentType {}
extension JGodotMemberElement: JGodotArgumentType {}

public protocol MethodDefinition {
    var name: String { get }
    var isConst: Bool { get }
    var isVararg: Bool { get }
    var isStatic: Bool { get }
    var isVirtual: Bool { get }
    var optionalHash: Int? { get }
    var returnValue: JGodotReturnValue? { get }
    var optionalDescription: String? { get }
    var parameters: [JGodotArgumentType]? { get }
}

extension JGodotClassMethod: MethodDefinition {
    public var optionalHash: Int? { hash }
    public var optionalDescription: String? { self.description ?? nil }
    public var parameters: [JGodotArgumentType]? {
        arguments
    }
}

extension JGodotUtilityFunction: MethodDefinition {
    public var isConst: Bool { true }
    public var isStatic: Bool { true }
    public var isVirtual: Bool { false }
    public var optionalHash: Int? { hash }
    public var optionalDescription: String? { self.description }
    public var returnValue: JGodotReturnValue? {
        if let returnType {
            return JGodotReturnValue (type: returnType, meta: nil)
        } else {
            return nil
        }
    }
    public var parameters: [JGodotArgumentType]? {
        arguments?.map { $0 as JGodotArgumentType }
    }
}


// computed property to preserve snake case in SwiftGodot code
public protocol BriefDescriptionProvider {
    associatedtype BriefDescriptionType
    var brief_description: BriefDescriptionType { get }
    var briefDescription: BriefDescriptionType { get }
}

extension BriefDescriptionProvider where BriefDescriptionType == String {
    public var brief_description: String {
        return briefDescription
    }
}

extension BriefDescriptionProvider where BriefDescriptionType == String? {
    public var brief_description: String? {
        return briefDescription
    }
}
extension JGodotBuiltinClass: BriefDescriptionProvider {}
extension JGodotExtensionAPIClass: BriefDescriptionProvider {}

// hash function implementation to account for hashValue deprecation
extension JSONNull {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(0)
    }
}

// enforcing enums after initialization
extension JGodotExtensionAPI {
    public func validateRecursive() throws {
        try deepValidate(self)
    }
}

private func deepValidate(_ any: Any) throws {
    if let validatable = any as? EnumConstrained {
        try validatable.validate()
    }

    let mirror = Mirror(reflecting: any)

    for child in mirror.children {
        try deepValidate(child.value)
    }
}

public struct InvalidEnumValueError: LocalizedError {
    let field: String
    let value: String
    let options: [String]

    public var errorDescription: String? {
        return "Invalid value '\(value)' for field '\(field)'. Expected one of: \(options.joined(separator: ", "))"
    }
}

public protocol EnumConstrained {
    var validationValue: String { get }
    var validationFieldName: String { get }
    var allowedValues: [String] { get }
}

extension EnumConstrained {

    public func validate() throws {
        if validationValue.isEmpty {
            return
        }
        guard allowedValues.contains(validationValue) else {
            throw InvalidEnumValueError(field: validationFieldName, value: validationValue, options: allowedValues)
        }
    }
}

//Enforcing JGodotMeta enum (in TypeWithMeta protocol)
public enum JGodotMeta: String, Codable, CaseIterable {
    case char32 = "char32"
    case double = "double"
    case float = "float"
    case int16 = "int16"
    case int32 = "int32"
    case int64 = "int64"
    case int8 = "int8"
    case uint16 = "uint16"
    case uint32 = "uint32"
    case uint64 = "uint64"
    case uint8 = "uint8"
}

public protocol JGodotMetaEnumConstrained: EnumConstrained, TypeWithMeta {}

extension JGodotMetaEnumConstrained {
    public var validationValue: String { self.meta ?? "" }

    public var validationFieldName: String { "meta" }

    public var allowedValues: [String] {
        return JGodotMeta.allCases.map { $0.rawValue }
    }
}

extension JGodotArgument: JGodotMetaEnumConstrained {}
extension JGodotSingleton: JGodotMetaEnumConstrained {}
extension JGodotReturnValue: JGodotMetaEnumConstrained {}

//preserving preferred naming convention for JGodotArgumentMeta
public typealias JGodotArgumentMeta = JGodotMeta

////Enforcing JGodotTypeEnum enum
public enum JGodotTypeEnum: String, Codable, CaseIterable {
    case aabb = "AABB"
    case basis = "Basis"
    case color = "Color"
    case int = "int"
    case float = "float"
    case plane = "Plane"
    case projection = "Projection"
    case quaternion = "Quaternion"
    case rect2 = "Rect2"
    case rect2I = "Rect2i"
    case transform2D = "Transform2D"
    case transform3D = "Transform3D"
    case vector2 = "Vector2"
    case vector2I = "Vector2i"
    case vector3 = "Vector3"
    case vector3I = "Vector3i"
    case vector4 = "Vector4"
    case vector4I = "Vector4i"
}

public protocol JGodotTypeEnumConstrained: EnumConstrained {}

extension JGodotTypeEnumConstrained {
    public var allowedValues: [String] {
        return JGodotTypeEnum.allCases.map { $0.rawValue }
    }
    public var swiftTypeName: String {
        guard let enumCase = JGodotTypeEnum(rawValue: validationValue) else {
            return validationValue
        }

        switch enumCase {
        case .int:
            return "Int"
        default:
            return enumCase.rawValue
        }
    }
}

extension JGodotBuiltinClassMemberOffsetClass: JGodotTypeEnumConstrained {
    public var validationValue: String { self.name }
    public var validationFieldName: String { "name" }
}

extension JGodotMemberElement: JGodotTypeEnumConstrained {
    public var validationValue: String { self.type }
    public var validationFieldName: String { "type" }
}

////Enforcing JGodotMemberMeta enum
public enum JGodotMemberMeta: String, Codable, CaseIterable {
    case basis = "Basis"
    case double = "double"
    case float = "float"
    case int32 = "int32"
    case vector2 = "Vector2"
    case vector2I = "Vector2i"
    case vector3 = "Vector3"
    case vector4 = "Vector4"
}


extension JGodotMember: EnumConstrained {
    public var validationValue: String { self.meta }
    public var validationFieldName: String { "meta" }
    public var allowedValues: [String] {
        return JGodotMemberMeta.allCases.map { $0.rawValue }
    }
}

////Enforcing JGodotAPIType enum
public enum JGodotAPIType: String, Codable, CaseIterable {
    case core = "core"
    case editor = "editor"
}

extension JGodotExtensionAPIClass: EnumConstrained {
    public var validationValue: String { self.apiType }
    public var validationFieldName: String { "apiType" }
    public var allowedValues: [String] {
        return JGodotAPIType.allCases.map { $0.rawValue }
    }
}

////Enforcing JGodotCategory enum
public enum JGodotCategory: String, Codable, CaseIterable {
    case general = "general"
    case math = "math"
    case random = "random"
}

extension JGodotUtilityFunction: EnumConstrained {
    public var validationValue: String { self.category }
    public var validationFieldName: String { "category" }
    public var allowedValues: [String] {
        return JGodotCategory.allCases.map { $0.rawValue }
    }
}
